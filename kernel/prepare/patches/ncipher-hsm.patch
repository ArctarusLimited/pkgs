diff --git drivers/misc/Kconfig drivers/misc/Kconfig
index 0f5a49fc7c9e..16184198ba41 100644
--- drivers/misc/Kconfig
+++ drivers/misc/Kconfig
@@ -477,6 +477,7 @@ source "drivers/misc/ti-st/Kconfig"
 source "drivers/misc/lis3lv02d/Kconfig"
 source "drivers/misc/altera-stapl/Kconfig"
 source "drivers/misc/mei/Kconfig"
+source "drivers/misc/nshield/Kconfig"
 source "drivers/misc/vmw_vmci/Kconfig"
 source "drivers/misc/genwqe/Kconfig"
 source "drivers/misc/echo/Kconfig"
diff --git drivers/misc/Makefile drivers/misc/Makefile
index a086197af544..e5999df68673 100644
--- drivers/misc/Makefile
+++ drivers/misc/Makefile
@@ -41,6 +41,7 @@ obj-y				+= ti-st/
 obj-y				+= lis3lv02d/
 obj-$(CONFIG_ALTERA_STAPL)	+=altera-stapl/
 obj-$(CONFIG_INTEL_MEI)		+= mei/
+obj-$(CONFIG_HSM_NCIPHER)   += nshield/
 obj-$(CONFIG_VMWARE_VMCI)	+= vmw_vmci/
 obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lattice-ecp3-config.o
 obj-$(CONFIG_SRAM)		+= sram.o
diff --git drivers/misc/nshield/Kconfig drivers/misc/nshield/Kconfig
new file mode 100644
index 000000000000..107642ba27f2
--- /dev/null
+++ drivers/misc/nshield/Kconfig
@@ -0,0 +1,4 @@
+config HSM_NCIPHER
+	bool "Thales nCipher HSM support"
+	help
+	  This option enables the driver for nShield HSMs
diff --git drivers/misc/nshield/Makefile drivers/misc/nshield/Makefile
new file mode 100644
index 000000000000..3a825eb0a41a
--- /dev/null
+++ drivers/misc/nshield/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_HSM_NCIPHER) := nfp.o
+nfp-objs := hostif.o osif.o i21285.o i21555.o i21555d.o drvlist.o
diff --git drivers/misc/nshield/autoversion.h drivers/misc/nshield/autoversion.h
new file mode 100644
index 000000000000..627e29e6ae9c
--- /dev/null
+++ drivers/misc/nshield/autoversion.h
@@ -0,0 +1,43 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* AUTOGENERATED - DO NOT EDIT */
+#ifndef AUTOVERSION_H
+#define AUTOVERSION_H
+
+#define VERSION_RELEASEMAJOR 2
+#define VERSION_RELEASEMINOR 71
+#define VERSION_RELEASEPATCH 1
+#define VERSION_CHECKINTIMEHIGH 0x00000000UL
+#define VERSION_CHECKINTIMELOW  0x48733ef1UL
+#define VERSION_RELEASE_BUILD 1
+#define VERSION_INFIXCHAR "."
+#define VERSION_SUFFIXCHAR " "
+#define VERSION_CHECKINSTRING "2008-07-08 11:18:25"
+#define VERSION_BUILDSTRING "2008-07-08 11:18:25"
+#define VERSION_SCSISTRING "2*71"
+#define VERSION_SOFTSTRING "2.71.1 "
+#define VERSION_NO "2.71.1cam5"
+#define VERSION_STRING "2.71.1cam5"
+#define VERSION_COMPNAME "nfdrv"
+
+#define VERSION_SUB_IFMODULE "0.20.1cam8"
+#define VERSION_SUB_CUTILS "2.31.1cam6"
+#define VERSION_SUB_BUILD "2.93.1cam5"
+
+#define VERSION_TOOL "nfdrv 2.71.1cam5 built on " __DATE__ " " __TIME__
+
+#endif
diff --git drivers/misc/nshield/devinit.h drivers/misc/nshield/devinit.h
new file mode 100644
index 000000000000..a69314693857
--- /dev/null
+++ drivers/misc/nshield/devinit.h
@@ -0,0 +1,51 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+devinit.h: devinit declaration removed from since 3.8 kernel
+ * (c) Thales UK Limited 2015
+ */
+
+#ifndef DEVINIT_H_
+#define DEVINIT_H_
+
+#include <linux/version.h>
+
+/*
+ * Since linux kernel 3.8 the following macros are removed.
+ */
+
+#if LINUX_VERSION_CODE >= VERSION(3,8,0)
+
+# ifndef __devinit
+#   define __devinit
+# endif
+
+# ifndef __devinitdata
+#   define __devinitdata
+# endif
+
+# ifndef __devexit
+#   define __devexit
+# endif
+
+# ifndef __devexit_p
+#   define __devexit_p
+# endif
+
+#endif /* LINUX_VERSION_CODE >= VERSION(3,8,0) */
+
+#endif /* DEVINIT_H_ */
diff --git drivers/misc/nshield/drvlist.c drivers/misc/nshield/drvlist.c
new file mode 100644
index 000000000000..3f6d78df9b83
--- /dev/null
+++ drivers/misc/nshield/drvlist.c
@@ -0,0 +1,38 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+drvlist.c: nCipher PCI HSM command driver list
+
+ * (c) Thales UK Limited 2015
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#include "nfp_common.h"
+#include "nfp_fixup.h"
+#include "nfp_cmd.h"
+
+const nfpcmd_dev *nfp_drvlist[] = {
+  &i21285_cmddev,
+  &i21555_cmddev,
+  NULL
+};
+
diff --git drivers/misc/nshield/hostif.c drivers/misc/nshield/hostif.c
new file mode 100644
index 000000000000..37825d989dcf
--- /dev/null
+++ drivers/misc/nshield/hostif.c
@@ -0,0 +1,1211 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+hostif.c: nCipher PCI HSM linux host interface
+
+ * (c) Thales UK Limited 2015
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include "nfp_common.h"
+#include "nfp_error.h"
+#include "nfp_fixup.h"
+#include "nfp_hostif.h"
+#include "nfp_dev.h"
+#include "nfp_osif.h"
+#include "nfp_cmd.h"
+#include "devinit.h"
+#include <linux/bitops.h>
+
+#ifdef smp_mb__before_atomic
+#define NF_smp_mb__before_atomic smp_mb__before_atomic
+#else
+#define NF_smp_mb__before_atomic smp_mb__before_clear_bit
+#endif
+NFP_MODULE_LICENSE
+
+/* device list --------------------------------------------------- */
+
+nfp_dev *nfp_dev_list[ NFP_MAXDEV ];
+
+/* this can be set when the driver is loaded, use insmod nfp.o nfp_debug=<n>
+   where <n> = 1 through 4 inclusive */
+int nfp_debug= 1;
+
+/* this can be set when the driver is loaded, use insmod nfp.o nfp_ifvers=<n>
+ * where n = 0 allows any supported interface,
+ *       n > 0 allows only interface versions <= n :
+ * interface versions are listed in nfdev-common.h
+ */
+int nfp_ifvers= NFDEV_IF_PCI_PUSH;
+
+NFP_MODULE_PREAMBLE
+
+/* interface resource allocation */
+
+int nfp_alloc_pci_push( nfp_dev *pdev ) {
+  /* allocate resources needed for PCI Push,
+   * if not already allocated.
+   * return True if successful
+   */
+  if(!pdev->read_buf) {
+    pdev->read_buf= kmalloc( NFP_READBUF_SIZE, GFP_KERNEL | GFP_DMA );
+    if(pdev->read_buf)
+      memset( pdev->read_buf, 0, NFP_READBUF_SIZE);
+  }
+  return (pdev->read_buf != NULL);
+}
+
+void nfp_free_pci_push( nfp_dev *pdev ) {
+  /* free resources allocated to PCI Push */
+  if(pdev->read_buf) {
+    kfree(pdev->read_buf);
+    pdev->read_buf = NULL;
+  }
+}
+
+/* include definition of nfp_set_ifvers() */
+#include "nfp_ifvers.c"
+
+static read_write_t nfp_read( READ_FIRST_ARG
+                              struct file *file,
+                              char *buf,
+                              count_t count
+                              READ_LAST_ARG );
+
+static read_write_t nfp_write( WRITE_FIRST_ARG
+                               struct file *file,
+                               const char *buf,
+                               count_t count
+                               WRITE_LAST_ARG );
+
+#if LINUX_VERSION_CODE >= VERSION(2,1,0)
+static unsigned int nfp_pollselect( struct file *file,poll_table *table );
+#else
+static int nfp_pollselect( struct inode *node,
+                            struct file *file,
+                            int mode,
+                            select_table *table );
+#endif
+
+static int nfp_ioctl( struct inode *node, struct file *file, unsigned int cmd, unsigned long arg );
+#if LINUX_VERSION_CODE >= VERSION(2,6,36)
+static long nfp_unlocked_ioctl( struct file *filp, unsigned int cmd, unsigned long arg );
+#endif
+
+static int nfp_open( struct inode *node, struct file *file );
+static release_t nfp_release( struct inode *node, struct file *file);
+
+static int nfp_num_devices = 0;
+
+#if LINUX_VERSION_CODE >= VERSION(2,6,13)
+static struct class *nfp_class;
+#endif
+
+/* nfp file ops --------------------------------------------------- */
+
+static struct file_operations nfp_fops = {
+#if LINUX_VERSION_CODE >= VERSION(2,3,0)
+  owner:        THIS_MODULE,
+#endif
+  read:         nfp_read,
+  write:        nfp_write,
+  poll:         nfp_pollselect,
+#if LINUX_VERSION_CODE >= VERSION(2,6,36)
+  unlocked_ioctl:        nfp_unlocked_ioctl,
+#else
+  ioctl:        nfp_ioctl,
+#endif
+  open:         nfp_open,
+  release:      nfp_release,
+};
+
+/*--------------------*/
+/*  nfp_isr           */
+/*--------------------*/
+
+#if LINUX_VERSION_CODE >= VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= VERSION(2,6,19)
+static irqreturn_t nfp_isr( int irq, void *context ) {
+#else
+static irqreturn_t nfp_isr( int irq, void *context, struct pt_regs *regs ) {
+#endif
+#else
+static void nfp_isr( int irq, void *context, struct pt_regs *regs ) {
+#endif
+  nfp_dev *pdev;
+  int handled;
+  nfp_err ne;
+
+  pdev = (nfp_dev *)context;
+  if( !pdev ) {
+    nfp_log( NFP_DBG1, "nfp_isr: cannot find dev");
+#if LINUX_VERSION_CODE >= VERSION(2,5,0)
+    return IRQ_NONE;
+#else
+    return;
+#endif
+  }
+
+  nfp_log( NFP_DBG3, "nfp_isr: entered");
+
+  ne= pdev->cmddev->isr( pdev->common.cmdctx, &handled );
+  if(ne)
+    nfp_log( NFP_DBG1, "nfp_isr: cmddev isr failed (%d)", nfp_oserr(ne));
+
+#if LINUX_VERSION_CODE >= VERSION(2,5,0)
+  return IRQ_RETVAL(handled);
+#endif
+
+#if LINUX_VERSION_CODE < VERSION(2,6,19)
+  (void)regs;
+#endif
+}
+
+/*--------------------*/
+/*  nfp_read          */
+/*--------------------*/
+
+void nfp_read_complete(nfp_dev *pdev, int ok) {
+
+  /* could be executed simultaneously by more than one thread -
+   * e.g. from the read isr and from the timeout
+   * we don't want that to happen. */
+  if (test_and_set_bit(CMPLT_BIT, &pdev->rd_outstanding))
+  {
+    return;
+  }
+
+  if(!test_bit(WAIT_BIT, &pdev->rd_outstanding)) {
+    /* we can only get here if the read has already been completed
+       and no new ENSUREREADING request has been received since */
+    nfp_log( NFP_DBG1,"nfp_complete_read: !pdev->rd_outstanding");
+    clear_bit(CMPLT_BIT, &pdev->rd_outstanding);
+    return;
+  }
+
+  /* in case the timer has not expired */
+  del_timer(&pdev->rd_timer);
+
+  pdev->rd_ready= 1;
+  pdev->rd_ok= ok;
+
+  nfp_log( NFP_DBG2,"nfp_complete_read: pdev->rd_outstanding=0");
+
+  NF_smp_mb__before_atomic();
+  clear_bit(CMPLT_BIT, &pdev->rd_outstanding);
+  clear_bit(WAIT_BIT, &pdev->rd_outstanding);
+
+  /* do this last */
+  nfp_wake_up_all( &pdev->rd_queue );
+}
+
+static void nfp_rdtimeout( struct timer_list *timer )
+{
+  nfp_dev *pdev;
+  nfp_log( NFP_DBG1, "nfp_rdtimeout: read timed out");
+
+  pdev = from_timer(pdev, timer, rd_timer);
+  if (!pdev) {
+    nfp_log( NFP_DBG1, "nfp_rdtimeout: NULL pdev." );
+    return;
+  }
+
+  nfp_read_complete(pdev, 0);
+}
+
+static read_write_t nfp_read( READ_FIRST_ARG
+                              struct file *file,
+                              char *buf,
+                              count_t count
+                              READ_LAST_ARG ) {
+  nfp_dev *pdev;
+  int nbytes;
+  int minor;
+  nfp_err ret;
+  (void)unused;
+
+  nfp_log( NFP_DBG2, "nfp_read: entered");
+
+  minor= MINOR( INODE_FROM_FILE( file )->i_rdev );
+  if (minor>NFP_MAXDEV) {
+    nfp_log( NFP_DBG1, "nfp_read: minor out of range." );
+    return -ENODEV;
+  }
+
+  pdev = nfp_dev_list[ minor ];
+  if( !pdev ) {
+    nfp_log( NFP_DBG1, "nfp_read: NULL pdev." );
+    return -ENODEV;
+  }
+
+#if LINUX_VERSION_CODE >= VERSION(2,6,8)
+  if( access_ok( buf, count ) == -EFAULT ) {
+#else
+  if( verify_area( VERIFY_WRITE, buf, count ) == -EFAULT ) {
+#endif
+    nfp_log( NFP_DBG1, "nfp_read: verify area for write failed." );
+    return -EFAULT;
+  }
+
+  if( !pdev->rd_ready ) {
+    nfp_log ( NFP_DBG1, "nfp_read: read called when not ready.");
+    return -EIO;
+  }
+  pdev->rd_ready=0;
+  nbytes= 0;
+  if( !pdev->rd_ok ) {
+    nfp_log ( NFP_DBG2, "nfp_read: read failed");
+    return -EIO;
+  }
+
+  if(pdev->ifvers >= NFDEV_IF_PCI_PUSH) {
+    nfp_log( NFP_DBG3, "nfp_read : copying kernel buffer");
+    nbytes= *(unsigned int *)(pdev->read_buf+4);
+    nbytes= FROM_LE32_MEM(&nbytes);
+    nfp_log( NFP_DBG3, "nfp_read: nbytes %d", nbytes);
+    if(nbytes<0 || nbytes>count) {
+      nfp_log( NFP_DBG1, "nfp_read: bad byte count (%d) from device", nbytes);
+      return -EIO;
+    }
+    nfp_copy_to_user(buf, pdev->read_buf + 8, nbytes);
+  } else {
+    ret = pdev->cmddev->read_block( buf, count, pdev->common.cmdctx,(void *)&nbytes );
+    if( ret != NFP_SUCCESS) {
+      nfp_log( NFP_DBG1, "nfp_read : cmddev->read_block failed ");
+      return nfp_oserr( ret );
+    }
+  }
+  if (nbytes>NFP_READ_MAX) {
+    nfp_log (NFP_DBG1, "nfp_read: nbytes > %d", NFP_READ_MAX);
+    return -EIO;
+  }
+  nfp_log( NFP_DBG2, "nfp_read returns %d.", nbytes );
+
+  return nbytes;
+}
+
+/*--------------------*/
+/*  write             */
+/*--------------------*/
+
+void nfp_write_complete( nfp_dev *pdev, int ok) {
+  /* complete write by waking waiting processes */
+  pdev->wr_ok= ok;
+  nfp_wake_up_all( &pdev->wr_queue );
+}
+
+static read_write_t nfp_write( WRITE_FIRST_ARG
+                               struct file *file,
+                               const char *buf,
+                               count_t count
+                               WRITE_LAST_ARG ) {
+  nfp_dev *pdev;
+  long timeout;
+  int minor;
+  nfp_err  ret;
+  nfp_wait_queue_t wait;
+  (void)unused;
+
+  nfp_log( NFP_DBG2, "nfp_write: Write called");
+
+  minor= MINOR( INODE_FROM_FILE( file )->i_rdev );
+  if (minor>NFP_MAXDEV) {
+    nfp_log( NFP_DBG1, "nfp_write: minor out of range." );
+    return -ENODEV;
+  }
+
+  pdev = nfp_dev_list[ minor ];
+  if( !pdev ) {
+    nfp_log( NFP_DBG1, "nfp_write: write: NULL pdev." );
+    return -ENODEV;
+  }
+
+  if(!pdev->wr_ready) {
+    nfp_log ( NFP_DBG1, "nfp_write: write called when not ready.");
+    return -ENXIO;
+  }
+
+  nfp_log( NFP_DBG2, "nfp_write: sending write request");
+  pdev->wr_ready=0;
+
+  nfp_init_waitqueue_entry( &wait, current);
+  add_wait_queue(&pdev->wr_queue, &wait);
+  current->__state= TASK_UNINTERRUPTIBLE;
+  timeout= 1;
+  ret = pdev->cmddev->write_block( buf, count, pdev->common.cmdctx);
+  if( ret == NFP_SUCCESS ) {
+    nfp_schedule_timeout (NFP_TIMEOUT, timeout);
+  }
+  current->__state= TASK_RUNNING;
+  remove_wait_queue(&pdev->wr_queue, &wait);
+  pdev->wr_ready=1;
+
+  if( ret != NFP_SUCCESS) {
+    if ( ret != NFP_ESTARTING ) {
+      nfp_log(NFP_DBG1,"nfp_write: write_block failed");
+    }
+    return -ENXIO;
+  }
+  if (!timeout) {
+    nfp_log( NFP_DBG1, "nfp_write: module timed out");
+    return -ENXIO;
+  }
+  nfp_log( NFP_DBG2, "nfp_write: returning %d.", pdev->wr_ok?count:-EIO );
+  if (!pdev->wr_ok) {
+    nfp_log( NFP_DBG1, "nfp_write: failed");
+  }
+  return pdev->wr_ok?count:-EIO;
+}
+
+/*--------------------*/
+/*  poll / select     */
+/*--------------------*/
+
+#if LINUX_VERSION_CODE >= VERSION(2,1,0)
+
+static unsigned int nfp_pollselect( struct file *file,poll_table *table ) {
+  struct nfp_dev *pdev;
+  unsigned int mask = 0;
+  int minor = MINOR( INODE_FROM_FILE( file )->i_rdev );
+
+  nfp_log( NFP_DBG2, "nfp_pollselect: entered");
+
+  if (minor>NFP_MAXDEV) {
+    nfp_log( NFP_DBG1, "nfp_pollselect: minor out of range." );
+    return -ENODEV;
+  }
+
+  pdev = nfp_dev_list[ minor ];
+  if( !pdev ) {
+    nfp_log( NFP_DBG1, "nfp_pollselect: NULL pdev." );
+    return -ENODEV;
+  }
+
+  poll_wait( file, &pdev->rd_queue, table );
+  poll_wait( file, &pdev->wr_queue, table );
+
+  if( pdev->rd_ready ) mask |= POLLIN | POLLRDNORM; /* readable */
+  if( pdev->wr_ready ) mask |= POLLOUT | POLLWRNORM; /* writeable */
+
+  return mask;
+}
+
+#else /* LINUX_VERSION_CODE < 0x20100 */
+
+static int nfp_pollselect( struct inode *node,
+                            struct file *file,
+                            int mode,
+                            select_table *table ) {
+  struct nfp_dev *pdev;
+  int minor = MINOR( node->i_rdev );
+
+  nfp_log( NFP_DBG2, "nfp_pollselect: entered");
+
+  if (minor>NFP_MAXDEV) {
+    nfp_log( NFP_DBG1, "nfp_pollselect: minor out of range." );
+    return -ENODEV;
+  }
+
+  pdev = nfp_dev_list[ minor ];
+  if( !pdev ) {
+    nfp_log( NFP_DBG2, "nfp_pollselect: NULL pdev." );
+    return -ENODEV;
+  }
+
+  if( mode == SEL_IN ) {
+    if( pdev->rd_ready ) {
+      return 1; /* readable */
+    }
+    select_wait( &pdev->rd_queue, table );
+
+    return 0;
+  }
+
+  if( mode == SEL_OUT ) {
+    if( pdev->wr_ready ) {
+      if( nfp_debug > 4 )
+      return 1; /* always allow writing */
+    }
+    select_wait( &pdev->wr_queue, table );
+  }
+
+  return 0; /* never exception-able */
+}
+
+#endif
+
+/*--------------------*/
+/*  ioctl             */
+/*--------------------*/
+
+#if LINUX_VERSION_CODE >= VERSION(2,6,36)
+static long nfp_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
+  long ret;
+  int minor;
+  nfp_dev *pdev;
+
+  nfp_log( NFP_DBG2, "nfp_unlocked_ioctl: entered" );
+
+  minor = MINOR( INODE_FROM_FILE( filp )->i_rdev );
+  pdev = nfp_dev_list[ minor ];
+  if( !pdev ) {
+    nfp_log( NFP_DBG1, "nfp_unlocked_ioctl: NULL pdev." );
+    return -ENODEV;
+  }
+  spin_lock (&pdev->spinlock);
+
+  ret = nfp_ioctl(NULL, filp, cmd, arg);
+
+  spin_unlock (&pdev->spinlock);
+  nfp_log( NFP_DBG2, "nfp_unlocked_ioctl: left" );
+  return ret;
+}
+#endif
+
+static int nfp_ioctl( struct inode *node, struct file *file, unsigned int cmd, unsigned long arg ) {
+  nfp_dev *pdev;
+  int minor;
+
+  nfp_log( NFP_DBG2, "nfp_ioctl: entered");
+
+  minor = MINOR( INODE_FROM_FILE( file )->i_rdev );
+
+  if (minor>NFP_MAXDEV) {
+    nfp_log( NFP_DBG1, "nfp_ioctl: minor out of range." );
+    return -ENODEV;
+  }
+
+  pdev = nfp_dev_list[ minor ];
+  if( !pdev ) {
+    nfp_log( NFP_DBG1, "nfp_ioctl: NULL pdev." );
+    return -ENODEV;
+  }
+
+  nfp_log( NFP_DBG2, "nfp_ioctl: entered, minor = %d", minor );
+
+  switch( cmd ) {
+  case NFDEV_IOCTL_ENQUIRY: {
+    nfdev_enquiry_str enq_data;
+    int error;
+
+    nfp_log( NFP_DBG2, "nfp_ioctl: enquiry");
+    enq_data.busno = pdev->common.busno;
+    enq_data.slotno = pdev->common.slotno;
+
+    COPY_TO_USER( (void *)arg, &enq_data, sizeof(enq_data), error );
+    if (error) {
+      nfp_log( NFP_DBG1, "nfp_ioctl: COPY_TO_USER() failed.");
+      return error;
+    }
+    break;
+  }
+
+  case NFDEV_IOCTL_ENSUREREADING_BUG3349:
+  case NFDEV_IOCTL_ENSUREREADING:
+    {
+      unsigned int addr, len;
+      int error;
+      nfp_err ne;
+
+      nfp_log( NFP_DBG2, "nfp_ioctl: ensure device reading.");
+      COPY_FROM_USER( &len, (void *)arg, sizeof(unsigned int),error);
+      if (error) {
+        nfp_log( NFP_DBG1, "nfp_ioctl: COPY_FROM_USER() failed.");
+        return error;
+      }
+      /* signal a read to the module */
+      nfp_log( NFP_DBG2, "nfp_ioctl: signalling read request to module, len = %x.", len );
+      if (len>NFP_READ_MAX) {
+        nfp_log( NFP_DBG1, "nfp_ioctl: len > %x = %x.", NFP_READ_MAX, len );
+        return -EINVAL;
+      }
+
+      if (test_and_set_bit(WAIT_BIT, &pdev->rd_outstanding)) {
+        nfp_log( NFP_DBG1, "nfp_ioctl: ensure reading called with read outstanding");
+        return -EIO;
+      }
+      nfp_log( NFP_DBG2,"nfp_ioctl: pdev->rd_outstanding=1");
+      addr= 0;
+      if(pdev->ifvers >= NFDEV_IF_PCI_PUSH)
+        addr= virt_to_bus(pdev->read_buf);
+      mod_timer(&pdev->rd_timer, jiffies + (NFP_TIMEOUT_SEC * HZ));
+      nfp_log( NFP_DBG2, "nfp_ioctl: read request");
+      ne= pdev->cmddev->ensure_reading( addr, len, pdev->common.cmdctx);
+      if( ne != NFP_SUCCESS ) {
+        del_timer_sync(&pdev->rd_timer);
+        /* make sure that del_timer_sync is done before we clear rd_outstanding */
+        NF_smp_mb__before_atomic();
+        clear_bit(WAIT_BIT, &pdev->rd_outstanding);
+        if (ne != NFP_ESTARTING) {
+          nfp_log(NFP_DBG1, "nfp_ioctl: ensure_reading failed");
+        }
+        return nfp_oserr(ne);
+      }
+    }
+    break;
+
+  case NFDEV_IOCTL_PCI_IFVERS:
+    {
+      int vers, error;
+
+      nfp_log( NFP_DBG2, "nfp_ioctl: NFDEV_IOCTL_PCI_IFVERS");
+      COPY_FROM_USER( &vers, (void *)arg, sizeof(vers),error);
+      if (error) {
+        nfp_log( NFP_DBG1, "nfp_ioctl: COPY_FROM_USER() failed.");
+        return error;
+      }
+      if( test_bit(0, &pdev->rd_outstanding) ) {
+        nfp_log( NFP_DBG1, "nfp_ioctl: can't change interface version as read outstanding");
+        return -EIO;
+      }
+
+      nfp_set_ifvers(pdev, vers);
+    }
+    break;
+
+
+  case NFDEV_IOCTL_CHUPDATE:
+    nfp_log( NFP_DBG2, "nfp_ioctl: channel update");
+    break;
+
+  case NFDEV_IOCTL_DEBUG:
+    {
+      int num, error;
+
+      nfp_log( NFP_DBG2, "nfp_ioctl: debug");
+      COPY_FROM_USER( &num, (void *)arg, sizeof(num),error);
+      if (error) {
+        nfp_log( NFP_DBG1, "nfp_ioctl: COPY_FROM_USER() failed.");
+        return error;
+      }
+      if( pdev->cmddev->debug ) {
+        return nfp_oserr(pdev->cmddev->debug( num, pdev->common.cmdctx));
+      } else
+        return -EINVAL;
+    }
+    break;
+
+  case NFDEV_IOCTL_STATS: {
+    int error;
+
+    nfp_log( NFP_DBG2, "nfp_ioctl: stats");
+
+    COPY_TO_USER( (void *)arg,
+                  &pdev->common.stats,
+                  sizeof(nfdev_stats_str),
+                  error );
+    if (error) {
+      nfp_log( NFP_DBG1, "nfp_ioctl: COPY_TO_USER() failed.");
+      return error;
+    }
+    break;
+  }
+
+  case NFDEV_IOCTL_CONTROL: {
+    int error;
+    nfdev_control_str control;
+    
+    nfp_log( NFP_DBG2, "nfp_ioctl: control");
+    COPY_FROM_USER( &control, (void *)arg, sizeof control, error);
+    if (error) {
+      nfp_log( NFP_DBG1, "nfp_ioctl: COPY_FROM_USER() failed for _CONTROL.");
+      return error;
+    }
+    if(!pdev->cmddev->setcontrol) {
+      nfp_log( NFP_DBG1, "nfp_ioctl: setcontrol not supported for this device.");
+      return -EINVAL;
+    }
+    nfp_log( NFP_DBG2, "nfp_ioctl: updating HSM control register to %x.",
+             control );
+    return nfp_oserr(pdev->cmddev->setcontrol(&control, pdev->common.cmdctx));
+  }
+
+  case NFDEV_IOCTL_STATUS: {
+    int error;
+    nfdev_status_str status;
+    nfp_log( NFP_DBG2, "nfp_ioctl: state");
+    if(!pdev->cmddev->getstatus) {
+      nfp_log( NFP_DBG1, "nfp_ioctl: getstatus not supported for this device.");
+      return -EINVAL;
+    }
+    if((error = pdev->cmddev->getstatus(&status, pdev->common.cmdctx)))
+       return nfp_oserr(error);
+    COPY_TO_USER( (void *)arg, &status, sizeof(status), error );
+    if (error) {
+      nfp_log( NFP_DBG1, "nfp_ioctl: COPY_TO_USER() failed for _STATUS.");
+      return error;
+    }
+    break;
+  }
+
+  default:
+    nfp_log( NFP_DBG1, "nfp_ioctl: unknown ioctl." );
+    return -EINVAL;
+    break;
+  }
+
+  return 0;
+}
+
+/*--------------------*/
+/*  open              */
+/*--------------------*/
+
+static int nfp_open( struct inode *node, struct file *file ) {
+  nfp_dev *pdev;
+  nfp_err ne;
+  int minor = MINOR( INODE_FROM_FILE( file )->i_rdev );
+
+  nfp_log( NFP_DBG2, "nfp_open: called, file = %p.", file );
+
+  if (minor>NFP_MAXDEV) {
+    nfp_log( NFP_DBG1, "nfp_open: minor out of range." );
+    return -ENODEV;
+  }
+
+  pdev = nfp_dev_list[ minor ];
+  if( !pdev ) {
+    nfp_log( NFP_DBG1, "nfp_open: cannot find dev %d.", minor );
+    return -ENODEV;
+  }
+
+  spin_lock (&pdev->spinlock);
+  if (pdev->busy) {
+    nfp_log( NFP_DBG1, "nfp_open: device busy." );
+    spin_unlock (&pdev->spinlock);
+    return -EBUSY;
+  }
+  pdev->busy= 1;
+  spin_unlock (&pdev->spinlock);
+
+  /* use oldest possible interface until told otherwise */
+  pdev->ifvers= NFDEV_IF_STANDARD;
+  nfp_log( NFP_DBG3, "nfp_open: setting ifvers %d", pdev->ifvers);
+  pdev->rd_ready= 0; /* drop any old data */
+
+  ne= pdev->cmddev->open(pdev->common.cmdctx);
+  if( ne != NFP_SUCCESS) {
+    nfp_log( NFP_DBG1, "nfp_open : cmddev->open ");
+    return nfp_oserr(ne);
+  }
+
+#if LINUX_VERSION_CODE < VERSION(2,5,0)
+  MOD_INC_USE_COUNT;
+#endif
+
+  nfp_log( NFP_DBG2, "nfp_open: done");
+
+  return 0;
+}
+
+/*--------------------*/
+/*  release           */
+/*--------------------*/
+
+static release_t nfp_release( struct inode *node, struct file *file ) {
+  nfp_dev *pdev;
+  long timeout;
+  nfp_err ret;
+  int minor = MINOR( INODE_FROM_FILE( file )->i_rdev );
+
+  nfp_log( NFP_DBG2, "nfp_release: called, file = %p.", file );
+
+  if (minor>NFP_MAXDEV) {
+    nfp_log( NFP_DBG1, "nfp_release: minor out of range." );
+    RELEASE_RETURN( -ENODEV );
+  }
+
+  pdev = nfp_dev_list[ minor ];
+  if( !pdev ) {
+    nfp_log( NFP_DBG1, "nfp_release: cannot find dev.");
+    RELEASE_RETURN( -ENODEV );
+  }
+
+  {
+    nfp_wait_queue_t wait;
+    timeout= 1;
+    nfp_init_waitqueue_entry( &wait, current);
+    current->__state= TASK_UNINTERRUPTIBLE;
+    add_wait_queue(&pdev->rd_queue, &wait);
+    if (test_bit(WAIT_BIT, &pdev->rd_outstanding)) {
+      nfp_log( NFP_DBG2, "nfp_release: read outstanding");
+      nfp_schedule_timeout (NFP_TIMEOUT, timeout);
+      nfp_log( NFP_DBG3, "nfp_release: finished waiting");
+    }
+    current->__state= TASK_RUNNING;
+    remove_wait_queue(&pdev->rd_queue, &wait);
+    if (!timeout) {
+      nfp_log( NFP_DBG1, "nfp_release: outstanding read timed out");
+    }
+  }
+
+  spin_lock (&pdev->spinlock);
+  if (test_bit(WAIT_BIT, &pdev->rd_outstanding)) {
+    del_timer_sync(&pdev->rd_timer);
+    /* make sure that del_timer_sync is done before we clear rd_outstanding */
+    NF_smp_mb__before_atomic();
+    clear_bit(WAIT_BIT, &pdev->rd_outstanding);
+  }
+  pdev->busy= 0;
+  spin_unlock (&pdev->spinlock);
+
+  ret = pdev->cmddev->close(pdev->common.cmdctx);
+  if( ret != NFP_SUCCESS) {
+    nfp_log( NFP_DBG1, "nfp_close : cmddev->close failed");
+    return nfp_oserr( ret );
+  }
+
+#if LINUX_VERSION_CODE < VERSION(2,5,0)
+  MOD_DEC_USE_COUNT;
+#endif
+  RELEASE_RETURN( 0 );
+}
+
+/* device setup -------------------------------------------------- */
+
+static void nfp_dev_destroy( nfp_dev *pdev ) {
+  int i;
+  nfp_log(NFP_DBG2,"nfp_dev_destroy: entered");
+  if( pdev ) {
+    nfp_free_pci_push(pdev);
+
+    if( pdev->irq ) {
+      nfp_log(NFP_DBG3, "nfp_dev_destroy: freeing irq, %x", pdev->irq);
+      free_irq( pdev->irq, pdev );
+    }
+    for(i=0;i<6;i++)
+      if( pdev->iosize[i] ) {
+        nfp_log(NFP_DBG3, "nfp_dev_destroy: freeing IO BAR, %d", i);
+        release_region( (unsigned long)pdev->common.bar[i], pdev->iosize[i]);
+      }
+    for(i=0;i<6;i++)
+      if( pdev->common.bar[i] && !pdev->iosize[i] ) {
+        nfp_log(NFP_DBG3, "nfp_dev_destroy: freeing MEM BAR, %d", i);
+        IOUNMAP( pdev->common.bar[i] );
+      }
+    nfp_log(NFP_DBG3,"nfp_dev_destroy: freeing pdev");
+    kfree( pdev );
+  }
+}
+
+static int nfp_setup( const nfpcmd_dev *cmddev, unsigned char bus, unsigned char slot, unsigned int bar[6], unsigned char irq_line, struct pci_dev *pcidev) {
+  nfp_dev *pdev;
+  nfp_err ne;
+  int i;
+
+  nfp_log( NFP_DBG2, "nfp_setup: Found '%s' at bus %x, slot %x, irq %d.", cmddev->name, bus, slot, irq_line);
+
+  pdev = (struct nfp_dev *)kmalloc( sizeof( *pdev ), GFP_KERNEL);
+  if( !pdev ) {
+    nfp_log( NFP_DBG1, "nfp_setup: failed to allocate device structure." );
+    goto fail_continue;
+  }
+  nfp_log( NFP_DBG2, "nfp_setup: allocated device structure.");
+  memset( pdev, 0, sizeof( *pdev ) );
+
+  pdev->common.busno= bus;
+  pdev->pcidev= pcidev;
+  pdev->common.slotno= slot;
+  pdev->cmddev= cmddev;
+
+  for(i=0;i<6;i++) {
+    if(cmddev->bar_sizes[i] & PCI_BASE_ADDRESS_SPACE_IO) {
+#if LINUX_VERSION_CODE >= VERSION(2,6,0)
+
+      /* Kernel 2.6.x did away with check_region(), observing that it
+       * suffered from race conditions. In fact, some 2.6 drivers don't
+       * even bother to check the return from request_region(), but we
+       * prefer to be verbose. */
+      if (!request_region(bar[i], cmddev->bar_sizes[i] & ~0xF, cmddev->name)) {
+        nfp_log( NFP_DBG1, "nfp_setup: request_region failed, %x, %x, %d (%s)", bar[i], cmddev->bar_sizes[i], i, cmddev->name );
+        goto fail_continue;
+      }
+
+#else
+      if( check_region( bar[i], cmddev->bar_sizes[i] & ~0xF ) ) {
+        nfp_log( NFP_DBG1, "nfp_setup: check_region failed, %x, %x, %d", bar[i], cmddev->bar_sizes[i], i );
+        goto fail_continue;
+      }
+      request_region( bar[i], cmddev->bar_sizes[i] & ~0xF, cmddev->name );
+#endif
+
+      pdev->common.bar[i]= (unsigned char *)((long)bar[i] & ~0xF);
+      pdev->iosize[i]= cmddev->bar_sizes[i] & ~0xF;
+    } else if(cmddev->bar_sizes[i]) {
+      pdev->common.bar[i]= IOREMAP( bar[i], cmddev->bar_sizes[i] & ~0xF);
+      if( pdev->common.bar[i] == NULL ) {
+        nfp_log( NFP_DBG1, "nfp_setup: unable to map memory BAR %d, (0x%x).", i, bar[i] );
+        goto fail_continue;
+      }
+    }
+  }
+
+  pdev->read_buf= NULL;
+
+  nfp_init_waitqueue_head( &pdev->wr_queue );
+  nfp_init_waitqueue_head( &pdev->rd_queue );
+
+  pdev->wr_ready= 1;
+
+  spinlock_init( &pdev->spinlock );
+
+  if( request_irq( irq_line,
+		   nfp_isr,
+#if  LINUX_VERSION_CODE >= VERSION(2,6,22)
+		   IRQF_SHARED,
+#else
+		   SA_SHIRQ,
+#endif
+		   cmddev->name,
+		   pdev ) ) {
+    nfp_log( NFP_DBG1, "nfp_setup: unable to claim interrupt." );
+    goto fail_continue;
+  }
+  pdev->irq= irq_line;
+
+  ne = pdev->cmddev->create(&pdev->common);
+  if( ne != NFP_SUCCESS) {
+    nfp_log( NFP_DBG1, "nfp_setup: failed to create command device (%d)", nfp_oserr(ne));
+    goto fail_continue;
+  }
+  pdev->common.dev= pdev;
+
+  memset( &(pdev->common.stats), 0, sizeof( pdev->common.stats ) );
+
+#if LINUX_VERSION_CODE >= VERSION(2,4,0)
+  pci_set_drvdata( pcidev, pdev );
+#endif
+
+  /* setup timeout timer */
+  timer_setup(&pdev->rd_timer, nfp_rdtimeout, 0);
+  mod_timer(&pdev->rd_timer, jiffies + (NFP_TIMEOUT_SEC * HZ));
+
+  nfp_dev_list[ nfp_num_devices ] =  pdev;
+#if LINUX_VERSION_CODE >= VERSION(2,6,13)
+  device_create(nfp_class,
+                NULL, /* parent */
+                MKDEV(NFP_MAJOR, nfp_num_devices),
+#if LINUX_VERSION_CODE >= VERSION(2,6,27)
+                NULL, /* drvdata */
+#endif
+                "nfp%d",
+                nfp_num_devices);
+#endif
+  nfp_log( NFP_DBG2, "nfp_setup: nfp_num_devices= %d, pdev = %p.", nfp_num_devices, pdev );
+  nfp_num_devices ++;
+  return 1;
+
+fail_continue:
+  nfp_dev_destroy(pdev);
+
+  return 0;
+}
+
+/* device probing ---------------------------------------------------------- */
+
+#if LINUX_VERSION_CODE >= VERSION(2,4,0)
+static int __devinit nfp_pci_probe (struct pci_dev *dev,
+                                    const struct pci_device_id *id)
+{
+  int err, i;
+  unsigned int bar[6];
+  const nfpcmd_dev *cmddev = nfp_drvlist[id->driver_data];
+
+  nfp_log(NFP_DBG2,"nfp_pci_probe: entered");
+
+  err = pci_enable_device(dev);
+  if (err) {
+    nfp_log(NFP_DBG1,"nfp_pci_probe: pci_enable_device failed");
+    return err;
+  }
+
+  pci_set_master(dev);
+
+  for(i=0;i<6;i++) {
+    if (pci_resource_len( dev, i ) < (cmddev->bar_sizes[i] & ~0xF)) {
+      nfp_log( NFP_DBG1,
+               "nfp_pci_probe: unexpected pci mem address range %x, %x, %d",
+               pci_resource_len( dev, i ),
+               cmddev->bar_sizes[i], i);
+      return -ENODEV;
+    }
+    bar[i]= pci_resource_start( dev, i );
+  }
+  nfp_log( NFP_DBG2,
+           "nfp_probe: devname %s, slotname %s, busname %s",
+#if LINUX_VERSION_CODE >= VERSION(2,5,0)
+#if LINUX_VERSION_CODE <= VERSION(2,6,8)
+           pci_pretty_name(dev),
+#else
+           "",
+#endif
+           pci_name(dev),
+#else
+           dev->name,
+           dev->slot_name,
+#endif
+           dev->bus->name);
+
+  err = nfp_setup( cmddev,
+                   dev->bus->number,
+                   PCI_SLOT(dev->devfn),
+                   bar,
+                   dev->irq,
+                   dev );
+  if (!err) {
+    return -ENODEV;
+  }
+  return 0;
+}
+
+static void __devexit nfp_pci_remove (struct pci_dev *dev)
+{
+  int index;
+  nfp_dev *pdev;
+
+  nfp_log(NFP_DBG2,"nfp_pci_remove: entered");
+
+  pdev = pci_get_drvdata( dev );
+  if(pdev) {
+    if(pdev->cmddev)
+      pdev->cmddev->destroy(pdev->common.cmdctx);
+    nfp_dev_destroy(pdev);
+    index = 0;
+    while( index < NFP_MAXDEV ) {
+      if( nfp_dev_list[ index ] == pdev ) {
+        nfp_dev_list[ index ] = NULL;
+#if LINUX_VERSION_CODE >= VERSION(2,6,13)
+        device_destroy(nfp_class, MKDEV(NFP_MAJOR, index));
+#endif
+      }
+      index++;
+    }
+  }
+}
+
+#else /* LINUX_VERSION_CODE < VERSION(2,4,0) */
+#if LINUX_VERSION_CODE >= VERSION(2,1,0)
+
+static int nfp_probe( const nfpcmd_dev *cmddev ) {
+  struct pci_dev *pcidev;
+  int i;
+  unsigned int bar[6];
+  unsigned short sub_vendor, sub_device;
+
+  pcidev= NULL;
+  while( (pcidev= pci_find_device(cmddev->vendorid, cmddev->deviceid, pcidev)) != NULL ) {
+    pci_read_config_word( pcidev, PCI_SUBSYSTEM_VENDOR_ID, &sub_vendor );
+    pci_read_config_word( pcidev, PCI_SUBSYSTEM_ID, &sub_device );
+    if( sub_vendor != cmddev->sub_vendorid )
+      continue;
+    if( sub_device != cmddev->sub_deviceid )
+      continue;
+    for(i=0;i<6;i++) {
+      bar[i]= pcidev->base_address[i] & ~0xF;
+    }
+    nfp_setup(cmddev, pcidev->bus->number, PCI_SLOT(pcidev->devfn), bar, pcidev->irq, pcidev);
+  }
+  return 0;
+}
+
+#else /* LINUX_VERSION_CODE < VERSION(2,1,0) */
+
+static int nfp_probe( const nfpcmd_dev *cmddev ) {
+  int pci_index;
+  int i, ret;
+  unsigned char pci_bus, pci_device_fn;
+  unsigned int bar[6];
+  unsigned char pci_irq_line;
+  unsigned short vendor, device, sub_vendor, sub_device;
+
+  for( pci_index=0; ; pci_index++ ) {
+    ret = pcibios_find_device( cmddev->vendorid,
+                               cmddev->deviceid,
+                               pci_index,
+                               &pci_bus,
+                               &pci_device_fn );
+    if( ret != PCIBIOS_SUCCESSFUL )
+      break;
+
+    pcibios_read_config_word( pci_bus, pci_device_fn,
+                              PCI_VENDOR_ID, &vendor );
+    pcibios_read_config_word( pci_bus, pci_device_fn,
+                              PCI_DEVICE_ID, &device );
+    pcibios_read_config_word( pci_bus, pci_device_fn,
+                              PCI_SUBSYSTEM_VENDOR_ID, &sub_vendor );
+    pcibios_read_config_word( pci_bus, pci_device_fn,
+                              PCI_SUBSYSTEM_ID, &sub_device );
+
+    if( vendor != cmddev->vendorid )
+      continue;
+    if( device != cmddev->deviceid )
+      continue;
+    if( sub_vendor != cmddev->sub_vendorid )
+      continue;
+    if( sub_device != cmddev->sub_deviceid )
+      continue;
+
+    pcibios_read_config_byte( pci_bus, pci_device_fn,
+                              PCI_INTERRUPT_LINE, &pci_irq_line );
+    for(i=0;i<6;i++) {
+      pcibios_read_config_dword( pci_bus, pci_device_fn,
+                                 PCI_BASE_ADDRESS_0 + (i*4), bar + i );
+      bar[i] &= ~0xF;
+    }
+
+    nfp_setup(cmddev, pci_bus, pci_device_fn, bar, pci_irq_line, NULL);
+  }
+  return 0;
+}
+
+#endif /* LINUX_VERSION_CODE < VERSION(2,1,0) */
+#endif /* LINUX_VERSION_CODE < VERSION(2,4,0) */
+
+#if LINUX_VERSION_CODE >= VERSION(2,4,0)
+static struct pci_device_id nfp_pci_tbl[] __devinitdata = {
+  { 0x1011, 0x1065, 0x0100, 0x0100,
+    0, 0, /* Ignore class */
+    0 /* Index into nfp_drvlist */
+  },
+  { 0x8086, 0xb555, 0x0100, 0x0100,
+    0, 0, /* Ignore class */
+    1 /* Index into nfp_drvlist */
+  },
+  { 0, } /* terminate list */
+};
+MODULE_DEVICE_TABLE(pci,nfp_pci_tbl);
+
+static struct pci_driver nfp_pci_driver = {
+        name:           "nfp",
+        id_table:       nfp_pci_tbl,
+        probe:          nfp_pci_probe,
+        remove:         __devexit_p(nfp_pci_remove),
+};
+#endif
+
+/*--------------------*/
+/*  init              */
+/*--------------------*/
+
+int nfp_init( void ) {
+  int index;
+#if LINUX_VERSION_CODE < VERSION(2,4,0)
+  nfpcmd_dev const *cmddev;
+#endif
+
+  if( register_chrdev( NFP_MAJOR, NFP_DRVNAME, &nfp_fops ) ) {
+    nfp_log( NFP_DBG1, "unable to get major for nfp device." );
+    return -EIO;
+  }
+
+  for( index = 0; index < NFP_MAXDEV; index++ )
+    nfp_dev_list[index] = NULL;
+
+#if LINUX_VERSION_CODE < VERSION(2,1,55)
+  if( !pcibios_present() ) {
+    nfp_log( NFP_DBG1, "nfp_init: no pcibios present");
+    return 0;
+  }
+#endif
+
+#if LINUX_VERSION_CODE >= VERSION(2,6,13)
+  nfp_class = class_create(THIS_MODULE, "nfp");
+  if (IS_ERR(nfp_class))
+  {
+    nfp_log( NFP_DBG1,
+             "nfp_init: failed to create a class for this device, err = %ld",
+             PTR_ERR(nfp_class));
+    return -EIO;
+  }
+#endif
+
+  index= 0;
+#if LINUX_VERSION_CODE >= VERSION(2,4,0)
+  return pci_module_init(&nfp_pci_driver);
+#else
+  while( (cmddev = nfp_drvlist[index++]) != NULL )
+    nfp_probe(cmddev);
+
+  nfp_log( NFP_DBG2, "nfp_init: Device driver initialised, %d devices", nfp_num_devices  );
+
+  return 0;
+#endif
+}
+
+/*-----------------------*/
+/*  module load / unload */
+/*-----------------------*/
+
+#if LINUX_VERSION_CODE >= VERSION(2,4,0)
+int nfp_module_init( void ) {
+#else
+int init_module( void ) {
+#endif
+  nfp_log( NFP_DBG2, "module_init: entered" );
+  return nfp_init();
+}
+
+#if LINUX_VERSION_CODE >= VERSION(2,4,0)
+void nfp_module_exit( void ) {
+#else
+void cleanup_module( void ) {
+  int index;
+  nfp_dev *pdev;
+#endif
+
+  nfp_log(NFP_DBG2,"cleanup_module: entered");
+
+#if LINUX_VERSION_CODE >= VERSION(2,4,0)
+  pci_unregister_driver(&nfp_pci_driver);
+#else
+  /* de-allocagte all hardware resources and free hardware descriptor list */
+  index= 0;
+  while( index < NFP_MAXDEV ) {
+    pdev= nfp_dev_list[ index ];
+    if(pdev) {
+      if(pdev->cmddev)
+        pdev->cmddev->destroy(pdev->common.cmdctx);
+      nfp_dev_destroy(pdev);
+    }
+    index++;
+  }
+#endif
+
+#if LINUX_VERSION_CODE >= VERSION(2,6,13)
+  class_destroy(nfp_class);
+#endif
+
+  unregister_chrdev( NFP_MAJOR, NFP_DRVNAME );
+  nfp_log( NFP_DBG2, "cleanup_module: Module unloaded" );
+}
+
+#if LINUX_VERSION_CODE >= VERSION(2,4,0)
+module_init(nfp_module_init);
+module_exit(nfp_module_exit);
+#endif
diff --git drivers/misc/nshield/i21285.c drivers/misc/nshield/i21285.c
new file mode 100644
index 000000000000..62e8995f859f
--- /dev/null
+++ drivers/misc/nshield/i21285.c
@@ -0,0 +1,325 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+i21285.c: nCipher PCI HSM intel/digital 21285 command driver
+
+ * (c) Thales UK Limited 2015
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#include "nfp_common.h"
+#include "nfp_error.h"
+#include "nfp_hostif.h"
+#include "nfp_osif.h"
+#include "i21285.h"
+#include "nfp_cmd.h"
+#include "nfpci.h"
+
+/* create ------------------------------------------------------- */
+
+static nfp_err i21285_create( nfp_cdev *pdev ) {
+  unsigned int tmp32;
+
+  nfp_log( NFP_DBG2, "i21285_create: entered");
+  pdev->cmdctx= pdev;  /* set our context to just be a pointer to our nfp_cdev */
+
+  nfp_log( NFP_DBG2, "i21285_create: enable doorbell");
+  if(!pdev->bar[ IOBAR ]) {
+    nfp_log( NFP_DBG1, "i21285_create: null BAR[%d]", IOBAR );
+    return NFP_ENOMEM;
+  }
+  TO_LE32_IO( &tmp32, DOORBELL_ENABLE | POSTLIST_ENABLE);
+  nfp_outl( pdev, IOBAR, I21285_OFFSET_INTERRUPT_MASK, tmp32 );
+
+  return NFP_SUCCESS;
+}
+
+/* stop ------------------------------------------------------- */
+
+static nfp_err i21285_destroy( void * ctx ) {
+  nfp_cdev *pdev;
+  unsigned int tmp32;
+
+  nfp_log( NFP_DBG2, "i21285_destroy: entered");
+
+  pdev= (nfp_cdev *)ctx;
+  if(!pdev) {
+    nfp_log( NFP_DBG1, "i21285_destroy: NULL pdev");
+    return NFP_ENODEV;
+  }
+  if(!pdev->bar[ IOBAR ]) {
+    nfp_log( NFP_DBG1, "i21285_destroy: null BAR[%d]", IOBAR );
+    return NFP_ENOMEM;
+  }
+  TO_LE32_IO( &tmp32, DOORBELL_DISABLE | POSTLIST_DISABLE );
+  nfp_outl( pdev, IOBAR, I21285_OFFSET_INTERRUPT_MASK, tmp32 );
+
+  return NFP_SUCCESS;
+}
+
+/* open ------------------------------------------------------- */
+
+static nfp_err i21285_open( void * ctx ) {
+  (void)ctx;
+  nfp_log( NFP_DBG2, "i21285_open: entered");
+
+  return NFP_SUCCESS;
+}
+
+/* close ------------------------------------------------------- */
+
+static nfp_err i21285_close( void * ctx ) {
+  (void)ctx;
+  nfp_log( NFP_DBG2, "i21285_close: entered");
+
+  return NFP_SUCCESS;
+}
+
+/* isr ------------------------------------------------------- */
+
+static nfp_err i21285_isr( void *ctx, int *handled ) {
+  nfp_cdev *pdev;
+  unsigned int doorbell;
+  unsigned int tmp32;
+
+  nfp_log( NFP_DBG3, "i21285_isr: entered");
+
+  *handled= 0;
+  pdev= (nfp_cdev *)ctx;
+  if(!pdev) {
+    nfp_log( NFP_DBG1, "i21285_isr: NULL pdev");
+    return NFP_ENODEV;
+  }
+
+  doorbell= nfp_inl( pdev, IOBAR, I21285_OFFSET_DOORBELL);
+  doorbell= FROM_LE32_IO(&doorbell) & 0xffff;
+  while( doorbell && doorbell != 0xffff) {
+    *handled= 1;
+    /* service interrupts */
+    if( doorbell & (NFAST_INT_DEVICE_WRITE_OK | NFAST_INT_DEVICE_WRITE_FAILED)) {
+      TO_LE32_IO( &tmp32, NFAST_INT_DEVICE_WRITE_OK | NFAST_INT_DEVICE_WRITE_FAILED);
+      nfp_outl( pdev, IOBAR, I21285_OFFSET_DOORBELL, tmp32 );
+
+      nfp_log(NFP_DBG2, "i21285_isr: write done interrupt, ok = %d.", doorbell & NFAST_INT_DEVICE_WRITE_OK ? 1 : 0 );
+
+      nfp_write_complete(pdev->dev, doorbell & NFAST_INT_DEVICE_WRITE_OK ? 1 : 0 );
+    }
+
+    if( doorbell & (NFAST_INT_DEVICE_READ_OK | NFAST_INT_DEVICE_READ_FAILED)) {
+       TO_LE32_IO( &tmp32, NFAST_INT_DEVICE_READ_OK | NFAST_INT_DEVICE_READ_FAILED );
+       nfp_outl( pdev, IOBAR, I21285_OFFSET_DOORBELL, tmp32 );
+
+      nfp_log(NFP_DBG2, "i21285_isr: read ack interrupt, ok = %d.", doorbell & NFAST_INT_DEVICE_READ_OK ? 1 : 0 );
+      nfp_read_complete( pdev->dev, doorbell & NFAST_INT_DEVICE_READ_OK ? 1 : 0);
+    }
+
+    if( doorbell & ~(NFAST_INT_DEVICE_READ_OK  | NFAST_INT_DEVICE_READ_FAILED |
+                     NFAST_INT_DEVICE_WRITE_OK | NFAST_INT_DEVICE_WRITE_FAILED)) {
+      nfp_log( NFP_DBG1, "i21285_isr: unexpected interrupt %x", doorbell );
+      TO_LE32_IO( &tmp32, 0xffff & doorbell );
+      nfp_outl( pdev, IOBAR, I21285_OFFSET_DOORBELL, tmp32 );
+    }
+    doorbell= nfp_inl( pdev, IOBAR, I21285_OFFSET_DOORBELL);
+    doorbell= FROM_LE32_IO(&doorbell) & 0xffff;
+  }
+  return 0;
+}
+
+/* write ------------------------------------------------------- */
+
+static nfp_err i21285_write( const char *block, int len, void *ctx ) {
+  nfp_cdev *cdev;
+  unsigned int hdr[2];
+  nfp_err ne;
+  unsigned int tmp32;
+
+  nfp_log( NFP_DBG2, "i21285_write: entered");
+
+  cdev= (nfp_cdev *)ctx;
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21285_write: NULL pdev");
+    return NFP_ENODEV;
+  }
+
+  nfp_log(NFP_DBG2, "i21285_write: pdev->bar[ MEMBAR ]= %x\n", cdev->bar[ MEMBAR ]);
+  nfp_log(NFP_DBG2, "i21285_write: pdev->bar[ IOBAR ]= %x\n", cdev->bar[ IOBAR ]);
+  if(!cdev->bar[ MEMBAR ]) {
+    nfp_log( NFP_DBG1, "i21285_write: null BAR[%d]", MEMBAR );
+    return NFP_ENOMEM;
+  }
+  ne= nfp_copy_from_user_to_dev( cdev, MEMBAR, NFPCI_JOBS_WR_DATA, block, len);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21285_write: nfp_copy_from_user_to_dev failed");
+    return ne;
+  }
+  TO_LE32_MEM(&hdr[0], NFPCI_JOB_CONTROL);
+  TO_LE32_MEM(&hdr[1], len);
+
+  ne= nfp_copy_to_dev( cdev, MEMBAR, NFPCI_JOBS_WR_CONTROL, (const char *)hdr, 8);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21285_write: nfp_copy_to_dev failed");
+    return ne;
+  }
+
+  ne= nfp_copy_from_dev( cdev, MEMBAR, NFPCI_JOBS_WR_LENGTH, (char *)hdr, 4);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21285_write: nfp_copy_from_dev failed");
+    return ne;
+  }
+  
+  TO_LE32_MEM( &tmp32, len );
+  if ( hdr[0] != tmp32 ) {
+    nfp_log( NFP_DBG1, "i21285_write: length not written");
+    return NFP_EIO;
+  }
+
+  TO_LE32_IO( &tmp32, NFAST_INT_HOST_WRITE_REQUEST);
+
+  nfp_outl( cdev, IOBAR, I21285_OFFSET_DOORBELL, tmp32 );
+
+  nfp_log( NFP_DBG2, "i21285_write: done");
+  return NFP_SUCCESS;
+}
+
+/* read ------------------------------------------------------- */
+
+static nfp_err i21285_read( char *block, int len, void *ctx, int *rcount) {
+  nfp_cdev *cdev;
+  nfp_err ne;
+  int count;
+
+  nfp_log( NFP_DBG2, "i21285_read: entered, len %d", len);
+  *rcount= 0;
+
+  cdev= (nfp_cdev *)ctx;
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21285_read: NULL pdev");
+    return NFP_ENODEV;
+  }
+
+  if(!cdev->bar[ MEMBAR ]) {
+    nfp_log( NFP_DBG1, "i21285_read: null BAR[%d]", MEMBAR );
+    return NFP_ENOMEM;
+  }
+  ne= nfp_copy_from_dev( cdev, MEMBAR, NFPCI_JOBS_RD_LENGTH, (char *)&count, 4);
+  if(ne) {
+    nfp_log( NFP_DBG1, "i21285_read: nfp_copy_from_dev failed.");
+    return ne;
+  }
+  count= FROM_LE32_MEM(&count);
+  if(count<0 || count>len) {
+    nfp_log( NFP_DBG1, "i21285_read: bad byte count (%d) from device", count);
+    return NFP_EIO;
+  }
+  ne= nfp_copy_to_user_from_dev( cdev, MEMBAR, NFPCI_JOBS_RD_DATA, block, count);
+  if( ne ) {
+    nfp_log( NFP_DBG1, "i21285_read: nfp_copy_to_user_from_dev failed.");
+    return ne;
+  }
+  nfp_log( NFP_DBG2, "i21285_read: done");
+  *rcount= count;
+  return NFP_SUCCESS;
+}
+
+/* chupdate  ------------------------------------------------------- */
+
+static nfp_err i21285_chupdate( char *data, int len, void *ctx ) {
+  (void)ctx;
+  (void)len;
+  (void)data;
+  nfp_log( NFP_DBG1, "i21285_chupdate: NYI");
+  return NFP_SUCCESS;
+}
+
+/* ensure reading -------------------------------------------------- */
+
+static nfp_err i21285_ensure_reading( unsigned int addr, int len, void *ctx ) {
+  nfp_cdev *cdev;
+  unsigned int hdr[2];
+  unsigned int tmp32;
+  nfp_err ne;
+
+  nfp_log( NFP_DBG2, "i21285_ensure_reading: entered");
+
+  if(addr) {
+    nfp_log( NFP_DBG2, "i21285_ensure_reading: bad addr");
+    return -NFP_EINVAL;
+  }
+
+  cdev= (nfp_cdev *)ctx;
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21285_ensure_reading: NULL pdev");
+    return NFP_ENODEV;
+  }
+
+  if(!cdev->bar[ MEMBAR ]) {
+    nfp_log( NFP_DBG1, "i21285_ensure_reading: null BAR[%d]", MEMBAR );
+    return NFP_ENXIO;
+  }
+  nfp_log( NFP_DBG3, "i21285_ensure_reading: pdev->bar[ MEMBAR ]= %x", cdev->bar[ MEMBAR ]);
+  nfp_log( NFP_DBG3, "i21285_ensure_reading: pdev->bar[ IOBAR ]= %x", cdev->bar[ IOBAR ]);
+  TO_LE32_MEM( &hdr[0], NFPCI_JOB_CONTROL);
+  TO_LE32_MEM( &hdr[1], len);
+  ne= nfp_copy_to_dev( cdev, MEMBAR, NFPCI_JOBS_RD_CONTROL, (const char *)hdr, 8);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21285_ensure_reading: nfp_copy_to_dev failed");
+    return ne;
+  }
+  ne= nfp_copy_from_dev( cdev, MEMBAR, NFPCI_JOBS_RD_LENGTH, (char *)hdr, 4);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21285_ensure_reading: nfp_copy_from_dev failed");
+    return ne;
+  }
+  TO_LE32_MEM( &tmp32, len );
+  if ( hdr[0] != tmp32 ) {
+    nfp_log( NFP_DBG1, "i21285_ensure_reading: len not written");
+    return NFP_EIO;
+  };
+  TO_LE32_IO( &tmp32, NFAST_INT_HOST_READ_REQUEST );
+  nfp_outl( cdev, IOBAR, I21285_OFFSET_DOORBELL, tmp32 );
+
+  return NFP_SUCCESS;
+}
+
+/* command device structure ------------------------------------- */
+
+
+const nfpcmd_dev i21285_cmddev = {
+  "nCipher Gen 1 PCI",
+  PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_DEC_21285,
+  PCI_VENDOR_ID_NCIPHER, PCI_DEVICE_ID_NFAST_GEN1,
+  { 0, IOSIZE | PCI_BASE_ADDRESS_SPACE_IO, NFPCI_RAM_MINSIZE, 0, 0, 0 },
+  NFP_CMD_FLG_NEED_IOBUF,
+  i21285_create,
+  i21285_destroy,
+  i21285_open,
+  i21285_close,
+  i21285_isr,
+  i21285_write,
+  i21285_read,
+  i21285_chupdate,
+  i21285_ensure_reading,
+  0, /* no debug */
+  0, /* no control */
+  0, /* no status */
+};
+  
diff --git drivers/misc/nshield/i21285.h drivers/misc/nshield/i21285.h
new file mode 100644
index 000000000000..e55d857ffd39
--- /dev/null
+++ drivers/misc/nshield/i21285.h
@@ -0,0 +1,55 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * (c) Thales UK Limited 2015
+ *
+ *
+ */
+
+#ifndef NFP_I21285_H
+#define NFP_I21285_H
+
+#ifndef PCI_VENDOR_ID_DEC
+#define PCI_VENDOR_ID_DEC               0x1011
+#endif
+#ifndef PCI_DEVICE_ID_DEC_21285
+#define PCI_DEVICE_ID_DEC_21285         0x1065
+#endif
+#ifndef PCI_VENDOR_ID_NCIPHER
+#define PCI_VENDOR_ID_NCIPHER           0x0100
+#endif
+
+#ifndef PCI_DEVICE_ID_NFAST_GEN1
+#define PCI_DEVICE_ID_NFAST_GEN1	0x0100
+#endif
+
+#define I21285_OFFSET_DOORBELL		0x60
+#define I21285_OFFSET_INTERRUPT_MASK	0x34
+
+#define DOORBELL_ENABLE 0x0
+#define DOORBELL_DISABLE 0x4
+
+#define POSTLIST_ENABLE 0x0
+#define POSTLIST_DISABLE 0x8
+
+#define IOBAR	1
+#define MEMBAR	2
+
+#define IOSIZE	0x80
+#define MEMSIZE	0x100000
+
+#endif
diff --git drivers/misc/nshield/i21555.c drivers/misc/nshield/i21555.c
new file mode 100644
index 000000000000..c15ec796c85d
--- /dev/null
+++ drivers/misc/nshield/i21555.c
@@ -0,0 +1,484 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+i21555.c: nCipher PCI HSM intel 21555 command driver
+
+ * (c) Thales UK Limited 2015
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#include "nfp_common.h"
+#include "nfp_error.h"
+#include "nfp_hostif.h"
+#include "nfp_osif.h"
+#include "i21555.h"
+#include "nfp_cmd.h"
+#include "nfpci.h"
+
+/* started ------------------------------------------------------
+ *
+ * Check that device is ready to talk, by checking that
+ * the i21555 has master enabled on its secondary interface
+ */
+
+static nfp_err i21555_started( nfp_cdev *pdev ) {
+  unsigned int tmp32;
+#ifdef CONFIGSPACE_DEBUG
+  unsigned int reg32[64];
+  int i;
+#endif
+  nfp_err ne;
+
+  nfp_log( NFP_DBG2, "i21555_started: entered");
+
+#ifdef CONFIGSPACE_DEBUG
+  /* Suck up all the registers */
+  for (i=0; i < 64; i++) {
+    ne = nfp_config_inl( pdev, i*4, &reg32[i] );
+  }
+
+  for (i=0; i < 16; i++) {
+    int j = i * 4;
+    nfp_log( NFP_DBG3, "i21555 config reg %2x: %08x %08x %08x %08x", j*4,
+        reg32[j], reg32[j+1], reg32[j+2], reg32[j+3]);
+  }
+#endif
+
+  ne = nfp_config_inl( pdev, I21555_CFG_SEC_CMD_STATUS, &tmp32 );
+  if (ne) {
+    /* succeed if PCI config reads are not implemented */
+    if (ne == NFP_EUNKNOWN)
+      return NFP_SUCCESS;
+    nfp_log( NFP_DBG1, "i21555_started: nfp_config_inl failed");
+    return ne;
+  }
+
+  tmp32= FROM_LE32_IO(&tmp32) & 0xffff;
+
+  if ( tmp32 & CFG_CMD_MASTER ) {
+    nfp_log( NFP_DBG3, "i21555_started: Yes %x", tmp32);
+    return NFP_SUCCESS;
+  } else {
+    nfp_log( NFP_DBG1, "i21555_started: device not started yet %x", tmp32);
+    return NFP_ESTARTING;
+  }
+}
+
+/* create ------------------------------------------------------- */
+
+static nfp_err i21555_create( nfp_cdev *pdev ) {
+  unsigned int tmp32;
+
+  nfp_log( NFP_DBG2, "i21555_create: entered");
+  pdev->cmdctx= pdev;  /* set our context to just be a pointer to our nfp_cdev */
+
+  if(!pdev->bar[ IOBAR ]) {
+    nfp_log( NFP_DBG1, "i21555_create: null BAR[%d]", IOBAR );
+    return NFP_ENOMEM;
+  }
+  nfp_log( NFP_DBG2, "i21555_create: enable doorbell");
+  TO_LE32_IO( &tmp32, I21555_DOORBELL_PRI_ENABLE );
+  nfp_outl( pdev, IOBAR, I21555_OFFSET_DOORBELL_PRI_SET_MASK, tmp32 );
+  nfp_outl( pdev, IOBAR, I21555_OFFSET_DOORBELL_PRI_CLEAR_MASK, tmp32 );
+  return NFP_SUCCESS;
+}
+
+/* stop ------------------------------------------------------- */
+
+static nfp_err i21555_destroy( void * ctx ) {
+  nfp_cdev *pdev;
+  unsigned int tmp32;
+
+  nfp_log( NFP_DBG2, "i21555_destroy: entered");
+
+  pdev= (nfp_cdev *)ctx;
+  if(!pdev) {
+    nfp_log( NFP_DBG1, "i21555_destroy: NULL pdev");
+    return NFP_ENODEV;
+  }
+  if(!pdev->bar[ IOBAR ]) {
+    nfp_log( NFP_DBG1, "i21555_destroy: null BAR[%d]", IOBAR );
+    return NFP_ENOMEM;
+  }
+  TO_LE32_IO( &tmp32, I21555_DOORBELL_PRI_DISABLE );
+  nfp_outl( pdev, IOBAR, I21555_OFFSET_DOORBELL_PRI_SET_MASK, tmp32 );
+  nfp_outl( pdev, IOBAR, I21555_OFFSET_DOORBELL_PRI_CLEAR_MASK, tmp32 );
+
+  return NFP_SUCCESS;
+}
+
+/* open ------------------------------------------------------- */
+
+static nfp_err i21555_open( void * ctx ) {
+  (void)ctx;
+
+  nfp_log( NFP_DBG2, "i21555_open: entered");
+
+  return NFP_SUCCESS;
+}
+
+/* close ------------------------------------------------------- */
+
+static nfp_err i21555_close( void * ctx ) {
+  (void)ctx;
+  nfp_log( NFP_DBG2, "i21555_close: entered");
+
+  return NFP_SUCCESS;
+}
+
+/* isr ------------------------------------------------------- */
+
+static nfp_err i21555_isr( void *ctx, int *handled ) {
+  nfp_cdev *pdev;
+  nfp_err ne;
+  unsigned short doorbell;
+  unsigned short tmp16;
+
+  nfp_log( NFP_DBG3, "i21555_isr: entered");
+
+  *handled= 0;
+  pdev= (nfp_cdev *)ctx;
+  if(!pdev) {
+    nfp_log( NFP_DBG1, "i21555_isr: NULL pdev");
+    return NFP_ENODEV;
+  }
+
+  pdev->stats.isr++;
+
+  if(!pdev->bar[ IOBAR ]) {
+    nfp_log( NFP_DBG1, "i21555_isr: null BAR[%d]", IOBAR );
+    return NFP_ENOMEM;
+  }
+
+  /* This interrupt may not be from our module, so check that it actually is
+   * us before handling it.
+   */
+  ne = i21555_started( pdev );
+  if (ne) {
+    if (ne != NFP_ESTARTING) {
+      nfp_log( NFP_DBG1, "i21555_isr: i21555_started failed");
+    }
+    return ne;
+  }
+
+  doorbell= nfp_inw( pdev, IOBAR, I21555_OFFSET_DOORBELL_PRI_SET);
+  doorbell= FROM_LE16_IO(&doorbell);
+  while( doorbell && doorbell != 0xffff) {
+    *handled= 1;
+    /* service interrupts */
+    if( doorbell & (NFAST_INT_DEVICE_WRITE_OK | NFAST_INT_DEVICE_WRITE_FAILED)) {
+      pdev->stats.isr_write++;
+      TO_LE16_IO(&tmp16,NFAST_INT_DEVICE_WRITE_OK | NFAST_INT_DEVICE_WRITE_FAILED);
+      nfp_outw( pdev, IOBAR, I21555_OFFSET_DOORBELL_PRI_CLEAR, tmp16 );
+
+      nfp_log( NFP_DBG2, "i21555_isr: write done interrupt, ok = %d.", doorbell & NFAST_INT_DEVICE_WRITE_OK ? 1 : 0 );
+
+      nfp_write_complete(pdev->dev, doorbell & NFAST_INT_DEVICE_WRITE_OK ? 1 : 0 );
+    }
+
+    if( doorbell & (NFAST_INT_DEVICE_READ_OK | NFAST_INT_DEVICE_READ_FAILED)) {
+      pdev->stats.isr_read++;
+      TO_LE16_IO(&tmp16,NFAST_INT_DEVICE_READ_OK | NFAST_INT_DEVICE_READ_FAILED);
+      nfp_outw( pdev, IOBAR, I21555_OFFSET_DOORBELL_PRI_CLEAR, tmp16 );
+
+      nfp_log( NFP_DBG2, "i21555_isr: read ack interrupt, ok = %d.", doorbell & NFAST_INT_DEVICE_READ_OK ? 1 : 0 );
+      nfp_read_complete( pdev->dev, doorbell & NFAST_INT_DEVICE_READ_OK ? 1 : 0);
+    }
+
+    if( doorbell & ~(NFAST_INT_DEVICE_READ_OK  | NFAST_INT_DEVICE_READ_FAILED |
+                     NFAST_INT_DEVICE_WRITE_OK | NFAST_INT_DEVICE_WRITE_FAILED)) {
+      TO_LE16_IO(&tmp16,doorbell);
+      nfp_outw( pdev, IOBAR, I21555_OFFSET_DOORBELL_PRI_CLEAR, tmp16 );
+      nfp_log( NFP_DBG1, "i21555_isr: unexpected interrupt %x", doorbell );
+    }
+    doorbell= nfp_inw( pdev, IOBAR, I21555_OFFSET_DOORBELL_PRI_SET);
+    doorbell= FROM_LE16_IO(&doorbell);
+  }
+  nfp_log( NFP_DBG3, "i21555_isr: exiting");
+  return 0;
+}
+
+/* write ------------------------------------------------------- */
+
+static nfp_err i21555_write( const char *block, int len, void *ctx) {
+  nfp_cdev *cdev;
+  unsigned int hdr[2];
+  nfp_err ne;
+  unsigned short tmp16;
+  unsigned int tmp32;
+
+  nfp_log( NFP_DBG2, "i21555_write: entered");
+
+  cdev= (nfp_cdev *)ctx;
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21555_write: NULL cdev");
+    return NFP_ENODEV;
+  }
+
+  cdev->stats.write_fail++;
+
+  if(!cdev->bar[ IOBAR ]) {
+    nfp_log( NFP_DBG1, "i21555_write: null BAR[%d]", IOBAR );
+    return NFP_ENOMEM;
+  }
+
+  ne = i21555_started( cdev );
+  if (ne) {
+    if (ne != NFP_ESTARTING) {
+      nfp_log( NFP_DBG1, "i21555_write: i21555_started failed");
+    }
+    return ne;
+  }
+
+  nfp_log( NFP_DBG3, "i21555_write: cdev->bar[ MEMBAR ]= %x", cdev->bar[ MEMBAR ]);
+  nfp_log( NFP_DBG3, "i21555_write: cdev->bar[ IOBAR ]= %x", cdev->bar[ IOBAR ]);
+  nfp_log( NFP_DBG3, "i21555_write: block len %d", len ); 
+  ne= nfp_copy_from_user_to_dev( cdev, MEMBAR, NFPCI_JOBS_WR_DATA, block, len);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_write: nfp_copy_from_user_to_dev failed");
+    return ne;
+  }
+  TO_LE32_MEM(&hdr[0], NFPCI_JOB_CONTROL);
+  TO_LE32_MEM(&hdr[1], len);
+  ne= nfp_copy_to_dev( cdev, MEMBAR, NFPCI_JOBS_WR_CONTROL, (const char *)hdr, 8);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_write: nfp_copy_to_dev failed");
+    return ne;
+  }
+
+  ne= nfp_copy_from_dev( cdev, MEMBAR, NFPCI_JOBS_WR_LENGTH, (char *)hdr, 4);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_write: nfp_copy_from_dev failed");
+    return ne;
+  }
+
+  TO_LE32_MEM(&tmp32, len);
+  if ( hdr[0] != tmp32 ) {
+    nfp_log( NFP_DBG1, "i21555_write: length not written");
+    return NFP_EIO;
+  }
+  TO_LE16_IO(&tmp16, NFAST_INT_HOST_WRITE_REQUEST >> 16);
+  nfp_outw( cdev, IOBAR, I21555_OFFSET_DOORBELL_SEC_SET, tmp16);
+
+  cdev->stats.write_fail--;
+  cdev->stats.write_block++;
+  cdev->stats.write_byte += len;
+
+  nfp_log( NFP_DBG2, "i21555_write: done");
+  return NFP_SUCCESS;
+}
+
+/* read ------------------------------------------------------- */
+
+static nfp_err i21555_read( char *block, int len, void *ctx, int *rcount) {
+  nfp_cdev *cdev;
+  nfp_err ne;
+  int count;
+
+  nfp_log( NFP_DBG2, "i21555_read: entered");
+  *rcount= 0;
+
+  cdev= (nfp_cdev *)ctx;
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21555_read: NULL pdev");
+    return NFP_ENODEV;
+  }
+
+  cdev->stats.read_fail++;
+
+  if(!cdev->bar[ IOBAR ]) {
+    nfp_log( NFP_DBG1, "i21555_read: null BAR[%d]", IOBAR );
+    return NFP_ENOMEM;
+  }
+
+  ne= nfp_copy_from_dev( cdev, MEMBAR, NFPCI_JOBS_RD_LENGTH, (char *)&count, 4);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_read: nfp_copy_from_dev failed.");
+    return ne;
+  }
+  count= FROM_LE32_MEM(&count);
+  if(count<0 || count>len) {
+    nfp_log( NFP_DBG1, "i21555_read: bad byte count (%d) from device", count);
+    return NFP_EIO;
+  }
+  ne= nfp_copy_to_user_from_dev( cdev, MEMBAR, NFPCI_JOBS_RD_DATA, block, count);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_read: nfp_copy_to_user failed.");
+    return ne;
+  }
+  nfp_log( NFP_DBG2, "i21555_read: done");
+  *rcount= count;
+  cdev->stats.read_fail--;
+  cdev->stats.read_block++;
+  cdev->stats.read_byte += len;
+  return NFP_SUCCESS;
+}
+
+/* chupdate  ------------------------------------------------------- */
+
+static nfp_err i21555_chupdate( char *data, int len, void *ctx ) {
+  (void)ctx;
+  (void)len;
+  (void)data;
+  nfp_log( NFP_DBG1, "i21555_chupdate: NYI");
+  return NFP_SUCCESS;
+}
+
+/* ensure reading -------------------------------------------------- */
+
+static nfp_err i21555_ensure_reading( unsigned int addr, int len, void *ctx ) {
+  nfp_cdev *cdev;
+  unsigned int hdr[3];
+  unsigned short tmp16;
+  unsigned int tmp32;
+  nfp_err ne;
+  int hdr_len;
+
+  nfp_log( NFP_DBG2, "i21555_ensure_reading: entered");
+
+  cdev= (nfp_cdev *)ctx;
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21555_ensure_reading: NULL cdev");
+    return NFP_ENODEV;
+  }
+
+  cdev->stats.ensure_fail++;
+
+  if(!cdev->bar[ IOBAR ]) {
+    nfp_log( NFP_DBG1, "i21555_ensure_reading: null BAR[%d]", IOBAR );
+    return NFP_ENOMEM;
+  }
+
+  ne = i21555_started( cdev );
+  if (ne) {
+    if (ne != NFP_ESTARTING) {
+      nfp_log( NFP_DBG1, "i21555_ensure_reading: i21555_started failed");
+    }
+    return ne;
+  }
+
+  nfp_log( NFP_DBG3, "i21555_ensure_reading: pdev->bar[ MEMBAR ]= %x", cdev->bar[ MEMBAR ]);
+  nfp_log( NFP_DBG3, "i21555_ensure_reading: pdev->bar[ IOBAR ]= %x", cdev->bar[ IOBAR ]);
+  if(addr) {
+    nfp_log( NFP_DBG3, "i21555_ensure_reading: new format, addr %x", addr);
+    TO_LE32_MEM(&hdr[0], NFPCI_JOB_CONTROL_PCI_PUSH);
+    TO_LE32_MEM(&hdr[1], len);
+    TO_LE32_MEM(&hdr[2], addr);
+    hdr_len= 12;
+  } else {
+    TO_LE32_MEM(&hdr[0], NFPCI_JOB_CONTROL);
+    TO_LE32_MEM(&hdr[1], len);
+    hdr_len= 8;
+  }
+  ne= nfp_copy_to_dev( cdev, MEMBAR, NFPCI_JOBS_RD_CONTROL, (const char *)hdr, hdr_len);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_ensure_reading: nfp_copy_to_dev failed");
+    return ne;
+  }
+
+  ne= nfp_copy_from_dev( cdev, MEMBAR, NFPCI_JOBS_RD_LENGTH, (char *)hdr, 4);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_ensure_reading: nfp_copy_from_dev failed");
+    return ne;
+  }
+
+  TO_LE32_MEM(&tmp32, len);
+
+  if ( hdr[0] != tmp32 ) {
+    nfp_log( NFP_DBG1, "i21555_ensure_reading: len not written");
+    return NFP_EIO;
+  }
+  TO_LE16_IO( &tmp16, NFAST_INT_HOST_READ_REQUEST >> 16);
+  nfp_outw( cdev, IOBAR, I21555_OFFSET_DOORBELL_SEC_SET, tmp16);
+
+  cdev->stats.ensure_fail--;
+  cdev->stats.ensure++;
+
+  return NFP_SUCCESS;
+}
+
+/* set control register ----------------------------------------- */
+
+static nfp_err i21555_set_control( const nfdev_control_str *control,
+                                   void *ctx ) {
+  nfp_cdev *cdev = (nfp_cdev *)ctx;
+  uint32_t control_flipped;
+
+  nfp_log( NFP_DBG3, "i21555_set_control: entered");
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21555_set_control: NULL pdev");
+    return NFP_ENODEV;
+  }
+  if(!cdev->bar[ IOBAR ]) {
+    nfp_log( NFP_DBG1, "i21555_write: null BAR[%d]", IOBAR );
+    return NFP_ENOMEM;
+  }
+  TO_LE32_IO(&control_flipped, control->control);
+  nfp_outl( cdev, IOBAR, I21555_SCRATCHPAD_REGISTER_CONTROL, control_flipped);
+  return NFP_SUCCESS;
+
+}
+
+/* get status/error registers ----------------------------------- */
+
+static nfp_err i21555_get_status( nfdev_status_str *status, void *ctx ) {
+  nfp_cdev *cdev = (nfp_cdev *)ctx;
+  uint32_t status_flipped;
+  uint32_t *error = (uint32_t *)status->error;
+
+  nfp_log( NFP_DBG3, "i21555_get_status: entered");
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21555_get_status: NULL cdev");
+    return NFP_ENODEV;
+  }
+  if(!cdev->bar[ IOBAR ]) {
+    nfp_log( NFP_DBG1, "i21555_write: null BAR[%d]", IOBAR );
+    return NFP_ENOMEM;
+  }
+  status_flipped = nfp_inl( cdev, IOBAR, I21555_SCRATCHPAD_REGISTER_STATUS);
+  status->status = FROM_LE32_IO(&status_flipped);
+  error[0] = nfp_inl( cdev, IOBAR, I21555_SCRATCHPAD_REGISTER_ERROR_LO);
+  error[1] = nfp_inl( cdev, IOBAR, I21555_SCRATCHPAD_REGISTER_ERROR_HI);
+  return NFP_SUCCESS;
+}
+
+/* command device structure ------------------------------------- */
+
+const nfpcmd_dev i21555_cmddev = {
+  "nCipher Gen 2 PCI",
+  PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_21555,
+  PCI_VENDOR_ID_NCIPHER, PCI_SUBSYSTEM_ID_NFAST_REV1,
+  { 0, IOSIZE | PCI_BASE_ADDRESS_SPACE_IO, NFPCI_RAM_MINSIZE_JOBS, 0, 0, 0 },
+  NFP_CMD_FLG_NEED_IOBUF,
+  i21555_create,
+  i21555_destroy,
+  i21555_open,
+  i21555_close,
+  i21555_isr,
+  i21555_write,
+  i21555_read,
+  i21555_chupdate,
+  i21555_ensure_reading,
+  i21555_debug,
+  i21555_set_control,
+  i21555_get_status,
+};
diff --git drivers/misc/nshield/i21555.h drivers/misc/nshield/i21555.h
new file mode 100644
index 000000000000..ee7ada36d927
--- /dev/null
+++ drivers/misc/nshield/i21555.h
@@ -0,0 +1,72 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * (c) Thales UK Limited 2015
+ *
+ *
+ */
+
+#ifndef I21555_H
+#define I21555_H
+
+#ifndef PCI_VENDOR_ID_INTEL
+#define PCI_VENDOR_ID_INTEL             0x8086
+#endif
+
+#ifndef PCI_DEVICE_ID_INTEL_21555
+#define PCI_DEVICE_ID_INTEL_21555       0xb555
+#endif
+
+#ifndef PCI_VENDOR_ID_NCIPHER
+#define PCI_VENDOR_ID_NCIPHER           0x0100
+#endif
+
+#ifndef PCI_SUBSYSTEM_ID_NFAST_REV1
+#define PCI_SUBSYSTEM_ID_NFAST_REV1     0x0100
+#endif
+
+#define I21555_OFFSET_DOORBELL_PRI_SET		0x9C
+#define I21555_OFFSET_DOORBELL_SEC_SET		0x9E
+#define I21555_OFFSET_DOORBELL_PRI_CLEAR	0x98
+
+#define I21555_OFFSET_DOORBELL_PRI_SET_MASK	0xA4
+#define I21555_OFFSET_DOORBELL_PRI_CLEAR_MASK	0xA0
+
+#define I21555_DOORBELL_PRI_ENABLE 0x0000
+#define I21555_DOORBELL_PRI_DISABLE 0xFFFF
+
+/* 8 32-bit scratchpad registers start here; bridge manual section 11.4 */
+#define I21555_SCRATCHPAD_REGISTER(n)           (0xA8 + 4 * (n))
+
+/* Scratchpad register assignments */
+#define I21555_SCRATCHPAD_REGISTER_CONTROL      I21555_SCRATCHPAD_REGISTER(0)
+#define I21555_SCRATCHPAD_REGISTER_STATUS       I21555_SCRATCHPAD_REGISTER(1)
+#define I21555_SCRATCHPAD_REGISTER_ERROR_LO     I21555_SCRATCHPAD_REGISTER(2)
+#define I21555_SCRATCHPAD_REGISTER_ERROR_HI     I21555_SCRATCHPAD_REGISTER(3)
+
+#define I21555_CFG_SEC_CMD_STATUS 0x44
+
+#define CFG_CMD_MASTER 0x0004
+
+#define IOBAR   1
+#define MEMBAR  2
+
+#define IOSIZE  0x100
+
+extern nfp_err i21555_debug( int cmd, void *ctx );
+
+#endif
diff --git drivers/misc/nshield/i21555d.c drivers/misc/nshield/i21555d.c
new file mode 100644
index 000000000000..65e359c0cdfd
--- /dev/null
+++ drivers/misc/nshield/i21555d.c
@@ -0,0 +1,41 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+i21555d.c: nCipher PCI HSM intel 21555 debug ioctl
+
+ * (c) Thales UK Limited 2015
+
+history
+
+15/05/2002 jsh  Original, does nothing
+
+*/
+
+#include "nfp_common.h"
+#include "nfp_error.h"
+#include "nfp_osif.h"
+#include "i21555.h"
+
+nfp_err i21555_debug( int cmd, void *ctx) {
+  nfp_log( NFP_DBG1, "i21555_debug: entered");
+
+  return NFP_EUNKNOWN;
+
+  (void) cmd;
+  (void) ctx;
+}
diff --git drivers/misc/nshield/nfdev-common.h drivers/misc/nshield/nfdev-common.h
new file mode 100644
index 000000000000..fbf034867c7e
--- /dev/null
+++ drivers/misc/nshield/nfdev-common.h
@@ -0,0 +1,171 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/** \file nfdev-common.h
+ *
+ * \brief nFast device driver (not generic SCSI) ioctl struct definition file
+ *  include NFDEV-$(system) for ioctl number definitions
+ *
+ *  1998.07.13	jsh	Started
+ *
+ * 
+ */
+
+#ifndef NFDEV_COMMON_H
+#define NFDEV_COMMON_H
+
+#if defined(__KERNEL__) || defined(__OpenBSD_kernel__)
+/* uint32_t is known about - don't try to define it */
+#else
+/* We need to defined uint32_t somehow */
+#if defined(_WIN32)
+/* int is always 32-bits */
+typedef unsigned int uint32_t;
+#else
+#if defined(__OpenBSD__)
+#include <sys/types.h>
+#else
+/* inttypes.h eventually defines uint32_t */
+#include <inttypes.h>
+#endif
+#endif
+#endif
+
+/**
+ * Result of the ENQUIRY ioctl.
+ */
+typedef struct nfdev_enquiry_str {
+  uint32_t  busno; /**< Which bus is the PCI device on. */
+  unsigned char slotno; /**< Which slot is the PCI device in. */
+  unsigned char reserved[3]; /**< for consistant struct alignment */
+} nfdev_enquiry_str;
+
+/**
+ * Result of the STATS ioctl.
+ */
+typedef struct nfdev_stats_str {
+  uint32_t  isr; /**< Count interrupts. */
+  uint32_t  isr_read; /**< Count read interrupts. */
+  uint32_t  isr_write; /**< Count write interrupts. */
+  uint32_t  write_fail; /**< Count write failures. */
+  uint32_t  write_block; /**< Count blocks written. */
+  uint32_t  write_byte; /**< Count bytes written. */
+  uint32_t  read_fail; /**< Count read failures. */
+  uint32_t  read_block; /**< Count blocks read. */
+  uint32_t  read_byte; /**< Count bytes read. */
+  uint32_t  ensure_fail; /**< Count read request failures. */
+  uint32_t  ensure; /**< Count read requests. */
+} nfdev_stats_str;
+
+/**
+ * Input to the CONTROL ioctl.
+ */
+typedef struct nfdev_control_str {
+  uint32_t  control; /**< Control flags. */
+} nfdev_control_str;
+
+/** Control bit indicating host supports MOI control */
+#define NFDEV_CONTROL_HOST_MOI 0x0001
+
+/** Index of control bits indicating desired mode
+ *
+ * Desired mode follows the M_ModuleMode enumeration.
+ */
+#define NFDEV_CONTROL_MODE_SHIFT 1
+
+/** Detect a backwards-compatible control value
+ *
+ * Returns true if the request control value "makes no difference", i.e.
+ * and the failure of an attempt to set it is therefore uninteresting.
+ */
+#define NFDEV_CONTROL_HARMLESS(c) ((c) <= 1)
+
+/**
+ * Result of the STATUS ioctl.
+ */
+typedef struct nfdev_status_str {
+  uint32_t  status; /**< Status flags. */
+  char      error[8]; /**< Error string. */
+} nfdev_status_str;
+
+/** Monitor firmware supports MOI control and error reporting */
+#define NFDEV_STATUS_MONITOR_MOI 0x0001
+
+/** Application firmware supports MOI control and error reporting */
+#define NFDEV_STATUS_APPLICATION_MOI 0x0002
+
+/** Application firmware running and supports error reporting */
+#define NFDEV_STATUS_APPLICATION_RUNNING 0x0004
+
+/** HSM failed
+ *
+ * Consult error[] for additional information.
+ */
+#define NFDEV_STATUS_FAILED 0x0008
+
+/** Standard PCI interface. */
+#define NFDEV_IF_STANDARD	0x01
+
+/** PCI interface with results pushed from device
+ *  via DMA.
+ */
+#define NFDEV_IF_PCI_PUSH	0x02
+
+/* platform independant base ioctl numbers */
+
+/** Enquiry ioctl.
+ *  \return nfdev_enquiry_str describing the attached device. */
+#define NFDEV_IOCTL_NUM_ENQUIRY        0x01
+
+/** Channel Update ioctl.
+ *  \deprecated */
+#define NFDEV_IOCTL_NUM_CHUPDATE       0x02
+
+/** Ensure Reading ioctl.
+ *  Signal a read request to the device.
+ *  \param (unsigned int) Length of data to be read.
+ */
+#define NFDEV_IOCTL_NUM_ENSUREREADING  0x03
+
+/** Device Count ioctl.
+ *  Not implemented for on all platforms.
+ *  \return (int) the number of attached devices. */
+#define NFDEV_IOCTL_NUM_DEVCOUNT       0x04
+
+/** Internal Debug ioctl.
+ *  Not implemented in release drivers. */
+#define NFDEV_IOCTL_NUM_DEBUG          0x05
+
+/** PCI Interface Version ioctl.
+ *  \param (int) Maximum PCI interface version
+ *   supported by the user of the device. */
+#define NFDEV_IOCTL_NUM_PCI_IFVERS     0x06
+
+/** Statistics ioctl.
+ *  \return nfdev_enquiry_str describing the attached device. */
+#define NFDEV_IOCTL_NUM_STATS          0x07
+
+/** Module control ioctl
+ * \param (nfdev_control_str) Value to write to HSM control register
+ */
+#define NFDEV_IOCTL_NUM_CONTROL        0x08
+
+/** Module state ioctl
+ * \return (nfdev_status_str) Values read from HSM status/error registers
+ */
+#define NFDEV_IOCTL_NUM_STATUS         0x09
+
+#endif
diff --git drivers/misc/nshield/nfdev-linux.h drivers/misc/nshield/nfdev-linux.h
new file mode 100644
index 000000000000..6b4a9c2a277c
--- /dev/null
+++ drivers/misc/nshield/nfdev-linux.h
@@ -0,0 +1,71 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfdev-linux.h: nFast linux specific device ioctl interface.
+
+(C) Copyright nCipher Corporation Ltd 1998 All rights reserved
+
+history
+
+14/07/1998 jsh  Original
+
+*/
+
+#ifndef NFDEV_LINUX_H
+#define NFDEV_LINUX_H
+
+#include "nfdev-common.h"
+
+#define NFDEV_IOCTL_TYPE 0x10
+
+#define NFDEV_IOCTL_CHUPDATE		_IO( NFDEV_IOCTL_TYPE, \
+					     NFDEV_IOCTL_NUM_CHUPDATE )
+
+#define NFDEV_IOCTL_ENQUIRY		_IOR( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_ENQUIRY, \
+					       nfdev_enquiry_str )
+
+#define NFDEV_IOCTL_ENSUREREADING	_IOW( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_ENSUREREADING, \
+					      int )
+
+#define NFDEV_IOCTL_ENSUREREADING_BUG3349	_IO( NFDEV_IOCTL_TYPE, \
+					     NFDEV_IOCTL_NUM_ENSUREREADING )
+
+
+#define NFDEV_IOCTL_DEBUG		_IOW( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_DEBUG, \
+					      int )
+
+#define NFDEV_IOCTL_PCI_IFVERS		_IOW( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_PCI_IFVERS, \
+					      int )
+
+#define NFDEV_IOCTL_STATS		_IOR( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_STATS, \
+					       nfdev_stats_str )
+
+#define NFDEV_IOCTL_CONTROL		_IOW( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_CONTROL, \
+					      const nfdev_control_str )
+ 
+#define NFDEV_IOCTL_STATUS		_IOR( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_STATUS, \
+					      nfdev_status_str )
+
+#endif /* NFDEV_LINUX_H */
diff --git drivers/misc/nshield/nfp_cmd.h drivers/misc/nshield/nfp_cmd.h
new file mode 100644
index 000000000000..ebabf370d4a6
--- /dev/null
+++ drivers/misc/nshield/nfp_cmd.h
@@ -0,0 +1,82 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp_cmd.h: nCipher PCI HSM command driver decalrations
+
+ * (c) Thales UK Limited 2015
+
+history
+
+10/10/2001 jsh  Original
+
+*/
+
+#ifndef NFPCMD_H
+#define NFPCMD_H
+
+#include "nfp_hostif.h"
+#include "nfp_error.h"
+
+/* read and write called with userspace buffer */
+
+typedef struct nfpcmd_dev {
+  const char *name;
+  unsigned short vendorid, deviceid,
+                 sub_vendorid, sub_deviceid;
+  unsigned int bar_sizes[6];    /* includes IO bit */
+  unsigned int flags;
+  nfp_err (*create)(struct nfp_cdev *pdev);
+  nfp_err (*destroy)(void * ctx);
+  nfp_err (*open)(void * ctx);
+  nfp_err (*close)(void * ctx);
+  nfp_err (*isr)(void *ctx, int *handled);
+  nfp_err (*write_block)( const char *ublock, int len, void *ctx );
+  nfp_err (*read_block)( char *ublock, int len, void *ctx, int *rcount);
+  nfp_err (*channel_update)( char *data, int len, void *ctx);
+  nfp_err (*ensure_reading)( unsigned int addr, int len, void *ctx );
+  nfp_err (*debug)( int cmd, void *ctx);
+  nfp_err (*setcontrol)(const nfdev_control_str *control, void *ctx); /* may be NULL */
+  nfp_err (*getstatus)(nfdev_status_str *status, void *ctx); /* may be NULL */
+} nfpcmd_dev;
+
+#define NFP_CMD_FLG_NEED_IOBUF	0x1
+
+/* list of all supported drivers ---------------------------------------- */
+
+extern const nfpcmd_dev *nfp_drvlist[];
+
+extern const nfpcmd_dev i21285_cmddev;
+extern const nfpcmd_dev i21555_cmddev;
+extern const nfpcmd_dev bcm5820_cmddev;
+
+#ifndef PCI_BASE_ADDRESS_SPACE_IO
+#define PCI_BASE_ADDRESS_SPACE_IO	0x1
+#endif
+
+#define NFP_MAXDEV	16
+
+
+#define NFP_MEMBAR_MASK    ~0xf
+#define NFP_IOBAR_MASK     ~0x3
+/*
+   This masks off the bottom bits of the PCI_CSR_BAR which signify that the
+   BAR is an IO BAR rather than a MEM BAR 
+*/ 
+
+#endif
+
diff --git drivers/misc/nshield/nfp_common.h drivers/misc/nshield/nfp_common.h
new file mode 100644
index 000000000000..28f13abb7eb8
--- /dev/null
+++ drivers/misc/nshield/nfp_common.h
@@ -0,0 +1,56 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp.h: nCipher PCI HSM Linux OS interface declarations
+
+ * (c) Thales UK Limited 2015
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#ifndef NFP_COMMON_H
+#define NFP_COMMON_H
+
+#include <linux/types.h>
+
+typedef u_int32_t UINT32;    
+typedef u_int8_t BYTE;      
+
+#define DEFINE_NFPCI_PACKED_STRUCTS
+#include "nfpci.h"
+#include "nfdev-linux.h"
+
+typedef int oserr_t;
+
+/* endian byte sex swapping ------------------------------------------- */
+
+/* little endian systems only for now */
+
+#define TO_LE16_IO(x,y) (*x=y)
+#define FROM_LE16_IO(x) (*x)
+
+#define TO_LE32_IO(x,y) (*x=y)
+#define FROM_LE32_IO(x) (*x)
+
+#define TO_LE32_MEM(x,y) (*x=y)
+#define FROM_LE32_MEM(x) (*x)
+
+#endif
diff --git drivers/misc/nshield/nfp_dev.h drivers/misc/nshield/nfp_dev.h
new file mode 100644
index 000000000000..08626b9290ef
--- /dev/null
+++ drivers/misc/nshield/nfp_dev.h
@@ -0,0 +1,69 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp_dev.h: nCipher PCI HSM linux device declarations
+
+ * (c) Thales UK Limited 2015
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#ifndef NFP_DEV_H
+#define NFP_DEV_H
+
+#include "nfp_fixup.h"
+#include "nfp_hostif.h"
+#include "nfp_cmd.h"
+
+/* Interpretation of the bits of nfp_dev.rd_outstanding */
+#define WAIT_BIT 0     /* waiting for data */
+#define CMPLT_BIT 1    /* completing a read (got data or timing out) */
+
+typedef struct nfp_dev {
+  nfp_cdev common;
+
+  int iosize[6];
+
+  unsigned char irq;
+
+  unsigned char *read_buf;
+
+  struct pci_dev *pcidev;
+
+  int busy;
+  int rd_ready;
+  int rd_ok;
+  int wr_ready;
+  int wr_ok;
+  unsigned long rd_outstanding;
+  int ifvers;
+
+  spinlock_t spinlock;
+
+  struct timer_list rd_timer;
+
+  nfp_wait_queue_head_t wr_queue;
+  nfp_wait_queue_head_t rd_queue;
+
+  nfpcmd_dev const *cmddev;
+} nfp_dev;
+
+#endif
diff --git drivers/misc/nshield/nfp_error.h drivers/misc/nshield/nfp_error.h
new file mode 100644
index 000000000000..3a06dc34a55a
--- /dev/null
+++ drivers/misc/nshield/nfp_error.h
@@ -0,0 +1,60 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp_error.h: nCipher PCI HSM error handling
+
+ * (c) Thales UK Limited 2015
+
+history
+
+05/12/2001 jsh  Original
+
+*/
+
+#ifndef NFP_ERROR_H
+#define NFP_ERROR_H
+
+#include "nfp_common.h"
+
+#define NFP_SUCCESS	0x0
+#define NFP_EFAULT      0x1
+#define NFP_ENOMEM	0x2
+#define NFP_EINVAL	0x3
+#define NFP_EIO		0x4
+#define NFP_ENXIO	0x5
+#define NFP_ENODEV	0x6
+#define NFP_EINTR	0x7
+#define NFP_ESTARTING	0x8
+#define NFP_EAGAIN	0x9
+#define NFP_EUNKNOWN	0x100
+
+typedef int nfp_err;
+
+extern oserr_t nfp_oserr( nfp_err nerr );
+extern nfp_err nfp_error( oserr_t oerr );
+
+#define nfr( x) \
+  return nfp_error((x))
+
+#define nfer(x, fn, msg) \
+  { oserr_t err=(x); if(err) { nfp_log( NFP_DBG1, #fn ": " msg); return nfp_error(err); } }
+
+#define er(x, fn, msg ) \
+{ nfp_err err=(x); if(err) { nfp_log( NFP_DBG1, #fn ": " msg); return err; } }
+
+#endif
diff --git drivers/misc/nshield/nfp_fixup.h drivers/misc/nshield/nfp_fixup.h
new file mode 100644
index 000000000000..1f3a9a3dc353
--- /dev/null
+++ drivers/misc/nshield/nfp_fixup.h
@@ -0,0 +1,199 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp_fixup.h: nCipher PCI HSM linux version fixup macros
+
+ * (c) Thales UK Limited 2015
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#ifndef FIXUP_H
+#define FIXUP_H
+
+#define VERSION(ver,rel,seq) (((ver)<<16) | ((rel)<<8) | (seq))
+#include <linux/version.h>
+
+
+#if LINUX_VERSION_CODE < VERSION(2,6,19)
+#ifndef AUTOCONF_INCLUDED
+#include <linux/config.h>
+#endif
+#endif
+
+#include <linux/types.h>
+#include <linux/time.h>
+#include <asm/io.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#if  LINUX_VERSION_CODE >= VERSION(2,3,0)
+#include <linux/slab.h>
+#else
+#include <linux/malloc.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+
+#if  LINUX_VERSION_CODE >= VERSION(2,6,22)
+#define pci_module_init pci_register_driver
+#endif
+
+#if  LINUX_VERSION_CODE >= VERSION(2,1,0)
+#include <linux/init.h>
+#if LINUX_VERSION_CODE < VERSION(2,6,39)
+#define spinlock_init(plock)  *(plock) = SPIN_LOCK_UNLOCKED
+#else
+#define spinlock_init(plock) *(plock) = __SPIN_LOCK_UNLOCKED(*(plock))
+#endif
+#if  LINUX_VERSION_CODE >= VERSION(2,6,0)
+  #include <linux/moduleparam.h>
+  #define NFP_MODULE_PARAMETERS \
+  module_param(nfp_debug,int,0644); \
+  module_param(nfp_ifvers,int,0444);
+#else
+  #define NFP_MODULE_PARAMETERS \
+  MODULE_PARM(nfp_debug,"1-4i"); \
+  MODULE_PARM(nfp_ifvers,"0-2i");
+#endif
+#define NFP_MODULE_PREAMBLE \
+  MODULE_AUTHOR("nCipher"); \
+  MODULE_DESCRIPTION("nCipher PCI HSM driver"); \
+  NFP_MODULE_PARAMETERS \
+  MODULE_PARM_DESC(nfp_debug,"debug level (1-4)"); \
+  MODULE_PARM_DESC(nfp_ifvers,"maximum interface version (1-2), or any (0)");
+#else
+#include <linux/bios32.h>
+typedef int spinlock_t;
+#define spin_lock(a)
+#define spin_unlock(a)
+#define spinlock_init(plock)
+#define NFP_MODULE_PREAMBLE
+#endif
+
+#if LINUX_VERSION_CODE >= VERSION(2,3,0)
+typedef wait_queue_head_t nfp_wait_queue_head_t;
+typedef wait_queue_entry_t nfp_wait_queue_t;
+
+#define nfp_init_waitqueue_head(x)    init_waitqueue_head(x)
+#define nfp_init_waitqueue_entry(x,y) init_waitqueue_entry(x,y)
+#define nfp_wake_up_all(x)          wake_up_all(x)
+#else
+typedef struct wait_queue *nfp_wait_queue_head_t;
+typedef struct wait_queue nfp_wait_queue_t;
+
+#define nfp_init_waitqueue_head(phead) *(phead) = NULL
+#define nfp_init_waitqueue_entry(entry,t) { (entry)->task= (t); (entry)->next=NULL; }
+#define nfp_wake_up_all(x)	wake_up(x)
+#endif
+
+#if LINUX_VERSION_CODE >= VERSION(2,2,0)
+#define NFP_MAJOR       176
+#else
+#define NFP_MAJOR       62
+#endif
+
+/* NB: most of the 2.1.x dependent code is untested */
+
+#if LINUX_VERSION_CODE >= VERSION(2,1,4)
+  #define COPY_FROM_USER(DST,SRC,LEN,error) error = copy_from_user(DST,SRC,LEN) ? -EFAULT : 0
+  #define COPY_TO_USER(DST,SRC,LEN,error)   error = copy_to_user(DST,SRC,LEN) ? -EFAULT : 0
+#if LINUX_VERSION_CODE >= VERSION(3,19,0)
+  #define INODE_FROM_FILE( file )       ((file)->f_path.dentry->d_inode)
+#else
+  #define INODE_FROM_FILE( file )       ((file)->f_dentry->d_inode)
+#endif
+
+  #include <linux/poll.h>
+  typedef ssize_t read_write_t;
+  typedef int release_t;
+  typedef size_t count_t;
+
+  #define READ_FIRST_ARG
+  #define READ_LAST_ARG , loff_t *unused
+  #define WRITE_FIRST_ARG
+  #define WRITE_LAST_ARG , loff_t *unused
+
+  #define RELEASE_RETURN( x ) return x
+  #define GET_FREE_PAGES( x, y, z ) __get_free_pages( x, y )
+
+  #if LINUX_VERSION_CODE >= VERSION(2,1,5)
+  #include <asm/uaccess.h>
+  #endif
+
+#else   /* 2.0.x and 2.1.x before 2.1.4 */
+  #define COPY_FROM_USER(DST,SRC,LEN,error) {               \
+      error = verify_area (VERIFY_READ, (void *) SRC, LEN); \
+      if (error == 0)                                       \
+        memcpy_fromfs(DST,SRC,LEN);                         \
+    }
+  #define COPY_TO_USER(DST,SRC,LEN,error){                     \
+      error = verify_area (VERIFY_WRITE, (void *) DST, LEN); \
+      if (error == 0)                                        \
+        memcpy_tofs(DST,SRC,LEN);                            \
+    }
+
+  #define INODE_FROM_FILE( file )       ((file)->f_inode)
+  typedef int read_write_t;
+  typedef void release_t;
+  typedef int count_t;
+
+  #define READ_FIRST_ARG struct inode *unused,
+  #define READ_LAST_ARG
+  #define WRITE_FIRST_ARG struct inode *unused,
+  #define WRITE_LAST_ARG
+
+  #define RELEASE_RETURN( x )
+
+  #define GET_FREE_PAGES( x, y, z ) __get_free_pages( x, y, z )
+#endif
+
+#if LINUX_VERSION_CODE < VERSION(2,1,0)
+#define NFP_TIMEOUT (jiffies + ((NFP_TIMEOUT_SEC) * HZ))
+#define IOREMAP(ADDR, LEN)            vremap(ADDR, LEN)
+#define IOUNMAP(ADDR)                 vfree(ADDR)
+#define signal_pending(a) ((a)->signal & ~(a)->blocked)
+#define nfp_schedule_timeout(time, timeout) \
+    current->timeout = time; \
+    schedule(); \
+    timeout = current->timeout;
+#else
+#define NFP_TIMEOUT ((NFP_TIMEOUT_SEC) * HZ)
+#define IOREMAP(ADDR, LEN)            ioremap(ADDR, LEN)
+  #define IOUNMAP(ADDR)                 iounmap(ADDR)
+  #define nfp_schedule_timeout(time, timeout) \
+    timeout = schedule_timeout(time);
+#endif
+
+#ifdef MODULE_LICENSE
+#define NFP_MODULE_LICENSE \
+  MODULE_LICENSE("GPL");
+#else
+#define NFP_MODULE_LICENSE
+#endif
+
+#endif
+
+
diff --git drivers/misc/nshield/nfp_hostif.h drivers/misc/nshield/nfp_hostif.h
new file mode 100644
index 000000000000..516022de1559
--- /dev/null
+++ drivers/misc/nshield/nfp_hostif.h
@@ -0,0 +1,66 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp_hostif.h: nCipher PCI HSM host interface declarations
+
+ * (c) Thales UK Limited 2015
+
+history
+
+10/10/2001 jsh  Original
+
+*/
+
+#ifndef NFP_HOSTIF_H
+#define NFP_HOSTIF_H
+
+#include "nfdev-common.h"
+
+struct nfp_dev;
+
+/* common device structure */
+
+typedef struct nfp_cdev {
+  unsigned char *bar[6];
+  void *extra[6];
+
+  int busno;
+  int slotno;
+
+  void *cmdctx;
+
+  char *iobuf;
+
+  struct nfp_dev* dev;
+
+  struct nfdev_stats_str stats;
+
+} nfp_cdev;
+
+/* callbacks from command drivers -------------------------------------- */
+
+void nfp_read_complete(  struct nfp_dev *pdev, int ok);
+void nfp_write_complete( struct nfp_dev *pdev, int ok);
+
+#define NFP_READ_MAX (8 * 1024)
+#define NFP_READBUF_SIZE (NFP_READ_MAX + 8)
+#define NFP_TIMEOUT_SEC 10
+
+#define NFP_DRVNAME "nCipher nFast PCI driver"
+
+#endif
diff --git drivers/misc/nshield/nfp_ifvers.c drivers/misc/nshield/nfp_ifvers.c
new file mode 100644
index 000000000000..8071a8437774
--- /dev/null
+++ drivers/misc/nshield/nfp_ifvers.c
@@ -0,0 +1,66 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * (c) Thales UK Limited 2015
+ *
+ *
+ */
+/*
+ * nfp_ifervs.c  - common pci interface versioning
+ *
+ * uses:
+ *
+ * int pdev->ifvers
+ *     device interface version
+ *
+ * int nfp_ifvers
+ *     interface version limit
+ * 
+ * int nfp_alloc_pci_push( nfp_dev *pdev )
+ *     allocates resources needed for PCI Push,
+ *     if not already allocated, and return True if successful
+ *
+ * void nfp_free_pci_push( nfp_dev *pdev ) {
+ *     frees any resources allocated to PCI Push
+ */
+
+void nfp_set_ifvers( nfp_dev *pdev, int vers ) {
+#ifdef _WIN32
+#pragma warning(disable:6239)
+#pragma warning(disable:6326)
+#endif
+  if( (nfp_ifvers != 0) && (vers > nfp_ifvers) ) {
+    nfp_log( NFP_DBG2,
+             "nfp_set_ifvers: can't set ifvers %d"
+             " as nfp_ifvers wants max ifvers %d",
+             vers, nfp_ifvers);
+    return;
+  }
+  if( vers >= NFDEV_IF_PCI_PUSH ) {
+    if(!nfp_alloc_pci_push(pdev)) {
+      nfp_log( NFP_DBG1,
+               "nfp_set_ifvers: can't set ifvers %d"
+               " as resources not available",
+               vers);
+      return;
+    }
+  } else {
+    nfp_free_pci_push(pdev);
+  }
+  pdev->ifvers= vers;
+  nfp_log( NFP_DBG3, "nfp_set_ifvers: setting ifvers %d", vers);
+}
diff --git drivers/misc/nshield/nfp_osif.h drivers/misc/nshield/nfp_osif.h
new file mode 100644
index 000000000000..c0378b65cb82
--- /dev/null
+++ drivers/misc/nshield/nfp_osif.h
@@ -0,0 +1,117 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp_osif.h: nCipher PCI HSM OS interface declarations
+
+ * (c) Thales UK Limited 2015
+
+history
+
+10/10/2001 jsh  Original
+
+*/
+
+#ifndef NFP_OSIF_H
+#define NFP_OSIF_H
+
+#include "nfp_hostif.h"
+#include "nfp_error.h"
+
+/* general typedefs ----------------------------------------------- */
+
+typedef volatile unsigned int reg32;
+typedef volatile unsigned short reg16;
+typedef volatile unsigned char reg8;
+
+/* sempaphores, mutexs and events --------------------------------- */
+
+#if 0
+extern nfp_err nfp_sema_init( nfp_sema *sema, int initial);
+extern void nfp_sema_destroy( nfp_sema *sema );
+extern void nfp_sema_post( nfp_sema *sema );
+extern void nfp_sema_wait( nfp_sema *sema );
+extern int nfp_sema_wait_sig( nfp_sema *sema );
+
+extern nfp_err nfp_mutex_init( nfp_mutex *mutex );
+extern void nfp_mutex_destroy( nfp_mutex *mutex );
+extern void nfp_mutex_enter( nfp_mutex *mutex );
+extern void nfp_mutex_exit( nfp_mutex *mutex );
+
+extern nfp_err nfp_event_init( nfp_event *event );
+extern void nfp_event_destroy( nfp_event *event );
+extern void nfp_event_set( nfp_event *event );
+extern void nfp_event_clear( nfp_event *event );
+extern void nfp_event_wait( nfp_event *event );
+extern void nfp_event_wait_sig( nfp_event *event );
+
+#endif
+
+/* timeouts ------------------------------------------------------ */
+
+extern void nfp_sleep( int ms );
+
+/* memory handling ----------------------------------------------- */
+
+#define KMALLOC_DMA	0
+#define KMALLOC_CACHED	1
+
+extern void *nfp_kmalloc( int size, int flags );
+extern void *nfp_krealloc( void *ptr, int size, int flags );
+extern void nfp_kfree( void * );
+
+/* config space access ------------------------------------------------ */
+
+/* return Little Endian 32 bit config register */
+extern nfp_err nfp_config_inl( nfp_cdev *pdev, int offset, unsigned int *res );
+
+/* io space access ------------------------------------------------ */
+
+extern unsigned int nfp_inl( nfp_cdev *pdev, int bar, int offset );
+extern unsigned short nfp_inw( nfp_cdev *pdev, int bar, int offset );
+extern void nfp_outl( nfp_cdev *pdev, int bar, int offset, unsigned int data );
+extern void nfp_outw( nfp_cdev *pdev, int bar, int offset, unsigned short data );
+
+/* user and device memory space access ---------------------------- */
+
+/* NB these 2 functions are not guarenteed to be re-entrant for a given device */
+extern nfp_err nfp_copy_from_user_to_dev( nfp_cdev *cdev, int bar, int offset, const char *ubuf, int len);
+extern nfp_err nfp_copy_to_user_from_dev( nfp_cdev *cdev, int bar, int offset, char *ubuf, int len);
+
+extern nfp_err nfp_copy_from_user( char *kbuf, const char *ubuf, int len );
+extern nfp_err nfp_copy_to_user( char *ubuf, const char *kbuf, int len );
+
+extern nfp_err nfp_copy_from_dev( nfp_cdev *cdev, int bar, int offset, char *kbuf, int len );
+extern nfp_err nfp_copy_to_dev( nfp_cdev *cdev, int bar, int offset, const char *kbuf, int len);
+
+/* debug ------------------------------------------------------------ */
+
+#define NFP_DBG1	1
+#define NFP_DBGE	NFP_DBG1
+#define NFP_DBG2	2
+#define NFP_DBG3	3
+#define NFP_DBG4	4
+
+#ifdef STRANGE_VARARGS
+extern void nfp_log();
+#else
+extern void nfp_log( int severity, const char *format, ...);
+#endif
+
+extern int nfp_debug;
+
+#endif
diff --git drivers/misc/nshield/nfpci.h drivers/misc/nshield/nfpci.h
new file mode 100644
index 000000000000..ea2d65cd5b4b
--- /dev/null
+++ drivers/misc/nshield/nfpci.h
@@ -0,0 +1,177 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+*
+*  NFPCI.H	- nFast PCI interface definition file
+*
+*
+*
+*  1998.06.09	IH	Started
+*
+* The interface presented by nFast PCI devices consists of:
+*
+* A region of shared RAM used for data transfer & control information
+* A doorbell interrupt register, so both sides can give each other interrupts
+* A number of DMA channels for transferring data
+*/
+
+#ifndef NFPCI_H
+#define NFPCI_H
+
+/* Sizes of some regions */
+#define NFPCI_RAM_MINSIZE	0x00100000
+/* This is the minimum size of shared RAM. In future it may be possible to
+   negotiate larger sizes of shared RAM or auto-detect how big it is */
+#define NFPCI_RAM_MINSIZE_JOBS	0x00020000 /* standard jobs only */
+#define NFPCI_RAM_MINSIZE_KERN	0x00040000 /* standard and kernel jobs */
+
+/* Offsets within shared memory space.
+   The following main regions are:
+     jobs input area
+     jobs output area
+     kernel jobs input area
+     kernel output area
+*/
+
+#define NFPCI_OFFSET_JOBS		0x00000000
+#define NFPCI_OFFSET_JOBS_WR		0x00000000
+#define NFPCI_OFFSET_JOBS_RD		0x00010000
+#define NFPCI_OFFSET_KERN		0x00020000
+#define NFPCI_OFFSET_KERN_WR		0x00020000
+#define NFPCI_OFFSET_KERN_RD		0x00030000
+
+/* Interrupts, defined by bit position in doorbell register */
+
+/* Interrupts from device to host */
+#define NFAST_INT_DEVICE_WRITE_OK               0x00000001
+#define NFAST_INT_DEVICE_WRITE_FAILED           0x00000002
+#define NFAST_INT_DEVICE_READ_OK                0x00000004
+#define NFAST_INT_DEVICE_READ_FAILED            0x00000008
+#define NFAST_INT_DEVICE_KERN_WRITE_OK		0x00000010
+#define NFAST_INT_DEVICE_KERN_WRITE_FAILED	0x00000020
+#define NFAST_INT_DEVICE_KERN_READ_OK		0x00000040
+#define NFAST_INT_DEVICE_KERN_READ_FAILED	0x00000080
+
+/* Interrupts from host to device */
+#define NFAST_INT_HOST_WRITE_REQUEST            0x00010000
+#define NFAST_INT_HOST_READ_REQUEST             0x00020000
+#define NFAST_INT_HOST_DEBUG                    0x00040000
+#define NFAST_INT_HOST_KERN_WRITE_REQUEST	0x00080000
+#define NFAST_INT_HOST_KERN_READ_REQUEST	0x00100000
+
+/* Ordinary job submission ------------------------ */
+
+/* The NFPCI_OFFSET_JOBS_WR and NFPCI_OFFSET_JOBS_RD regions are defined
+   by the following (byte) address offsets... */
+
+#define NFPCI_OFFSET_CONTROL	0x0
+#define NFPCI_OFFSET_LENGTH	0x4
+#define NFPCI_OFFSET_DATA	0x8
+#define NFPCI_OFFSET_PUSH_ADDR	0x8
+
+#define NFPCI_JOBS_WR_CONTROL	(NFPCI_OFFSET_JOBS_WR + NFPCI_OFFSET_CONTROL)
+#define NFPCI_JOBS_WR_LENGTH	(NFPCI_OFFSET_JOBS_WR + NFPCI_OFFSET_LENGTH)
+#define NFPCI_JOBS_WR_DATA	(NFPCI_OFFSET_JOBS_WR + NFPCI_OFFSET_DATA)
+#define NFPCI_MAX_JOBS_WR_LEN		(0x0000FFF8)
+
+#define NFPCI_JOBS_RD_CONTROL	(NFPCI_OFFSET_JOBS_RD + NFPCI_OFFSET_CONTROL)
+#define NFPCI_JOBS_RD_LENGTH	(NFPCI_OFFSET_JOBS_RD + NFPCI_OFFSET_LENGTH)
+#define NFPCI_JOBS_RD_DATA	(NFPCI_OFFSET_JOBS_RD + NFPCI_OFFSET_DATA)
+/* address in PCI space of host buffer for NFPCI_JOB_CONTROL_PCI_PUSH */
+#define NFPCI_JOBS_RD_PUSH_ADDR	(NFPCI_OFFSET_JOBS_RD + NFPCI_OFFSET_PUSH_ADDR)
+#define NFPCI_MAX_JOBS_RD_LEN		(0x000FFF8)
+
+/* Kernel inferface job submission ---------------- */
+
+#define NFPCI_KERN_WR_CONTROL   (NFPCI_OFFSET_KERN_WR + NFPCI_OFFSET_CONTROL)
+#define NFPCI_KERN_WR_LENGTH    (NFPCI_OFFSET_KERN_WR + NFPCI_OFFSET_LENGTH)
+#define NFPCI_KERN_WR_DATA      (NFPCI_OFFSET_KERN_WR + NFPCI_OFFSET_DATA)
+#define NFPCI_MAX_KERN_WR_LEN      (0x0000FFF8)
+
+#define NFPCI_KERN_RD_CONTROL   (NFPCI_OFFSET_KERN_RD + NFPCI_OFFSET_CONTROL)
+#define NFPCI_KERN_RD_LENGTH    (NFPCI_OFFSET_KERN_RD + NFPCI_OFFSET_LENGTH)
+#define NFPCI_KERN_RD_DATA      (NFPCI_OFFSET_KERN_RD + NFPCI_OFFSET_DATA)
+/* address in PCI space of host buffer for NFPCI_JOB_CONTROL_PCI_PUSH */
+#define NFPCI_KERN_RD_ADDR      (NFPCI_OFFSET_KERN_RD + NFPCI_OFFSET_PUSH_ADDR)
+#define NFPCI_MAX_KERN_RD_LEN		(0x000FFF8)
+
+#ifdef DEFINE_NFPCI_PACKED_STRUCTS
+typedef struct
+{
+  UINT32	controlword;
+  UINT32	length;		/* length of data to follow */
+  union {
+    BYTE	data[1];
+    UINT32	addr;
+  } uu;
+}
+  NFPCI_JOBS_BLOCK;
+#endif
+
+
+#define NFPCI_JOB_CONTROL		0x00000001
+#define NFPCI_JOB_CONTROL_PCI_PUSH	0x00000002
+/*
+   The 'Control' word is analogous to the SCSI read/write address;
+   1 = standard push/pull IO
+   2 = push/push IO
+
+   To submit a block of job data, the host:
+   - sets the (32-bit, little-endian) word at NFPCI_JOBS_WR_CONTROL to NFPCI_JOB_CONTROL
+   - sets the word at NFPCI_JOBS_WR_LENGTH to the length of the data
+   - copies the data to NFPCI_JOBS_WR_DATA
+   - sets interrupt NFAST_INT_HOST_WRITE_REQUEST in the doorbell register
+   - awaits the NFAST_INT_DEVICE_WRITE_OK (or _FAILED) interrupts back
+
+   To read a block of jobs back, the host:
+   - sets the word at NFPCI_JOBS_RD_CONTROL to NFPCI_JOB_CONTROL
+   - sets the word at NFPCI_JOBS_RD_LENGTH to the max length for returned data
+   - sets interrupt NFAST_INT_HOST_READ_REQUEST
+   - awaits the NFAST_INT_DEVICE_READ_OK (or _FAILED) interrupt
+   - reads the data from NFPCI_JOBS_RD_DATA; the module will set the word at
+	NFPCI_JOBS_RD_LENGTH to its actual length.
+
+   Optionally the host can request the PCI read data to be pushed to host PCI mapped ram:
+   - allocates a contiguous PCI addressable buffer for a NFPCI_JOBS_BLOCK of max
+        size NFPCI_MAX_JOBS_RD_LEN (or NFPCI_MAX_KERN_RD_LEN) + 8
+   - sets the word at NFPCI_JOBS_RD_CONTROL to NFPCI_JOB_CONTROL_PCI_PUSH
+   - sets the word at NFPCI_JOBS_RD_LENGTH to the max length for returned data
+   - sets the word at NFPCI_JOBS_RD_PUSH_ADDR to be the host PCI address of
+        the buffer
+   - sets interrupt NFAST_INT_HOST_READ_REQUEST
+   - awaits the NFAST_INT_DEVICE_READ_OK (or _FAILED) interrupt
+   - reads the data from the buffer at NFPCI_OFFSET_DATA in the buffer.  The
+        module will set NFPCI_OFFSET_LENGTH to the actual length.
+*/
+
+#define NFPCI_SCRATCH_CONTROL       0
+
+#define NFPCI_SCRATCH_CONTROL_HOST_MOI   (1<<0)
+#define NFPCI_SCRATCH_CONTROL_MODE_SHIFT 1
+#define NFPCI_SCRATCH_CONTROL_MODE_MASK  (3<<NFPCI_SCRATCH_CONTROL_MODE_SHIFT)
+
+#define NFPCI_SCRATCH_STATUS        1
+
+#define NFPCI_SCRATCH_STATUS_MONITOR_MOI         (1<<0)
+#define NFPCI_SCRATCH_STATUS_APPLICATION_MOI     (1<<1)
+#define NFPCI_SCRATCH_STATUS_APPLICATION_RUNNING (1<<2)
+#define NFPCI_SCRATCH_STATUS_ERROR               (1<<3)
+
+#define NFPCI_SCRATCH_ERROR_LO      2
+#define NFPCI_SCRATCH_ERROR_HI      3
+
+#endif
diff --git drivers/misc/nshield/osif.c drivers/misc/nshield/osif.c
new file mode 100644
index 000000000000..1755d7da163f
--- /dev/null
+++ drivers/misc/nshield/osif.c
@@ -0,0 +1,213 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+osif.c: nCipher PCI HSM OS interface
+
+ * (c) Thales UK Limited 2015
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#include "nfp_common.h"
+#include "nfp_error.h"
+#include "nfp_fixup.h"
+#include "nfp_hostif.h"
+#include "nfp_osif.h"
+#include "nfp_error.h"
+#include "autoversion.h"
+#include "nfp_dev.h"
+
+void nfp_sleep( int ms ) {
+#if LINUX_VERSION_CODE >= VERSION(2,5,0)
+  DEFINE_WAIT(wait);
+#endif
+  nfp_wait_queue_head_t q;
+
+  nfp_init_waitqueue_head( &q );
+
+#if LINUX_VERSION_CODE >= VERSION(2,5,0)
+  prepare_to_wait(&q, &wait, TASK_UNINTERRUPTIBLE);
+  schedule_timeout((ms * HZ) / 1000);
+  finish_wait(&q, &wait);
+#else
+  sleep_on_timeout( &q, (ms * HZ) / 1000 );
+#endif
+}
+
+nfp_err nfp_config_inl( nfp_cdev *pdev, int offset, unsigned int *res ) {
+  if(!pdev->dev || !pdev->dev->pcidev)
+    return NFP_ENODEV;
+  pci_read_config_dword( pdev->dev->pcidev, offset, res);
+  return 0;
+}
+
+/* user space memory access ---------------------------------- */
+
+nfp_err nfp_copy_from_user( char *kbuf, const char *ubuf, int len) {
+  int oserr;
+  long task_state;
+  task_state = current->__state;
+  COPY_FROM_USER(kbuf, ubuf, len, oserr);
+  current->__state = task_state;
+  nfr( oserr );
+}
+
+nfp_err nfp_copy_to_user( char *ubuf, const char *kbuf, int len) {
+  int oserr;
+  long task_state;
+  task_state = current->__state;
+  COPY_TO_USER(ubuf, kbuf, len, oserr);
+  current->__state = task_state;
+  nfr( oserr );
+}
+
+nfp_err nfp_copy_from_user_to_dev( nfp_cdev *cdev, int bar, int offset, const char *ubuf, int len) {
+  int oserr;
+  long task_state;
+  task_state = current->__state;
+  COPY_FROM_USER(cdev->bar[bar] + offset, ubuf, len, oserr);
+  current->__state = task_state;
+  nfr( oserr );
+}
+
+nfp_err nfp_copy_to_user_from_dev( nfp_cdev *cdev, int bar, int offset, char *ubuf, int len) {
+  int oserr;
+  long task_state;
+  task_state = current->__state;
+  COPY_TO_USER(ubuf, cdev->bar[bar] + offset, len, oserr);
+  current->__state = task_state;
+  nfr( oserr );
+}
+
+nfp_err nfp_copy_from_dev( nfp_cdev *cdev, int bar, int offset, char *kbuf, int len) {
+  memcpy( kbuf, cdev->bar[bar] + offset, len);
+  return NFP_SUCCESS;
+}
+
+nfp_err nfp_copy_to_dev( nfp_cdev *cdev, int bar, int offset, const char *kbuf, int len) {
+  memcpy( cdev->bar[bar] + offset, kbuf, len);
+  return NFP_SUCCESS;
+}
+
+/* pci io space access --------------------------------------- */
+
+unsigned int nfp_inl( nfp_cdev *pdev, int bar, int offset ) {
+  nfp_log( NFP_DBG3, "nfp_inl: addr %lx", (unsigned long) pdev->bar[bar] + offset);
+  return inl_p( (unsigned long) pdev->bar[bar] + offset);
+}
+
+unsigned short nfp_inw( nfp_cdev *pdev, int bar, int offset ) {
+  nfp_log( NFP_DBG3, "nfp_inl: addr %lx", (unsigned long) pdev->bar[bar] + offset);
+  return inw_p( (unsigned long) pdev->bar[bar] + offset);
+}
+
+void nfp_outl( nfp_cdev *pdev, int bar, int offset, unsigned int data ) {
+  nfp_log( NFP_DBG3, "nfp_outl: addr %lx, data %x", (unsigned long) pdev->bar[bar] + offset, data);
+  outl_p( data, (unsigned long) pdev->bar[bar] + offset );
+}
+
+void nfp_outw( nfp_cdev *pdev, int bar, int offset, unsigned short data ) {
+  nfp_log( NFP_DBG3, "nfp_outl: addr %lx, data %x", (unsigned long) pdev->bar[bar] + offset, data);
+  outw_p( data, (unsigned long) pdev->bar[bar] + offset );
+}
+
+/* logging ---------------------------------------------------- */
+
+void nfp_log( int level, const char *fmt, ...)
+{
+#if LINUX_VERSION_CODE < VERSION(2,6,13)
+  auto char buf[256];
+#endif
+  va_list ap;
+
+#ifndef VERSION_DISTRIBUTION
+/* Legacy build system does not have VERSION_DISTRIBUTION,
+ * Use the component version number instead.
+ */
+#define VERSION_DISTRIBUTION VERSION_NO
+#endif
+
+  switch (level) {
+  case NFP_DBG4: if (nfp_debug < 4) break;
+    fallthrough;
+  case NFP_DBG3: if (nfp_debug < 3) break;
+    fallthrough;
+  case NFP_DBG2: if (nfp_debug < 2) break;
+    fallthrough;
+  case NFP_DBG1: if (nfp_debug < 1) break;
+    fallthrough;
+  default:
+    printk ("nfdrv " VERSION_DISTRIBUTION ": ");
+    va_start(ap, fmt);
+#if LINUX_VERSION_CODE >= VERSION(2,6,13)
+    (void) vprintk(fmt, ap);
+#else
+    (void) vsnprintf(buf, 256, fmt, ap);
+    printk(buf);
+#endif
+    va_end(ap);
+    printk ("\n");
+    break;
+  }
+}
+
+struct errstr {
+  int oserr;
+  nfp_err nferr;
+};
+
+static struct errstr errtab[] = {
+  { -EFAULT, NFP_EFAULT },
+  { -ENOMEM, NFP_ENOMEM },
+  { -EINVAL, NFP_EINVAL },
+  { -EIO, NFP_EIO },
+  { -ENXIO, NFP_ENXIO },
+  { -ENODEV, NFP_ENODEV },
+  { 0, 0 }
+};
+
+nfp_err nfp_error( int oserr ) {
+  struct errstr *perr;
+  if(!oserr)
+    return 0;
+  perr= errtab;
+  while(perr->nferr) {
+   if(perr->oserr == oserr)
+     return perr->nferr;
+   perr++;
+  }
+  return NFP_EUNKNOWN;
+}
+
+int nfp_oserr( nfp_err nferr )
+{
+  struct errstr *perr;
+  if( nferr == NFP_SUCCESS)
+    return 0;
+  perr= errtab;
+  while(perr->nferr) {
+   if(perr->nferr == nferr)
+     return perr->oserr;
+   perr++;
+  }
+  return EIO;
+}
+
