diff --git drivers/misc/Kconfig drivers/misc/Kconfig
index 0f5a49fc7c9e..16184198ba41 100644
--- drivers/misc/Kconfig
+++ drivers/misc/Kconfig
@@ -477,6 +477,7 @@ source "drivers/misc/ti-st/Kconfig"
 source "drivers/misc/lis3lv02d/Kconfig"
 source "drivers/misc/altera-stapl/Kconfig"
 source "drivers/misc/mei/Kconfig"
+source "drivers/misc/nshield/Kconfig"
 source "drivers/misc/vmw_vmci/Kconfig"
 source "drivers/misc/genwqe/Kconfig"
 source "drivers/misc/echo/Kconfig"
diff --git drivers/misc/Makefile drivers/misc/Makefile
index a086197af544..e5999df68673 100644
--- drivers/misc/Makefile
+++ drivers/misc/Makefile
@@ -41,6 +41,7 @@ obj-y				+= ti-st/
 obj-y				+= lis3lv02d/
 obj-$(CONFIG_ALTERA_STAPL)	+=altera-stapl/
 obj-$(CONFIG_INTEL_MEI)		+= mei/
+obj-$(CONFIG_HSM_NCIPHER)   += nshield/
 obj-$(CONFIG_VMWARE_VMCI)	+= vmw_vmci/
 obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lattice-ecp3-config.o
 obj-$(CONFIG_SRAM)		+= sram.o
diff --git drivers/misc/nshield/Kconfig drivers/misc/nshield/Kconfig
new file mode 100644
index 000000000000..107642ba27f2
--- /dev/null
+++ drivers/misc/nshield/Kconfig
@@ -0,0 +1,4 @@
+config HSM_NCIPHER
+	bool "Thales nCipher HSM support"
+	help
+	  This option enables the driver for nShield HSMs
diff --git drivers/misc/nshield/Makefile drivers/misc/nshield/Makefile
new file mode 100644
index 000000000000..2237adc7d8d6
--- /dev/null
+++ drivers/misc/nshield/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_HSM_NCIPHER) := nfp.o
+nfp-objs := drvlist.o fsl.o hostif.o i21555.o i21555d.o osif.o
diff --git drivers/misc/nshield/autoversion.h drivers/misc/nshield/autoversion.h
new file mode 100644
index 000000000000..e4203de02c4b
--- /dev/null
+++ drivers/misc/nshield/autoversion.h
@@ -0,0 +1,18 @@
+/* AUTOGENERATED by ../main/cmake/python/mkautoversion.py - DO NOT EDIT */
+#ifndef AUTOVERSION_H
+#define AUTOVERSION_H
+
+#define VERSION_RELEASEMAJOR 12
+#define VERSION_RELEASEMINOR 80
+#define VERSION_RELEASEPATCH 4
+#define VERSION_CHECKINTIMEHIGH 0x00000000UL
+#define VERSION_CHECKINTIMELOW  0x618AEB9CUL
+#define VERSION_CHECKINSTRING "813026a88"
+#define VERSION_BUILDSTRING "#274 2021/11/09 21:43:56 UTC"
+#define VERSION_NO "12.80.4-274-813026a"
+#define VERSION_SOFTSTRING VERSION_NO
+#define VERSION_STRING "12.80.4-274-813026a"
+#define VERSION_COMPNAME "nshield"
+#define VERSION_TOOL "nshield (12.80.4-274-813026a)"
+
+#endif
diff --git drivers/misc/nshield/devinit.h drivers/misc/nshield/devinit.h
new file mode 100644
index 000000000000..42e8e67f776c
--- /dev/null
+++ drivers/misc/nshield/devinit.h
@@ -0,0 +1,51 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+devinit.h: devinit declaration removed from since 3.8 kernel
+ * (c) nCipher Security Limited 2019
+ */
+
+#ifndef DEVINIT_H_
+#define DEVINIT_H_
+
+#include <linux/version.h>
+
+/*
+ * Since linux kernel 3.8 the following macros are removed.
+ */
+
+#if LINUX_VERSION_CODE >= VERSION(3,8,0)
+
+# ifndef __devinit
+#   define __devinit
+# endif
+
+# ifndef __devinitdata
+#   define __devinitdata
+# endif
+
+# ifndef __devexit
+#   define __devexit
+# endif
+
+# ifndef __devexit_p
+#   define __devexit_p
+# endif
+
+#endif /* LINUX_VERSION_CODE >= VERSION(3,8,0) */
+
+#endif /* DEVINIT_H_ */
diff --git drivers/misc/nshield/drvlist.c drivers/misc/nshield/drvlist.c
new file mode 100644
index 000000000000..5bb6a77304f3
--- /dev/null
+++ drivers/misc/nshield/drvlist.c
@@ -0,0 +1,39 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+drvlist.c: nCipher PCI HSM command driver list
+
+ * (c) nCipher Security Limited 2019
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#include "nfp_common.h"
+#include "nfp_fixup.h"
+#include "nfp_cmd.h"
+
+const nfpcmd_dev *nfp_drvlist[] = {
+  &i21555_cmddev,
+  &fsl_c293_cmddev,
+  &fsl_p3041_cmddev,
+  &fsl_t1022_cmddev,
+  NULL
+};
diff --git drivers/misc/nshield/fsl.c drivers/misc/nshield/fsl.c
new file mode 100644
index 000000000000..07540a06a3e5
--- /dev/null
+++ drivers/misc/nshield/fsl.c
@@ -0,0 +1,911 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+ fsl.c: nCipher PCI HSM FSL command driver
+
+ (C) Copyright nCipher Security Limited 2019 All rights reserved
+
+ history
+
+ 09/10/2001 jsh  Original
+
+ */
+
+#include "fsl.h"
+#include "fsl_osif.h"
+#include "nfp_common.h"
+#include "nfp_error.h"
+#include "nfp_hostif.h"
+#include "nfp_osif.h"
+#include "nfp_cmd.h"
+#include "nfpci.h"
+
+
+#ifdef _MSC_VER
+#define __func__ __FUNCTION__
+#endif
+
+
+/* If defined, use aggressive checking for errors. */
+#define FSL_AGRESSIVE_CHECKING 0
+
+/**
+ * Resets FSL device.
+ *
+ * Extra device info is initialized the first time created.
+ *
+ * @param cdev common device.
+ * @returns NFP_SUCCESS if successful, other value if error.
+ */
+static nfp_err fsl_create(nfp_cdev *cdev) {
+    uint32_t clr = 0;
+
+    nfp_log(NFP_DBG4, "fsl_create: entered");
+
+    if (cdev == NULL) {
+        nfp_log(NFP_DBG1, "fsl_create: error: no device");
+        return NFP_ENODEV;
+    }
+
+    if (cdev->created) {
+        nfp_log(NFP_DBG3, "fsl_create: device already created");
+        return NFP_SUCCESS;
+    }
+
+    cdev->active_bar = -1;
+    cdev->detection_type = NFP_EPOLLING;
+    cdev->conn_status = NFP_ESTARTING;
+
+    /* try to reset check doorbell registers (don't read back in case they hang) */
+    TO_LE32_MEM(&clr, NFAST_INT_DEVICE_CLR);
+
+#if defined(__unix__)
+    cdev->active_bar = FSL_MEMBAR;
+    fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_CS_STATUS, clr);
+#elif defined(WINVER)
+    /* perform check to see if Bar0 and Bar1 are open for backwards compatibility.
+    If both bars are open Element [1] in the array will be populated */
+    if (cdev->bar[FSL_MEMBAR] == NULL) {
+        cdev->active_bar = 0;
+        fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_CS_STATUS, clr);
+    } else {
+        cdev->active_bar = 1;
+        fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_CS_STATUS, clr);
+    }
+#endif
+
+    if (cdev->bar[cdev->active_bar] == NULL) {
+        nfp_log(NFP_DBG1, "fsl_create: error: null FSL memory BAR[%d]", cdev->active_bar);
+        return NFP_ENOMEM;
+    }
+
+    /* set our context to just be a pointer to ourself */
+    cdev->cmdctx = cdev;
+
+    /* try to reset read/write doorbell registers (don't read back in case they hang) */
+    nfp_log(NFP_DBG3, "fsl_create: clearing read/write doorbell registers");
+    TO_LE32_MEM(&clr, NFAST_INT_HOST_CLR);
+    fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_CMD, clr);
+    fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_CMD, clr);
+	
+    nfp_log(NFP_DBG3, "fsl_create: exiting fsl_create active_bar: %d.", cdev->active_bar);
+
+    cdev->created = 1;
+    
+    return NFP_SUCCESS;
+}
+
+/**
+ * Destroys an FSL device.
+ *
+ * @param ctx device context (always the device itself).
+ * @returns NFP_SUCCESS if successful, other value if error.
+ */
+static nfp_err fsl_destroy(void *ctx) {
+    nfp_cdev *cdev;
+    unsigned int tmp32;
+
+    nfp_log(NFP_DBG4, "fsl_destroy: entered");
+
+    /* check for device */
+    cdev = (nfp_cdev *)ctx;
+    if (cdev == NULL) {
+        nfp_log(NFP_DBG1, "fsl_destroy: warning: no device");
+        return NFP_ENODEV;
+    }
+
+    /* clear doorbell registers */
+    if (cdev->bar[cdev->active_bar] != NULL) {
+        nfp_log(NFP_DBG3, "fsl_destroy: clearing doorbell registers");
+        TO_LE32_MEM(&tmp32, NFAST_INT_DEVICE_CLR);
+        fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_STATUS, tmp32);
+        fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_STATUS, tmp32);
+        fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_CS_STATUS, tmp32);
+    } else {
+        nfp_log(NFP_DBG1, "fsl_destroy: warning: no FSL BAR[%d] memory", cdev->active_bar);
+    }
+
+    return NFP_SUCCESS;
+}
+
+/**
+ * Returns fsl_created status.
+ *
+ * @param cdev common device.
+ * @returns NFP_SUCCESS if created or other value if error.
+ */
+static nfp_err fsl_created(nfp_cdev *cdev) {
+    nfp_log(NFP_DBG4, "%s: entered", __func__);
+
+    /* check for device */
+
+    if (!cdev) {
+        nfp_log(NFP_DBG1, "%s: error: no device", __func__);
+        return NFP_ENODEV;
+    }
+
+    if (!cdev->created) {
+        nfp_log(NFP_DBG1, "%s: error: device not created", __func__);
+        return NFP_ENODEV;
+    }
+
+    if (cdev->bar[cdev->active_bar] == NULL) {
+        nfp_log(NFP_DBG1, "%s: error: no FSL BAR[%d] memory", __func__, cdev->active_bar);
+        return NFP_ENOMEM;
+    }
+
+    return NFP_SUCCESS;
+}
+
+/* ----------------------------------------------------- */
+/* This call needs to be in synch with the ISR or the ISR will come in the middle 
+*  of a write/read op and cause problems.   
+* 
+*/
+static int fsl_connection_status(nfp_cdev *cdev, int lock_flag, nfp_err epd_status) {
+       
+    nfp_err status = NFP_ESTARTING;
+    (void) lock_flag;
+
+    if (!cdev) {
+       return NFP_ENODEV;
+    }
+
+    /* this code is mainly to support backwards compatibility with the interrupt driven approach
+     * to detection.
+     */
+    if (epd_status == NFP_EPOLLING) {
+        cdev->detection_type = NFP_EPOLLING;
+        cdev->conn_status = NFP_SUCCESS;
+    } else if (epd_status == NFAST_INT_DEVICE_PCI_DOWN) {
+         cdev->conn_status = NFP_ESTARTING;
+    }
+
+    status = cdev->conn_status;
+    return status;
+}
+
+/**
+ * Returns connection check status.
+ *
+ * @param cdev common device.
+ * @returns NFP_SUCCESS if started, NFP_ESTARTING if not ready, or other value if error.
+ */
+static nfp_err fsl_started(nfp_cdev *cdev, int lock_flag) {
+    nfp_err status = NFP_ESTARTING;
+    nfp_err epd_status = NFP_ESTARTING;
+    uint32_t doorbell_cs = 0x0;
+
+    nfp_log(NFP_DBG4, "%s: entered", __func__);
+
+    /* check for device */
+
+    if (!cdev) {
+        nfp_log(NFP_DBG1, "%s: error: no device", __func__);
+        return NFP_ENODEV;
+    }
+
+    if (cdev->bar[cdev->active_bar] == NULL) {
+        nfp_log(NFP_DBG1, "%s: error: no FSL BAR[%d] memory", __func__, cdev->active_bar);
+        return NFP_ENOMEM;
+    }
+    
+    /* check the status register to see if epd has started */
+    doorbell_cs = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_POLLING);
+    doorbell_cs = FROM_LE32_MEM(&doorbell_cs);
+    nfp_log(NFP_DBG3, "%s: doorbell_polling is: %x", __func__,doorbell_cs);
+    
+    if(doorbell_cs == NFAST_INT_DEVICE_POLL){
+        epd_status = NFP_EPOLLING;
+        nfp_log(NFP_DBG3, "%s: EPD in polling mode", __func__);
+    }
+    else if(doorbell_cs == NFAST_INT_DEVICE_PCI_DOWN){
+        epd_status = NFAST_INT_DEVICE_PCI_DOWN;
+    }
+    /* check current connection status */
+    status = fsl_connection_status(cdev, lock_flag,epd_status);
+
+    if (status == NFP_SUCCESS) {
+        nfp_log(NFP_DBG3, "%s: device started", __func__);
+    } else if (status == NFP_ESTARTING) {
+        nfp_log(NFP_DBG3, "%s: device starting", __func__);
+    } else {
+        nfp_log(NFP_DBG1, "%s: error: device failure: code 0x%x", __func__, status);
+    }
+
+    return status;
+}
+
+/**
+ * Resets connection check status.
+ *
+ * This can be called by the device driver when an I/O operation times out. This causes any
+ * following I/O operations to fail quickly until fsl_started() has been set successfully by a
+ * periodic check interrupt.
+ *
+ * @param cdev common device.
+ * @returns NFP_SUCCESS if stopped or other value if error.
+ */
+static nfp_err fsl_stopped(nfp_cdev *cdev) {
+
+    nfp_log(NFP_DBG4, "%s: entered", __func__);
+
+    /* check for device */
+
+    if (!cdev) {
+        nfp_log(NFP_DBG1, "%s: error: no device", __func__);
+        return NFP_ENODEV;
+    }
+
+    if (cdev->bar[cdev->active_bar] == NULL) {
+        nfp_log(NFP_DBG1, "%s: error: no FSL BAR[%d] memory", __func__, cdev->active_bar);
+        return NFP_ENOMEM;
+    }
+
+    /* reset current connection status */
+
+    cdev->conn_status = NFP_ESTARTING;
+
+    nfp_log(NFP_DBG2, "%s: device stopped", __func__);
+
+    return NFP_SUCCESS;
+}
+
+static int fsl_update_connection_status(nfp_cdev *cdev, int status) {
+
+    int current_status;
+    if (!cdev) {
+        return NFP_ENODEV;
+    }
+
+    current_status = cdev->conn_status;
+    cdev->conn_status = status;
+    return current_status;
+}
+
+/**
+ * Completes a connection check status interrupt.
+ *
+ * @param cdev common device.
+ * @param status device status.
+ */
+static void fsl_check_complete(nfp_cdev *cdev, nfp_err status) {
+    nfp_err ne;
+    uint32_t clr, chk;
+    int started;
+
+    nfp_log(NFP_DBG4, "%s: entered", __func__);
+
+    /* check for device */
+
+    if ((ne = fsl_created(cdev)) != NFP_SUCCESS) {
+        nfp_log(NFP_DBG1, "%s: error: check not completed", __func__);
+        return;
+    }
+
+    /* started becomes true after fsl_create and the first cs interrupt is successful.
+	*  It switches to false right afer since cs_status is set to NFP_SUCCESS right after this check.
+	*  A fsl_close or a fsl_create can reset the cs_status to NFP_ESTARTING again.
+	*/
+   started = (fsl_update_connection_status(cdev, status) == NFP_ESTARTING) && (status == NFP_SUCCESS);
+    
+   /* reset read/write doorbell registers if just started */
+
+    if (started) {
+        nfp_log(NFP_DBG3, "fsl_create: clearing read/write doorbell registers");
+        TO_LE32_MEM(&clr, NFAST_INT_HOST_CLR);
+        fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_CMD, clr);
+        chk = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_CMD);
+        fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_CMD, clr);
+        chk = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_CMD);
+        TO_LE32_MEM(&clr, NFAST_INT_DEVICE_CLR);
+        fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_STATUS, clr);
+        chk = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_STATUS);
+        fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_STATUS, clr);
+        chk = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_STATUS);
+    }
+
+    if (status == NFP_SUCCESS) {
+        nfp_log(NFP_DBG3, "fsl_check_complete: device started");
+    } else if (status == NFP_ESTARTING) {
+        nfp_log(NFP_DBG3, "fsl_check_complete: device not started yet");
+    } else {
+        nfp_log(NFP_DBG1, "fsl_check_complete: device check failed with code: 0x%x", status);
+    }
+}
+
+/**
+ * Handles an interrupt from the FSL device.
+ *
+ * @param ctx device context (always the device itself).
+ * @param handled set non-zero by this routine if interrupt considered handled
+ * @returns NFP_SUCCESS if successful, other value if error.
+ */
+static nfp_err fsl_isr(void *ctx, int *handled) {
+    nfp_cdev *cdev;
+    nfp_err ne;
+    uint32_t doorbell_rd, doorbell_wr, doorbell_cs;
+#ifdef FSL_AGRESSIVE_CHECKING
+    int x_wr = 0, x_rd = 0, x_cs = 0;
+#endif
+
+    nfp_log(NFP_DBG4, "%s: entered", __func__);
+    
+    /* mark not yet handled */
+
+    *handled = 0;
+
+    /* check for device */
+
+    cdev = (nfp_cdev *)ctx;
+    if ((ne = fsl_created(cdev)) != NFP_SUCCESS) {
+        nfp_log(NFP_DBG1, "%s: error: interrupt not handled", __func__);
+        return ne;
+    }
+
+    ++cdev->stats.isr;
+
+    doorbell_wr = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_STATUS);
+    doorbell_wr = FROM_LE32_MEM(&doorbell_wr);
+    doorbell_rd = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_STATUS);
+    doorbell_rd = FROM_LE32_MEM(&doorbell_rd);
+    doorbell_cs = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_CS_STATUS);
+    doorbell_cs = FROM_LE32_MEM(&doorbell_cs);
+    nfp_log(NFP_DBG3, "%s: cs:= %x,rd:=%x,wr:=%x", __func__,doorbell_cs,doorbell_rd,doorbell_wr);
+
+        
+    while (doorbell_rd || doorbell_wr || doorbell_cs ) {
+        /* prevent any illegal combination of set bits from triggering processing. Note that if anyone of these registers
+         * have an incorrect bit set, it would prevent the other operations from being processed since we return from the ISR,
+         * even if they have legal values. This is an unlikely scenario since these registers are written either to 0 or one
+         * of the legal values by the software on the card.*/
+        if ((doorbell_cs) && ((doorbell_cs & ~NFAST_INT_DEVICE_CHECK_OK) && (doorbell_cs & ~NFAST_INT_DEVICE_CHECK_FAILED))){
+            nfp_log(NFP_DBG1, "fsl_isr: illegal bits in doorbell_cs %x",doorbell_cs);
+            *handled = 1;
+            /* clear the register*/
+            fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_CS_STATUS, NFAST_INT_DEVICE_CLR);
+            return 0;
+        } 
+        if ((doorbell_rd) && ((doorbell_rd & ~NFAST_INT_DEVICE_READ_OK) && (doorbell_rd & ~NFAST_INT_DEVICE_READ_FAILED))){
+            nfp_log(NFP_DBG1, "fsl_isr: illegal bits in doorbell_rd %x",doorbell_rd);
+            *handled = 1;
+            /* clear the register*/
+            fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_STATUS, NFAST_INT_DEVICE_CLR);
+            return 0;
+        }
+        if ((doorbell_wr) && ((doorbell_wr & ~NFAST_INT_DEVICE_WRITE_OK) && (doorbell_wr & ~NFAST_INT_DEVICE_WRITE_FAILED))){
+            nfp_log(NFP_DBG1, "fsl_isr: illegal bits in doorbell_wr %x",doorbell_wr);
+            /* clear the register*/
+            fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_STATUS, NFAST_INT_DEVICE_CLR);
+            *handled = 1;
+            return 0;
+        }         
+        
+        /* service interrupts. if we made it here, the doorbell registers are all valid, so no need to check
+         * for their validity anymore. */
+
+        if (doorbell_wr) {
+            fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_STATUS, NFAST_INT_DEVICE_CLR);
+            cdev->stats.isr_write++;
+            nfp_write_complete(cdev->dev, doorbell_wr & NFAST_INT_DEVICE_WRITE_OK ? 1 : 0);
+            nfp_log(NFP_DBG3, "fsl_isr: acknowledging write interrupt: ok = %d", doorbell_wr & NFAST_INT_DEVICE_WRITE_OK ? 1 : 0);
+
+#ifdef FSL_AGRESSIVE_CHECKING
+            if (fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_STATUS) != NFAST_INT_DEVICE_CLR) {
+                nfp_log(NFP_DBG1, "fsl_isr: failed to clear doorbell write status");
+            } ++x_wr;
+#endif
+        }
+
+        if (doorbell_rd) {
+            fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_STATUS, NFAST_INT_DEVICE_CLR);
+            cdev->stats.isr_read++;
+            nfp_read_complete(cdev->dev, doorbell_rd & NFAST_INT_DEVICE_READ_OK ? 1 : 0);
+            nfp_log(NFP_DBG3, "fsl_isr: acknowledging read interrupt: ok = %d", doorbell_rd & NFAST_INT_DEVICE_READ_OK ? 1 : 0);
+
+#ifdef FSL_AGRESSIVE_CHECKING
+            if (fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_STATUS) != NFAST_INT_DEVICE_CLR) {
+                nfp_log(NFP_DBG1, "fsl_isr: failed to clear doorbell read status");
+            } ++x_rd;
+#endif
+        }
+        /* the doorbell_cs is being phased out in favor of polling since there were issues caused by this interrupt being issued from
+         * the card on its own when the driver was not even present. To maintain backwards compatibility, this code is being kept, but
+         * might be removed in the future.*/
+        nfp_log(NFP_DBG3, "fsl_isr: doorbell_cs is: %x",doorbell_cs);
+        if (doorbell_cs) {
+            fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_CS_STATUS, NFAST_INT_DEVICE_CLR);
+            fsl_check_complete(cdev, doorbell_cs & NFAST_INT_DEVICE_CHECK_OK ? NFP_SUCCESS : NFP_ESTARTING);
+            nfp_log(NFP_DBG3, "fsl_isr: acknowledging check interrupt: status:0x%x", doorbell_cs & NFAST_INT_DEVICE_CHECK_OK ? NFP_SUCCESS : NFP_ESTARTING);
+ 
+#ifdef FSL_AGRESSIVE_CHECKING
+            if (fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_CS_STATUS) != NFAST_INT_DEVICE_CLR) {
+                nfp_log(NFP_DBG1, "fsl_isr: warning: failed to clear doorbell check status");
+            } ++x_cs;
+#endif
+        }
+
+        doorbell_wr = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_STATUS);
+        doorbell_wr = FROM_LE32_MEM(&doorbell_wr);
+        doorbell_rd = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_STATUS);
+        doorbell_rd = FROM_LE32_MEM(&doorbell_rd);
+        doorbell_cs = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_CS_STATUS);
+        doorbell_cs = FROM_LE32_MEM(&doorbell_cs);
+        
+        nfp_log(NFP_DBG3, "fsl_isr: cs status in isr is: %x",doorbell_cs);
+    }
+
+    /* always report the interrupt as handled */
+
+    *handled = 1;
+#ifdef FSL_AGRESSIVE_CHECKING
+    if (x_wr + x_rd + x_cs == 0) {
+        nfp_log(NFP_DBG2, "fsl_isr: no operations handled by this ISR call");
+    } else {
+        if (x_wr + x_rd + x_cs > 1) {
+            nfp_log(NFP_DBG3, "fsl_isr: DEBUG: multiple operations handled by this ISR call: wr=%d, rd=%d, cs=%d", x_wr, x_rd, x_cs);
+        } else {
+            nfp_log(NFP_DBG3, "fsl_isr: DEBUG: one operation handled by this ISR call: wr=%d, rd=%d, cs=%d", x_wr, x_rd, x_cs);
+        }
+
+    }
+#endif
+    nfp_log(NFP_DBG3, "fsl_isr: exiting");
+
+    return 0;
+}
+
+/**
+ * Performs additional FSL-specific actions when opening a device.
+ *
+ * This routine returns an error if the device has not properly started.
+ *
+ * @param ctx device context (always the device itself).
+ * @returns NFP_SUCCESS if successful, other value if error.
+ */
+static nfp_err fsl_open(void *ctx) {
+    nfp_cdev *cdev;
+    nfp_err ne;
+	
+
+    nfp_log(NFP_DBG4, "fsl_open: entered");
+
+    /* check for device */
+
+    cdev = (nfp_cdev *) ctx;
+    if ((ne = fsl_started(cdev,NFP_WITH_LOCK)) != NFP_SUCCESS) {
+        cdev->stats.ensure_fail++;
+        nfp_log(NFP_DBG1, "%s: error: device not started", __func__);
+        return ne;
+    }
+
+    return NFP_SUCCESS;
+}
+
+/**
+ * Performs additional FSL-specific actions when closing a device.
+ *
+ * @param ctx device context (always the device itself).
+ * @returns NFP_SUCCESS if successful, other value if error.
+ */
+static nfp_err fsl_close(void *ctx) {
+    (void) ctx;
+
+    nfp_log(NFP_DBG4, "fsl_close: entered");
+
+    return NFP_SUCCESS;
+}
+
+/**
+ * Updates the device channel (not implemented).
+ *
+ * @param data data buffer.
+ * @param len length.
+ * @param ctx device context (always the device itself).
+ * @returns NFP_SUCCESS.
+ */
+static nfp_err fsl_chupdate(char *data, int len, void *ctx) {
+    (void) data; (void) len; (void) ctx;
+
+    nfp_log( NFP_DBG1, "fsl_chupdate: warning: not implemented");
+
+    return NFP_SUCCESS;
+}
+
+/**
+ * Sets control data.
+ *
+ * The device control register is writen directly. No doorbell style handshake
+ * is used.
+ *
+ * @param control control string to copy from.
+ * @param ctx device context (always the device itself).
+ * @returns NFP_SUCCESS if successful, other value if error.
+ */
+static nfp_err fsl_set_control(const nfdev_control_str *control, void *ctx) {
+    uint32_t control_data;
+    nfp_cdev *cdev;
+    nfp_err ne;
+
+    nfp_log(NFP_DBG4, "%s: entered", __func__);
+
+    /* check for device */
+
+    cdev = (nfp_cdev *) ctx;
+    if ((ne = fsl_started(cdev,NFP_WITH_LOCK)) != NFP_SUCCESS) {
+        nfp_log(NFP_DBG1, "%s: error: unable to set control", __func__);
+        return ne;
+    }
+
+    /* set control (written immediately with no explicit synchronization with the firmware)*/
+
+    TO_LE32_MEM(&control_data, control->control);
+    fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_REGISTER_CONTROL, control_data);
+
+    return NFP_SUCCESS;
+}
+
+/**
+ * Returns status data.
+ *
+ * The device status registers are read immediately. No doorbell style handshake
+ * is used. Without explicit synchronization, it is possible that an inconsistent state
+ * may be returned if the status is being updated by the firmware while simultaneously
+ * being read by the host. For example, the call could return an updated status word
+ * with a not as yet updated error string. This is likely a degenerate case.
+ *
+ * @param status string to copy into.
+ * @param ctx device context (always the device itself).
+ * @returns NFP_SUCCESS if successful, other value if error.
+ */
+static nfp_err fsl_get_status(nfdev_status_str *status, void *ctx) {
+    nfp_cdev *cdev;
+    nfp_err ne;
+    uint32_t status_data;
+    uint32_t *error = (uint32_t *) status->error;
+
+    nfp_log(NFP_DBG4, "%s: entered", __func__);
+
+    /* check for device */
+
+    cdev = (nfp_cdev *) ctx;
+    if ((ne = fsl_started(cdev,NFP_WITH_LOCK)) != NFP_SUCCESS) {
+        nfp_log(NFP_DBG1, "%s: error: unable to get status", __func__);
+        return ne;
+    }
+
+    /* get status (read immediately with no explicit synchronization with the firmware) */
+
+    status_data = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_REGISTER_STATUS);
+    status->status = FROM_LE32_MEM(&status_data);
+    error[0] = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_REGISTER_ERROR_LO);
+    error[1] = fsl_inl(cdev, cdev->active_bar, FSL_OFFSET_REGISTER_ERROR_HI);
+
+    return NFP_SUCCESS;
+}
+
+/**
+ * Initiates a device read request.
+ *
+ * @param addr 32-bit bus address used by DMA to push reply from device.
+ * @param len maximum length data to return.
+ * @param ctx device context (always the device itself).
+ * @returns NFP_SUCCESS if read initiated, NFP_ESTARTING if device not ready, or other value if error.
+ */
+static nfp_err fsl_ensure_reading(int unsigned addr, int len, void *ctx, int lock_flag) {
+    nfp_cdev *cdev;
+    uint32_t hdr[3];
+    uint32_t tmp32;
+    nfp_err ne;
+    int hdr_len;
+
+    nfp_log(NFP_DBG4, "%s: entered", __func__);
+
+    /* check for device */
+
+    cdev = (nfp_cdev *) ctx;
+	if ((ne = fsl_started(cdev, lock_flag)) != NFP_SUCCESS) {
+        cdev->stats.ensure_fail++;
+        nfp_log(NFP_DBG1, "%s: error: unable to initiate read", __func__);
+        return ne;
+    }
+
+    nfp_log( NFP_DBG3, "fsl_ensure_reading: cdev->bar[cdev->active_bar]= %x",  cdev->bar[cdev->active_bar]);
+
+    /* send read request */
+
+    if (addr) {
+        nfp_log(NFP_DBG3, "fsl_ensure_reading: requesting DMA reply to bus address %x", addr);
+        TO_LE32_MEM(&hdr[0], NFPCI_JOB_CONTROL_PCI_PUSH);
+        TO_LE32_MEM(&hdr[1], len);
+        TO_LE32_MEM(&hdr[2], addr);
+        hdr_len = 12;
+    } else {
+        TO_LE32_MEM(&hdr[0], NFPCI_JOB_CONTROL);
+        TO_LE32_MEM(&hdr[1], len);
+        hdr_len = 8;
+    }
+    if ((ne = nfp_copy_to_dev(cdev, cdev->active_bar, NFPCI_JOBS_RD_CONTROL, (char const *)hdr, hdr_len)) != NFP_SUCCESS) {
+        nfp_log(NFP_DBG1, "fsl_ensure_reading: error: nfp_copy_to_dev failed");
+        cdev->stats.ensure_fail++;
+        return ne;
+    }
+
+    /* confirm read request */
+
+    if ((ne = nfp_copy_from_dev(cdev, cdev->active_bar, NFPCI_JOBS_RD_LENGTH, (char *)hdr, 4)) != NFP_SUCCESS) {
+        nfp_log(NFP_DBG1, "fsl_ensure_reading: error: nfp_copy_from_dev failed");
+        cdev->stats.ensure_fail++;
+        return ne;
+    }
+    TO_LE32_MEM(&tmp32, len);
+    if (hdr[0] != tmp32) {
+        nfp_log(NFP_DBG1, "fsl_ensure_reading: error: expected length not written (%08x != %08x)", hdr[0], tmp32);
+        cdev->stats.ensure_fail++;
+        return NFP_EIO;
+    }
+
+    /* trigger read request */
+
+    TO_LE32_MEM(&tmp32, NFAST_INT_HOST_READ_REQUEST);
+    fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_RD_CMD, tmp32);
+
+    cdev->stats.ensure++;
+
+    nfp_log(NFP_DBG3, "fsl_ensure_reading: requesting max %d bytes", len);
+
+    return NFP_SUCCESS;
+}
+
+/**
+ * Reads a device read reply.
+ *
+ * @param block data buffer to copy into.
+ * @param len maximum length of data to copy.
+ * @param ctx device context (always the device itself).
+ * @param rcnt returned actual # of bytes copied
+ * @returns NFP_SUCCESS if read initiated, NFP_ESTARTING if device not ready, or other value if error.
+ */
+static nfp_err fsl_read(char *block, int len, void *ctx, int *rcnt) {
+    nfp_cdev *cdev;
+    nfp_err ne;
+    int cnt;
+
+    nfp_log(NFP_DBG4, "%s: entered", __func__);
+
+    *rcnt = 0;
+
+    /* check for device */
+
+    cdev = (nfp_cdev *)ctx;
+    if ((ne = fsl_started(cdev,NFP_WITH_LOCK)) != NFP_SUCCESS) {
+        cdev->stats.read_fail++;
+        nfp_log(NFP_DBG1, "%s: error: unable to complete read", __func__);
+        return ne;
+    }
+
+    /* receive reply length */
+
+    if ((ne = nfp_copy_from_dev(cdev, cdev->active_bar, NFPCI_JOBS_RD_LENGTH, (char *)&cnt, 4)) != NFP_SUCCESS) {
+        cdev->stats.read_fail++;
+        nfp_log(NFP_DBG1, "fsl_read: error: nfp_copy_from_dev failed.");
+        return ne;
+    }
+    cnt = FROM_LE32_MEM(&cnt);
+    nfp_log(NFP_DBG3, "fsl_read: cnt=%u.", cnt);
+    if (cnt < 0 || cnt > len) {
+        cdev->stats.read_fail++;
+        nfp_log(NFP_DBG1, "fsl_read: error: bad byte count (%d) from device", cnt);
+        return NFP_EIO;
+    }
+
+    /* receive data */
+
+    if ((ne = nfp_copy_to_user_from_dev(cdev, cdev->active_bar, NFPCI_JOBS_RD_DATA, block, cnt)) != NFP_SUCCESS) {
+        cdev->stats.read_fail++;
+        nfp_log(NFP_DBG1, "fsl_read: error: nfp_copy_to_user failed.");
+        return ne;
+    }
+
+    *rcnt = cnt;
+    cdev->stats.read_block++;
+    cdev->stats.read_byte += cnt;
+    nfp_log(NFP_DBG2, "fsl_read: read %d bytes (std)", cnt);
+
+    return NFP_SUCCESS;
+}
+
+/**
+ * Initiates a device write request.
+ *
+ * @param addr 32-bit bus address used by DMA to pull request to device.
+ * @param block data buffer to copy from.
+ * @param len length of data to copy.
+ * @param ctx device context (always the device itself).
+ * @returns NFP_SUCCESS if write successful, NFP_ESTARTING if device not ready, or other value if error.
+ */
+static nfp_err fsl_write(int unsigned addr, char const *block, int len, void *ctx) {
+    nfp_cdev *cdev;
+    unsigned int hdr[3];
+    nfp_err ne;
+    unsigned int tmp32;
+
+    nfp_log(NFP_DBG4, "%s: entered", __func__);
+
+    /* check for device */
+
+    cdev = (nfp_cdev *) ctx;
+    if ((ne = fsl_started(cdev,NFP_WITH_LOCK)) != NFP_SUCCESS) {
+        cdev->stats.write_fail++;
+        nfp_log(NFP_DBG1, "%s: error: unable to initiate write", __func__);
+        return ne;
+    }
+
+    if (0 == addr) {
+        /* std write */
+
+        nfp_log(NFP_DBG3, "fsl_write: cdev->bar[cdev->active_bar]= %x", cdev->bar[cdev->active_bar]);
+        nfp_log(NFP_DBG3, "fsl_write: block len %d", len);
+
+        /* send write request */
+
+        if ((ne = nfp_copy_from_user_to_dev(cdev, cdev->active_bar, NFPCI_JOBS_WR_DATA, block, len)) != NFP_SUCCESS) {
+            cdev->stats.write_fail++;
+            nfp_log(NFP_DBG1, "fsl_write: error: nfp_copy_from_user_to_dev failed");
+            return ne;
+        }
+
+        TO_LE32_MEM(&hdr[0], NFPCI_JOB_CONTROL);
+        TO_LE32_MEM(&hdr[1], len);
+        if ((ne = nfp_copy_to_dev(cdev, cdev->active_bar, NFPCI_JOBS_WR_CONTROL, (char const *)hdr, 8)) != NFP_SUCCESS) {
+            cdev->stats.write_fail++;
+            nfp_log(NFP_DBG1, "fsl_write: error: nfp_copy_to_dev failed");
+            return ne;
+        }
+
+        /* confirm write request */
+
+        if ((ne = nfp_copy_from_dev(cdev, cdev->active_bar, NFPCI_JOBS_WR_LENGTH, (char *)hdr, 4)) != NFP_SUCCESS) {
+            cdev->stats.write_fail++;
+            nfp_log(NFP_DBG1, "fsl_write: nfp_copy_from_dev failed");
+            return ne;
+        }
+
+        TO_LE32_MEM(&tmp32, len);
+        if (hdr[0] != tmp32) {
+            cdev->stats.write_fail++;
+            nfp_log(NFP_DBG1, "fsl_write: length not written (%08x != %08x)", hdr[0], tmp32);
+            return NFP_EIO;
+        }
+    } else {
+        /* dma write */
+
+        nfp_log(NFP_DBG3, "fsl_write: cdev->bar[cdev->active_bar]= %x", cdev->bar[cdev->active_bar]);
+        nfp_log(NFP_DBG3, "fsl_write: block len %d", len);
+        nfp_log(NFP_DBG3, "fsl_write: pull from 0x%016x using DMA", addr);
+
+        /* submit write request */
+
+        TO_LE32_MEM(&hdr[0], NFPCI_JOB_CONTROL_PCI_PULL);
+        TO_LE32_MEM(&hdr[1], len);
+        TO_LE32_MEM(&hdr[2], addr);
+        if ((ne = nfp_copy_to_dev(cdev, cdev->active_bar, NFPCI_JOBS_WR_CONTROL, (char const *)hdr, 12)) != NFP_SUCCESS) {
+            cdev->stats.write_fail++;
+            nfp_log(NFP_DBG1, "fsl_write: nfp_copy_to_dev failed");
+            return ne;
+        }
+
+        /* confirm request */
+
+        if ((ne = nfp_copy_from_dev(cdev, cdev->active_bar, NFPCI_JOBS_WR_LENGTH, (char *)hdr, 4)) != NFP_SUCCESS) {
+            cdev->stats.write_fail++;
+            nfp_log(NFP_DBG1, "fsl_write: nfp_copy_from_dev failed");
+            return ne;
+        }
+
+        TO_LE32_MEM(&tmp32, len);
+        if (hdr[0] != tmp32) {
+            cdev->stats.write_fail++;
+            nfp_log(NFP_DBG1, "fsl_write: length not written (%08x != %08x)", tmp32, hdr[0]);
+            return NFP_EIO;
+        }
+    }
+
+    /* trigger write */
+
+    TO_LE32_MEM(&tmp32, NFAST_INT_HOST_WRITE_REQUEST);
+    fsl_outl(cdev, cdev->active_bar, FSL_OFFSET_DOORBELL_WR_CMD, tmp32);
+
+    cdev->stats.write_block++;
+    cdev->stats.write_byte += len;
+
+    nfp_log(NFP_DBG3, "fsl_write: done");
+    return NFP_SUCCESS;
+}
+
+/**
+ * To show hot reset is supported on device
+ */
+static nfp_err fsl_hot_reset(void *ctx) {
+    (void) ctx;
+
+    nfp_log(NFP_DBG4, "fsl_hot_reset: entered");
+
+    return NFP_SUCCESS;
+}
+
+/** FSL c293 device configuration. */
+const nfpcmd_dev fsl_c293_cmddev = { "nCipher Next Gen PCI",
+        PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_FREESCALE_C293,
+        PCI_VENDOR_ID_NCIPHER, PCI_SUBSYSTEM_ID_NFAST_REV1,
+        { 0, FSL_MEMSIZE, 0, 0, 0, 0 },
+        NFP_CMD_FLG_NEED_MSI, NFDEV_IF_PCI_PUSH, fsl_create, fsl_destroy,
+        fsl_started, fsl_stopped, fsl_open, fsl_close, fsl_isr, fsl_write, fsl_read,
+        fsl_chupdate, fsl_ensure_reading, 0, 0, 0, 0 };
+
+/** FSL Hammerhead p3041 device configuration. */
+const nfpcmd_dev fsl_p3041_cmddev = { "nCipher Next Gen PCI",
+        PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_FREESCALE_P3041,
+        PCI_VENDOR_ID_NCIPHER, PCI_SUBSYSTEM_ID_NFAST_REV1,
+        { 0, FSL_MEMSIZE, 0, 0, 0, 0 },
+        NFP_CMD_FLG_NEED_MSI, NFDEV_IF_PCI_PULL, fsl_create, fsl_destroy,
+        fsl_started, fsl_stopped, fsl_open, fsl_close, fsl_isr, fsl_write, fsl_read,
+        fsl_chupdate, fsl_ensure_reading, 0, fsl_set_control, fsl_get_status, 0 };
+
+/** FSL Sawshark p3041 device configuration. */
+#if defined(__unix__)
+const nfpcmd_dev fsl_t1022_cmddev = { "nCipher Next Gen PCI",
+        PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_FREESCALE_T1022,
+        PCI_VENDOR_ID_NCIPHER, PCI_SUBSYSTEM_ID_NFAST_REV1,
+        { 0, FSL_MEMSIZE, 0, 0, 0, 0 },
+        NFP_CMD_FLG_NEED_MSI, NFDEV_IF_PCI_PULL, fsl_create, fsl_destroy,
+        fsl_started, fsl_stopped, fsl_open, fsl_close, fsl_isr, fsl_write, fsl_read,
+        fsl_chupdate, fsl_ensure_reading, 0, fsl_set_control, fsl_get_status, fsl_hot_reset };
+#elif defined(WINVER)
+/* NOTE setting FSL_MEMSIZE for both Element [0] and Element [1] in order
+to accomodate scenarios when both Bar0 and Bar1 Mem Resources are Available
+*/
+const nfpcmd_dev fsl_t1022_cmddev = { "nCipher Next Gen PCI",
+        PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_FREESCALE_T1022,
+        PCI_VENDOR_ID_NCIPHER, PCI_SUBSYSTEM_ID_NFAST_REV1,
+        { FSL_MEMSIZE, FSL_MEMSIZE, 0, 0, 0, 0 },
+        NFP_CMD_FLG_NEED_MSI, NFDEV_IF_PCI_PULL, fsl_create, fsl_destroy,
+        fsl_started, fsl_stopped, fsl_open, fsl_close, fsl_isr, fsl_write, fsl_read,
+        fsl_chupdate, fsl_ensure_reading, 0, fsl_set_control, fsl_get_status, fsl_hot_reset };
+#endif
+/* end of file */
diff --git drivers/misc/nshield/fsl.h drivers/misc/nshield/fsl.h
new file mode 100644
index 000000000000..b8365b18f3b2
--- /dev/null
+++ drivers/misc/nshield/fsl.h
@@ -0,0 +1,139 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*************************************************************************
+ *
+ * Project:      NGSolo
+ *
+ *-------------------------------------------------------------------------
+ *
+ *-------------------------------------------------------------------------
+ *
+ * Module Description:
+ *
+ *    This file declares FSL device configurations.
+ *
+ *-------------------------------------------------------------------------
+ *
+ * Notes:
+ *
+ *    This file is duplicated in the host and card repositories. It is
+ *    essential that both copies match!
+ *
+ *************************************************************************/
+
+/** @file
+
+  * (c) nCipher Security Limited 2019
+
+  * Declares FSL device configurations.
+  */
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+#ifndef FSL_H
+#define FSL_H
+
+#include "nfpci.h"
+
+/* PCI FSL definitions */
+
+#ifndef PCI_VENDOR_ID_FREESCALE
+#define PCI_VENDOR_ID_FREESCALE           0x1957
+#endif
+
+#ifndef PCI_DEVICE_ID_FREESCALE_C293
+#define PCI_DEVICE_ID_FREESCALE_C293      0x0800
+#endif
+
+#ifndef PCI_DEVICE_ID_FREESCALE_P3041
+#define PCI_DEVICE_ID_FREESCALE_P3041     0x041e
+#endif
+
+#ifndef PCI_DEVICE_ID_FREESCALE_T1022
+#define PCI_DEVICE_ID_FREESCALE_T1022     0x082c
+#endif
+
+#ifndef PCI_VENDOR_ID_NCIPHER
+#define PCI_VENDOR_ID_NCIPHER             0x0100
+#endif
+
+#ifndef PCI_SUBSYSTEM_ID_NFAST_REV1
+#define PCI_SUBSYSTEM_ID_NFAST_REV1       0x0100
+#endif
+
+#define FSL_CFG_SEC_CMD_STATUS            0x4C
+#define FSL_CFG_CMD_MASTER                0x10
+
+#define FSL_MEMBAR                        1
+
+/* NFAST extended PCI register definitions */
+
+#define NFPCI_OFFSET_JOBS_DS              0x00020000
+
+/* Interrupts from device to host */
+
+#define NFAST_INT_DEVICE_CLR              0x00000000
+#define NFAST_INT_DEVICE_CHECK_OK         0x00000100
+#define NFAST_INT_DEVICE_CHECK_FAILED     0x00000200
+#define NFAST_INT_DEVICE_POLL             0x00000300
+#define NFAST_INT_DEVICE_PCI_DOWN         0x00000400
+
+/* Interrupts from host to device */
+
+#define NFAST_INT_HOST_CLR                0x00000000
+
+/* PCI FSL register definitions */
+
+#define FSL_LENGTH                        NFPCI_RAM_MINSIZE_JOBS
+#define FSL_MEMSIZE                       NFPCI_RAM_MINSIZE_KERN
+
+#define FSL_DOORBELL_LOCATION             (FSL_MEMSIZE - 0x100)
+
+#define FSL_OFFSET_DOORBELL_RD_CMD        0x00u
+#define FSL_OFFSET_DOORBELL_WR_CMD        0x04u
+#define FSL_OFFSET_DOORBELL_RD_STATUS     0x08u
+#define FSL_OFFSET_DOORBELL_WR_STATUS     0x0Cu
+#define FSL_OFFSET_DOORBELL_CS_STATUS     0x10u
+
+#define FSL_OFFSET_REGISTER_CONTROL       0x20u
+#define FSL_OFFSET_REGISTER_STATUS        0x24u
+#define FSL_OFFSET_REGISTER_ERROR_LO      0x28u
+#define FSL_OFFSET_REGISTER_ERROR_HI      0x2Cu
+#define FSL_OFFSET_DOORBELL_POLLING       0x30u
+
+#define FSL_MAGIC                         0x12345678u
+
+/** Monitor firmware supports MOI control and error reporting */
+#define NFDEV_STATUS_MONITOR_MOI          0x0001
+
+/** Application firmware supports MOI control and error reporting */
+#define NFDEV_STATUS_APPLICATION_MOI      0x0002
+
+/** Application firmware running and supports error reporting */
+#define NFDEV_STATUS_APPLICATION_RUNNING  0x0004
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/* end of file */
diff --git drivers/misc/nshield/fsl_osif.h drivers/misc/nshield/fsl_osif.h
new file mode 100644
index 000000000000..baa62aa3131d
--- /dev/null
+++ drivers/misc/nshield/fsl_osif.h
@@ -0,0 +1,109 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+ fsl_osif.h: nCipher PCI HSM FSL command operating system interface
+
+ (C) Copyright nCipher Security Limited 2019 All rights reserved
+
+ */
+
+#ifndef FSL_OSIF_H
+#define FSL_OSIF_H
+
+#include "fsl.h"
+#include "nfp_error.h"
+#include "nfp_hostif.h"
+
+#ifdef __linux
+
+#include <asm/io.h>
+
+/**
+ * Writes a 32 bit word across PCI to the FSL card.
+ *
+ * @param cdev command device.
+ * @param bar base address region id.
+ * @param offset offset in bytes from base address.
+ * @param value 32 bit value being written.
+ */
+static inline void fsl_outl(nfp_cdev *cdev, int bar, int offset, unsigned int value) {
+    iowrite32(value, cdev->bar[bar] + FSL_DOORBELL_LOCATION + offset);
+}
+
+/**
+ * Reads a 32 bit word across PCI from the FSL card.
+ *
+ * @param cdev command device.
+ * @param bar base address region id.
+ * @param offset offset in bytes from base address.
+ * @returns 32 bit value.
+ */
+static inline uint32_t fsl_inl(nfp_cdev *cdev, int bar, int offset) {
+    return ioread32(cdev->bar[bar] + FSL_DOORBELL_LOCATION + offset);
+}
+
+#elif defined(WINVER)
+
+#include "nfp_osif.h"
+
+/**
+ * Writes a 32 bit word across PCI to the FSL card.
+ *
+ * @param cdev command device.
+ * @param bar base address region id.
+ * @param offset offset in bytes from base address.
+ * @param value 32 bit value being written.
+ */
+static void fsl_outl(nfp_cdev *cdev, int bar, int offset, unsigned int value) {
+    nfp_err ne;
+    char *data;
+
+    data = (char *) &value;
+    ne = nfp_copy_to_dev(cdev, bar, FSL_DOORBELL_LOCATION + offset, (char *) &value, 4);
+    if (ne) {
+        nfp_log(NFP_DBG1, "fsl_outl: nfp_copy_to_dev failed");
+    }
+}
+
+/**
+ * Reads a 32 bit word across PCI from the FSL card.
+ *
+ * @param cdev command device.
+ * @param bar base address region id.
+ * @param offset offset in bytes from base address.
+ * @returns 32 bit value.
+ */
+static uint32_t fsl_inl(nfp_cdev *cdev, int bar, int offset) {
+    nfp_err ne;
+    unsigned int value;
+
+    ne = nfp_copy_from_dev(cdev, bar, FSL_DOORBELL_LOCATION + offset, (char *) &value, 4);
+    if (ne) {
+        nfp_log(NFP_DBG1, "fsl_inl: nfp_copy_to_dev failed");
+        value = 0;
+    }
+    return value;
+}
+
+#else
+#error fsl_osif implementation not defined!
+#endif
+
+#endif
+
+/* end of file */
diff --git drivers/misc/nshield/hostif.c drivers/misc/nshield/hostif.c
new file mode 100644
index 000000000000..fb7301347fb2
--- /dev/null
+++ drivers/misc/nshield/hostif.c
@@ -0,0 +1,1737 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/** @file
+ *
+ hostif.c: nCipher PCI HSM linux host interface
+
+ * (c) nCipher Security Limited 2019
+
+ history
+
+ 09/10/2001 jsh  Original
+ * This driver is intended to support version 2.6.27 and newer Linux kernels.
+ */
+
+/**
+ * @todo add nfp_mgr_wait_until_all_removed
+ * @todo refine mgr_wait_until_all_probed
+ * @todo to complete multicard testing and restarting
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include "nfp_common.h"
+#include "nfp_error.h"
+#include "nfp_fixup.h"
+#include "nfp_hostif.h"
+#include "nfp_dev.h"
+#include "nfp_osif.h"
+#include "nfp_cmd.h"
+#include "devinit.h"
+#include <linux/bitops.h>
+#include "nfpci.h"
+
+#include "i21555.h"
+#include "fsl.h"
+#include "fsl_osif.h"
+
+#ifdef smp_mb__before_atomic
+#define NF_smp_mb__before_atomic smp_mb__before_atomic
+#else
+#define NF_smp_mb__before_atomic smp_mb__before_clear_bit
+#endif
+
+/* device list --------------------------------------------------- */
+
+nfp_dev *nfp_dev_list[NFP_MAXDEV];
+static int nfp_num_devices = 0;
+
+static struct class *nfp_class;
+/*! @} */
+
+/**
+ * @addtogroup modparams
+ * Module structures.
+ * @{
+ */
+
+/**
+ * NFP module debug parameter.
+ *
+ * This value can be overridden when the module is loaded, for example:
+ *
+ *   insmod nfp.ko nfp_debug=<n>
+ *
+ * where <n> = 1 through 4 inclusive
+ */
+int nfp_debug = 1;
+
+/**
+ * NFP module interface version parameter.
+ *
+ * This value can be overridden when the module is loaded, for example:
+ *
+ *   insmod nfp.ko nfp_ifvers=<n>
+ *
+ * where n = 0 allows any supported interface,
+ *       n > 0 allows only interface versions <= n.
+ * See nfdev-common.h for a list of supported interface versions.
+ * Specific card models may not support all interface versions.
+ */
+int nfp_ifvers = 0;
+
+NFP_MODULE_PREAMBLE
+NFP_MODULE_LICENSE
+
+/** @} */
+
+/**
+ * @addtogroup fops
+ * NFP character device file operations.
+ * @{
+ */
+
+
+static void start_rd_timer(nfp_dev *ndev) {
+  /* setup timeout timer */
+#if defined(from_timer)
+  mod_timer(&ndev->rd_timer, jiffies + (NFP_TIMEOUT_SEC * HZ));
+#else
+  ndev->rd_timer.expires = jiffies + (NFP_TIMEOUT_SEC * HZ);
+  add_timer(&ndev->rd_timer);
+#endif
+}
+
+/*
+ * Gets the hot reset state
+ *
+ * @param cmddev command device to check that hot reset is supported first
+ * @param pcidev pci_dev struct of an NFP device.
+ * @param int hr_status is set to 1 if device is in hot reset state
+ * @returns 0 if successful.
+ */
+static int nfp_hotreset_state(const nfpcmd_dev *const cmddev, const struct pci_dev *const pcidev, int *hr_status) {
+    int err = -EIO;
+    struct pci_bus* pcibus;
+    struct pci_dev* pci_bridge_dev;
+    u16 bridge_control_reg;
+ 
+    *hr_status = 0;
+
+    nfp_log(NFP_DBG4, "nfp_hotreset_state: entered");
+    if (cmddev == NULL) {
+        nfp_log(NFP_DBG4, "nfp_hotreset_state: cmddev was NULL.");
+        return -ENODEV;
+    }
+
+    if (pcidev == NULL) {
+        nfp_log(NFP_DBG4, "nfp_hotreset_state: pcidev was NULL.");
+        return -ENODEV;
+    }
+
+    if (!cmddev->hotreset) {
+      nfp_log(NFP_DBG2, "nfp_hotreset_state: %s: hotreset not supported for this device: ignored", pci_name(pcidev));
+      return -EINVAL;
+    }
+
+    if (pcidev->bus == NULL) {
+        nfp_log(NFP_DBG4, "nfp_hotreset_state: %s: pcidev->bus was NULL.", pci_name(pcidev));
+        return -ENODEV;
+    }
+    pcibus = pcidev->bus;
+
+    if (pcibus->self == NULL) {
+        nfp_log(NFP_DBG4, "nfp_hotreset_state: %s: virtual pci_bridge_dev was NULL.", pci_name(pcidev));
+        return -ENODEV;
+    }
+    pci_bridge_dev = pcibus->self;
+
+    /* Check whether the device is in hot reset mode */
+    err = pci_read_config_word(pci_bridge_dev, PCI_BRIDGE_CONTROL, &bridge_control_reg);
+    if (err) {
+        nfp_log(NFP_DBG1, "nfp_hotreset_state: %s: Failed to read pci bridge control %d", pci_name(pcidev) ,err);
+        return -EIO;
+    }
+
+    nfp_log(NFP_DBG4, "nfp_hotreset_state: %s: PCI device bridge_control_reg %02x ", pci_name(pcidev), bridge_control_reg);
+    if ((bridge_control_reg & PCI_BRIDGE_CTL_BUS_RESET) == PCI_BRIDGE_CTL_BUS_RESET) {
+      nfp_log(NFP_DBG4, "nfp_hotreset_state: PCI device %s is in hot reset", pci_name(pcidev));
+      *hr_status = 1;
+    }
+    else
+      nfp_log(NFP_DBG4, "nfp_hotreset_state: PCI device %s is NOT in hot reset mode", pci_name(pcidev));
+
+    nfp_log(NFP_DBG4,"nfp_hotreset_state: %s: left", pci_name(pcidev));
+    return 0;
+}
+
+/**
+ * Polls an NFP device.
+ *
+ * The kernel calls this function when a user tries to poll an NFP device. The function
+ * returns a bit mask which indicates if the device is immediately readable or writable.
+ * A readable device will set (POLLIN | POLLRDNORM). A writable device will set (POLLOUT | POLLWRNORM).
+ *
+ * @param filep device file pointer.
+ * @param wait  poll table pointer.
+ * @returns mask indicating if readable and/or writable.
+ */
+static unsigned int nfp_poll(struct file *file, poll_table *wait) {
+    struct nfp_dev *ndev;
+    unsigned int mask = 0;
+    int minor;
+
+    if (file == NULL) {
+        nfp_log(NFP_DBG1, "nfp_poll: pointer to file was NULL.");
+        return POLLERR;
+    }
+
+    minor = MINOR( INODE_FROM_FILE( file )->i_rdev );
+  
+    nfp_log(NFP_DBG4, "nfp_poll: entered");
+  
+    if (minor>=NFP_MAXDEV) {
+      nfp_log(NFP_DBG1, "nfp_poll: minor: %d out of range:  %d", minor, NFP_MAXDEV);
+      return -ENODEV;
+    }
+  
+    /* find ndev from minor */
+
+    ndev = nfp_dev_list[ minor ];
+    if (!ndev) {
+        nfp_log(NFP_DBG1, "nfp_poll: cannot find dev %d. no NFP device associated with this file", minor);
+        return -ENODEV;
+    }
+
+    poll_wait(file, &ndev->wr_queue, wait);
+    poll_wait(file, &ndev->rd_queue, wait);
+
+    if (test_bit(0, &ndev->wr_ready)) mask |= POLLOUT | POLLWRNORM; /* writeable */
+    if (test_bit(0, &ndev->rd_ready)) mask |= POLLIN | POLLRDNORM; /* readable */
+
+    nfp_log(NFP_DBG3, "nfp_poll: %s: device is %swritable, %sreadable",
+            pci_name(ndev->pcidev), mask & POLLOUT ? "" : "not ", mask & POLLIN ? "" : "not ");
+
+    return mask;
+}
+
+void nfp_write_complete(nfp_dev *ndev, int ok) {
+    nfp_log(NFP_DBG4, "nfp_write_complete: entered");
+
+    if (ndev == NULL) {
+        nfp_log(NFP_DBG1, "nfp_write_complete: pointer to ndev was NULL.");
+        return;
+    }
+
+    /* could be executed simultaneously by more than one thread -
+     * e.g. from the write isr and from the nfp_write/timeout
+     * we don't want that to happen. */
+    if (test_and_set_bit(CMPLT_BIT, &ndev->wr_outstanding))
+    {
+      return;
+    }
+
+    if (!test_bit(WAIT_BIT, &ndev->wr_outstanding)) {
+        /* we can only get here if the write has already been completed */
+        nfp_log(NFP_DBG1, "nfp_write_complete: %s: no write outstanding to complete; ignoring completion", pci_name(ndev->pcidev));
+        clear_bit(CMPLT_BIT, &ndev->wr_outstanding);
+        return;
+    }
+
+    /* complete write by waking waiting processes */
+    ndev->wr_ok = ok;
+
+    nfp_log(NFP_DBG3, "nfp_write_complete: %s: write completed %s okay", pci_name(ndev->pcidev), ok ? "" : "not ");
+
+    NF_smp_mb__before_atomic();
+    clear_bit(CMPLT_BIT, &ndev->wr_outstanding);
+    clear_bit(WAIT_BIT, &ndev->wr_outstanding);
+
+    /* wake up anyone waiting */
+
+    nfp_wake_up_all(&ndev->wr_queue);
+}
+#define CREATE_TRACE_POINTS
+
+#include "nfp_tracepoint.h"
+/**
+ * Writes to an NFP device.
+ *
+ * Data in the user space buffer is written to the NFP device. Any
+ * previous data is overwritten. An error is returned if not all
+ * bytes are written from the user space buffer.
+ *
+ * @param file  device file pointer.
+ * @param buf   pointer to a user space buffer.
+ * @param count size of user space buffer.
+ * @param off   offset position (ignored).
+ * @returns actual number of bytes written or a negative value if an error occurred.
+ */
+static ssize_t nfp_write(struct file *file, char const __user *buf, size_t count, loff_t *off) {
+    nfp_dev *ndev;
+    unsigned int addr;
+    int nbytes;
+    int minor;
+    nfp_err ne;
+    (void) off;
+
+    nfp_log(NFP_DBG4, "nfp_write: entered");
+    if (file == NULL) {
+        nfp_log(NFP_DBG1, "nfp_write: pointer to file was NULL.");
+        return -ENODEV;
+    }
+    trace_nfp_write(count);
+
+    /* find ndev from minor */
+
+    minor = MINOR( INODE_FROM_FILE( file )->i_rdev );
+    if (minor>=NFP_MAXDEV) {
+        nfp_log(NFP_DBG1, "nfp_write: minor: %d out of range:  %d", minor, NFP_MAXDEV);
+        return -ENODEV;
+    }
+  
+    ndev = nfp_dev_list[ minor ];
+    if (!ndev) {
+      nfp_log(NFP_DBG1, "nfp_write: cannot find dev %d.", minor);
+      return -ENODEV;
+    }
+
+    /* check max length requested */
+
+    if (count <= 0 || NFP_WRITE_MAX < count) {
+        nfp_log(NFP_DBG1, "nfp_write: %s: invalid requested write length %lu", pci_name(ndev->pcidev) , count);
+        return -EINVAL;
+    }
+
+    /* check if called before ready */
+
+    if (!test_and_clear_bit(0, &ndev->wr_ready)) {
+        nfp_log(NFP_DBG1, "nfp_write: %s: write called when not ready.", pci_name(ndev->pcidev));
+        return -ENXIO;
+    }
+    set_bit(WAIT_BIT, &ndev->wr_outstanding);
+
+    nfp_log(NFP_DBG3, "nfp_write: %s: writing %d bytes", pci_name(ndev->pcidev), count);
+
+    addr = 0;
+    if (ndev->ifvers >= NFDEV_IF_PCI_PULL) {
+        nfp_log(NFP_DBG3, "nfp_write: %s:  copying %lu bytes to dma buffer", pci_name(ndev->pcidev), count);
+        addr = ndev->write_dma;
+        TO_LE32_MEM(&nbytes, count);
+        *(unsigned int *) (ndev->write_buf + NFP_DMA_NBYTES_OFFSET) = nbytes;
+        if (0 != copy_from_user(ndev->write_buf + NFP_DMA_ADDRESS_OFFSET, buf, count)) {
+            clear_bit(WAIT_BIT, &ndev->wr_outstanding);
+            set_bit(0, &ndev->wr_ready);
+            nfp_log(NFP_DBG1, "nfp_write: %s:  copy from user space failed", pci_name(ndev->pcidev));
+            return -EIO;
+        }
+    }
+
+    ne = ndev->cmddev->write_block(addr, buf, count, ndev->common.cmdctx);
+    if (ne != NFP_SUCCESS) {
+        nfp_write_complete(ndev, 0);
+        if (ne != NFP_ESTARTING) {
+            nfp_log(NFP_DBG1,"nfp_write: %s: write_block failed", pci_name(ndev->pcidev));
+        }
+    }
+
+    while (test_bit(WAIT_BIT, &ndev->wr_outstanding)) {
+        if (!wait_event_timeout(ndev->wr_queue, test_bit(WAIT_BIT, &ndev->wr_outstanding) == 0, NFP_TIMEOUT)) {
+            nfp_write_complete(ndev, 0);
+            set_bit(0, &ndev->wr_ready);
+            nfp_log( NFP_DBG1, "nfp_write: %s: module timed out", pci_name(ndev->pcidev));
+            return -ENXIO;
+        }
+        if (test_bit(WAIT_BIT, &ndev->wr_outstanding)) {
+            nfp_log( NFP_DBG1, "nfp_write: %s: handling spurious wake-up", pci_name(ndev->pcidev));
+        }
+    }
+    set_bit(0, &ndev->wr_ready);
+ 
+    nfp_log( NFP_DBG2, "nfp_write: %s: returning %d.", pci_name(ndev->pcidev), ndev->wr_ok?count:-EIO );
+
+    if (!ndev->wr_ok) {
+        nfp_log(NFP_DBG1, "nfp_write: %s: device write failed", pci_name(ndev->pcidev));
+        return -EIO;
+    }
+
+    nfp_log(NFP_DBG2, "nfp_write: %s: wrote %d bytes (%s)", pci_name(ndev->pcidev), count, ndev->ifvers >= NFDEV_IF_PCI_PULL? "dma" : "std");
+    return count;
+}
+
+void nfp_read_complete(nfp_dev *ndev, int ok) {
+    nfp_log(NFP_DBG4, "nfp_read_complete: entered");
+
+    if (ndev == NULL) {
+        nfp_log(NFP_DBG1, "nfp_read_complete: pointer to ndev was NULL.");
+        return;
+    }
+
+    /* could be executed simultaneously by more than one thread -
+     * e.g. from the read isr and from the timeout
+     * we don't want that to happen. */
+    if (test_and_set_bit(CMPLT_BIT, &ndev->rd_outstanding))
+    {
+      return;
+    }
+
+    if (!test_bit(WAIT_BIT, &ndev->rd_outstanding)) {
+        /* we can only get here if the read has already been completed
+           and no new ENSUREREADING request has been received since */
+        nfp_log(NFP_DBG1, "nfp_read_complete: %s: no read outstanding to complete; ignoring completion", pci_name(ndev->pcidev));
+        clear_bit(CMPLT_BIT, &ndev->rd_outstanding);
+        return;
+    }
+
+    /* in case the timer has not expired */
+    del_timer(&ndev->rd_timer);
+
+    ndev->rd_ok = ok;
+    set_bit(0, &ndev->rd_ready);
+
+
+    nfp_log(NFP_DBG3, "nfp_read_complete: %s: read completed %s okay", pci_name(ndev->pcidev) , ok ? "" : "not ");
+
+    NF_smp_mb__before_atomic();
+    clear_bit(CMPLT_BIT, &ndev->rd_outstanding);
+    clear_bit(WAIT_BIT, &ndev->rd_outstanding);
+
+    /* wake up anyone waiting */
+
+    nfp_wake_up_all(&ndev->rd_queue);
+}
+
+#if defined (from_timer)
+typedef struct timer_list *compat_timer_arg_t;
+#else
+typedef unsigned long compat_timer_arg_t;
+#endif
+
+static void nfp_read_timeout(compat_timer_arg_t t) {
+    nfp_dev *ndev;
+
+    nfp_log(NFP_DBG4, "nfp_read_timeout: entered");
+
+#if defined(from_timer)
+    ndev = from_timer(ndev, t, rd_timer);
+#else
+    ndev = (nfp_dev *)t;
+#endif
+    if (!ndev) {
+        nfp_log(NFP_DBG1, "nfp_read_timeout: NULL device.");
+        return;
+    }
+
+    nfp_read_complete(ndev, 0);
+}
+
+/**
+ * Reads from an NFP device.
+ *
+ * Data is read from the NFP device into the user space buffer. The read
+ * removes the data from the device. An error is returned is not all the
+ * bytes are read from the user space buffer.
+ *
+ * @param file  device file pointer.
+ * @param buf   pointer to a user space buffer.
+ * @param count maximum size of user space buffer.
+ * @param off   offset position (ignored).
+ * @returns actual number of bytes read or a negative value if an error occurred.
+ */
+static ssize_t nfp_read(struct file *file, char __user *buf, size_t count, loff_t *off) {
+    nfp_dev *ndev;
+    int nbytes;
+    int minor;
+    nfp_err ne;
+    (void) off;
+
+    nfp_log(NFP_DBG4, "nfp_read: entered");
+
+    if (file == NULL) {
+        nfp_log(NFP_DBG1, "nfp_read: pointer to file was NULL.");
+        return -ENODEV;
+    }
+
+    minor = MINOR( INODE_FROM_FILE( file )->i_rdev );
+    if (minor>=NFP_MAXDEV) {
+        nfp_log(NFP_DBG1, "nfp_read: minor: %d out of range:  %d", minor, NFP_MAXDEV);
+        return -ENODEV;
+    }
+  
+    ndev = nfp_dev_list[ minor ];
+    if (!ndev) {
+        nfp_log(NFP_DBG1, "nfp_read: cannot find dev %d.", minor);
+        return -ENODEV;
+    }
+
+    /* check user space buffer */
+    /* the red hat release code for 8.1 is 8 << 8 + 1 = 8*256 + 1 = 2049 */
+
+#if (LINUX_VERSION_CODE >= VERSION(5,0,0)) || \
+    (defined(RHEL_RELEASE_CODE) && ( RHEL_RELEASE_CODE >= 2049 ))
+    if (!access_ok(buf, count))
+#else
+    if (!access_ok(VERIFY_WRITE, buf, count))
+#endif
+    {
+        nfp_log(NFP_DBG1, "nfp_read: %s: user space verify failed.", pci_name(ndev->pcidev));
+        return -EFAULT;
+    }
+
+    /* check max length requested */
+
+    if (count <= 0 || NFP_READ_MAX < count) {
+        nfp_log(NFP_DBG1, "nfp_read: %s: invalid requested max read length %lu", pci_name(ndev->pcidev), count);
+        return -EINVAL;
+    }
+
+    if (!test_and_clear_bit(0, &ndev->rd_ready)) {
+        nfp_log(NFP_DBG1, "nfp_read: %s: read called when not ready.", pci_name(ndev->pcidev));
+        return -EIO;
+    }
+    nbytes = 0;
+
+    /* check if read was ok */
+
+    if (!ndev->rd_ok) {
+        nfp_log(NFP_DBG1, "nfp_read: %s: read failed", pci_name(ndev->pcidev));
+        return -EIO;
+    }
+
+    /* finish read */
+
+    if (ndev->ifvers >= NFDEV_IF_PCI_PUSH) {
+        nbytes = *(unsigned int *) (ndev->read_buf + NFP_DMA_NBYTES_OFFSET);
+        nbytes = FROM_LE32_MEM(&nbytes);
+        nfp_log( NFP_DBG3, "nfp_read: %s: nbytes %d", pci_name(ndev->pcidev), nbytes);
+        if (nbytes < 0 || nbytes > count) {
+            nfp_log(NFP_DBG1, "nfp_read: %s: bad byte count (%d) from device", pci_name(ndev->pcidev), nbytes);
+            return -EIO;
+        }
+        if (0 != nfp_copy_to_user(buf, ndev->read_buf + NFP_DMA_ADDRESS_OFFSET, nbytes)) {
+            nfp_log(NFP_DBG1, "nfp_read: %s: copy to user space failed", pci_name(ndev->pcidev));
+            return -EIO;
+        }
+    } else {
+        nbytes = 0;
+        ne = ndev->cmddev->read_block(buf, count, ndev->common.cmdctx, (void *) &nbytes);
+        if (ne != NFP_SUCCESS) {
+            nfp_log(NFP_DBG1, "nfp_read: %s: device read failed", pci_name(ndev->pcidev));
+            return nfp_oserr(ne);
+        }
+    }
+
+    if (nbytes > NFP_READ_MAX) {
+        nfp_log(NFP_DBG1, "nfp_read: %s: read reply overflow: %d > %d max", pci_name(ndev->pcidev), nbytes, NFP_READ_MAX);
+        return -EIO;
+    }
+
+    nfp_log(NFP_DBG2, "nfp_read: %s: read %d bytes (%s)", pci_name(ndev->pcidev), nbytes, ndev->ifvers >= NFDEV_IF_PCI_PUSH? "dma" : "std");
+    return nbytes;
+}
+
+int nfp_alloc_pci_push( nfp_dev *ndev ) {
+  if (ndev == NULL) {
+    nfp_log(NFP_DBG1, "nfp_alloc_pci_push: ndev was NULL.");
+    return 0;
+  }
+  /* allocate resources needed for PCI Push,
+   * if not already allocated.
+   * return True if successful
+   */
+  if (!ndev->read_buf) {
+    ndev->read_buf= kmalloc( NFP_READBUF_SIZE, GFP_KERNEL | GFP_DMA );
+    if (ndev->read_buf) {
+      memset( ndev->read_buf, 0, NFP_READBUF_SIZE);
+      ndev->read_dma = dma_map_single(&ndev->pcidev->dev, ndev->read_buf,
+                                      NFP_READBUF_SIZE, DMA_BIDIRECTIONAL);
+      if (dma_mapping_error(&ndev->pcidev->dev, ndev->read_dma)) {
+        nfp_log(NFP_DBG1, "dma_mapping_error found after attempting dma_map_single");
+        kfree(ndev->read_buf);
+        ndev->read_buf = NULL;
+        ndev->read_dma = 0;
+      }
+    }
+  }
+  return (ndev->read_buf != NULL);
+}
+
+int nfp_alloc_pci_pull ( nfp_dev *ndev ) {
+  if (ndev == NULL) {
+    nfp_log(NFP_DBG1, "nfp_alloc_pci_pull: ndev was NULL.");
+    return 0;
+  }
+  /* allocate resources needed for PCI Pull,
+   * if not already allocated.
+   * return True if successful
+   */
+  if (!ndev->write_buf) {
+    ndev->write_buf= kmalloc( NFP_WRITEBUF_SIZE, GFP_KERNEL | GFP_DMA );
+    if (ndev->write_buf) {
+      memset( ndev->write_buf, 0, NFP_WRITEBUF_SIZE);
+      ndev->write_dma = dma_map_single(&ndev->pcidev->dev, ndev->write_buf,
+                                      NFP_WRITEBUF_SIZE, DMA_BIDIRECTIONAL);
+      if (dma_mapping_error(&ndev->pcidev->dev, ndev->write_dma)) {
+        nfp_log(NFP_DBG1, "dma_mapping_error found after attempting dma_map_single");
+        kfree(ndev->write_buf);
+        ndev->write_buf = NULL;
+        ndev->write_dma = 0;
+      }
+    }
+  }
+  return (ndev->write_buf != NULL);
+}
+
+void nfp_free_pci_push( nfp_dev *ndev ) {
+  if (ndev == NULL) {
+    nfp_log(NFP_DBG1, "nfp_free_pci_push: ndev was NULL.");
+    return;
+  }
+  /* free resources allocated to PCI Push */
+  if (ndev->read_buf) {
+    dma_unmap_single(&ndev->pcidev->dev, ndev->read_dma,
+                     NFP_READBUF_SIZE, DMA_BIDIRECTIONAL);
+    kfree(ndev->read_buf);
+    ndev->read_buf = NULL;
+    ndev->read_dma = 0;
+  }
+}
+
+void nfp_free_pci_pull( nfp_dev *ndev ) {
+  if (ndev == NULL) {
+    nfp_log(NFP_DBG1, "nfp_free_pci_pull: ndev was NULL.");
+    return;
+  }
+  /* free resources allocated to PCI Pull */
+  if (ndev->write_buf) {
+    dma_unmap_single(&ndev->pcidev->dev, ndev->write_dma,
+                     NFP_WRITEBUF_SIZE, DMA_BIDIRECTIONAL);
+    kfree(ndev->write_buf);
+    ndev->write_buf = NULL;
+    ndev->write_dma = 0;
+  }
+}
+
+/*
+ * Sets device interface version.
+ *
+ * @param ndev an NFP device.
+ * @param ifvers interface verison.
+ */
+static void nfp_set_ifvers(nfp_dev *ndev, int ifvers) {
+#ifdef _WIN32
+#pragma warning(disable:6239)
+#pragma warning(disable:6326)
+#endif
+    int max_ifvers;
+
+    nfp_log(NFP_DBG4, "nfp_set_ifvers: entered");
+
+    if (ndev == NULL) {
+        nfp_log(NFP_DBG1, "nfp_set_ifvers: ndev was NULL.");
+        return;
+    }
+
+    max_ifvers = ndev->cmddev->max_ifvers;
+    if ((nfp_ifvers != 0) && (max_ifvers > nfp_ifvers)) {
+        max_ifvers = nfp_ifvers;
+    }
+
+    /* on any error, ifvers remains unchanged */
+    if (ifvers < 0 || ifvers > max_ifvers) {
+            /* invalid nfp_ifvers: set to max as fallback */
+            nfp_log(NFP_DBG1, "nfp_set_ifvers: %d out of allowable range [0:%d]", ifvers, max_ifvers);
+            return;
+    }
+
+    if (ifvers == 0 && ndev->cmddev->deviceid == PCI_DEVICE_ID_FREESCALE_T1022) {
+        /* default ifvers: set to max for ngsolo not for legacy!
+         * The legacy card needs it set to 0 when in Maintenance mode and
+         * then the hardserver steps it up to ifvers 2 when switching back to
+         * Operational mode. NGSolo starts at the max (3) whenever possible.
+         */
+        ifvers = max_ifvers;
+    }
+
+    if (ifvers >= NFDEV_IF_PCI_PUSH) {
+      if (!nfp_alloc_pci_push(ndev)) {
+        nfp_log( NFP_DBG1,
+                 "nfp_set_ifvers: can't set ifvers %d"
+                 " as resources not available",
+                 ifvers);
+        return;
+      }
+    } else {
+      nfp_free_pci_push(ndev);
+    }
+
+    if (ifvers >= NFDEV_IF_PCI_PULL) {
+      if (!nfp_alloc_pci_pull(ndev)) {
+        nfp_log( NFP_DBG1,
+                 "nfp_set_ifvers: can't set ifvers %d"
+                 " as resources not available",
+                 ifvers);
+        return;
+      }
+    } else {
+      nfp_free_pci_pull(ndev);
+    }
+
+    ndev->ifvers = ifvers;
+    nfp_log(NFP_DBG2, "nfp_set_ifvers: setting ifvers = %d", ifvers);
+
+    return;
+}
+
+/**
+ * Performs an NFP device IOCTL call.
+ *
+ * @param inode device inode pointer.
+ * @param file  device file pointer.
+ * @param cmd   command id.
+ * @param arg   command argument.
+ * @returns 0 if successful.
+ */
+static int nfp_ioctl(struct inode *inode, struct file *file, unsigned int cmd, long unsigned arg) {
+    nfp_dev *ndev;
+    int minor;
+
+    nfp_log(NFP_DBG4, "nfp_ioctl: entered");
+
+    if (file == NULL) {
+        nfp_log(NFP_DBG1, "nfp_ioctl: pointer to file was NULL.");
+        return -ENODEV;
+    }
+
+    /* find ndev from minor */
+
+    minor = MINOR( INODE_FROM_FILE( file )->i_rdev );
+  
+    if (minor>=NFP_MAXDEV) {
+        nfp_log( NFP_DBG1, "nfp_ioctl: minor %d out of range:  %d", minor, NFP_MAXDEV);
+        return -ENODEV;
+    }
+
+    ndev = nfp_dev_list[ minor ];
+    if (!ndev) {
+      nfp_log( NFP_DBG1, "nfp_ioctl: cannot find dev %d.", minor);
+      return -ENODEV;
+    }
+  
+    switch (cmd) {
+    case NFDEV_IOCTL_ENQUIRY: {
+        nfdev_enquiry_str enq_data;
+        int err = -EIO;
+
+        nfp_log(NFP_DBG4, "nfp_ioctl: %s: enquiry", pci_name(ndev->pcidev));
+
+        if ((void *)arg == NULL) {
+            nfp_log(NFP_DBG1, "nfp_ioctl enquiry: %s: arg pointer is NULL.", pci_name(ndev->pcidev));   
+            return err;
+        }
+
+        enq_data.busno = ndev->common.busno;
+        enq_data.slotno = ndev->common.slotno;
+        COPY_TO_USER((void *)arg, &enq_data, sizeof(enq_data), err);
+        if (err) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: %s: copy to user space failed.", pci_name(ndev->pcidev));
+            return err;
+        }
+    }
+    break;
+    case NFDEV_IOCTL_ENSUREREADING:
+    case NFDEV_IOCTL_ENSUREREADING_BUG3349: {
+        unsigned int addr, len;
+        int err = -EIO;
+        nfp_err ne;
+
+        nfp_log(NFP_DBG4, "nfp_ioctl: %s: ensure reading", pci_name(ndev->pcidev));
+
+        if ((void *)arg == NULL) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: %s: ensure reading: arg pointer is NULL!", pci_name(ndev->pcidev));   
+            return err;
+        }
+
+        /* get and check max length */
+        COPY_FROM_USER((void *)&len, (void *)arg, sizeof(unsigned int),err);
+        if (err) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: %s: ensure reading: copy from user space failed.", pci_name(ndev->pcidev));
+            return err;
+        }
+        /* signal a read to the module */
+        nfp_log( NFP_DBG2, "nfp_ioctl: %s: signalling read request to module, len = %x.", pci_name(ndev->pcidev), len );
+        if (len>NFP_READ_MAX) {
+            nfp_log( NFP_DBG1, "nfp_ioctl: %s: len > %x = %x.", pci_name(ndev->pcidev), NFP_READ_MAX, len );
+            return -EINVAL;
+        }
+
+        if (len <= 0 || NFP_READ_MAX < len) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: %s: ensure reading: invalid max length %d/%d", pci_name(ndev->pcidev), len, NFP_READ_MAX);
+            err = -EINVAL;
+            return err;
+        }
+
+        /* check if okay to start read */
+
+        if (test_and_set_bit(WAIT_BIT, &ndev->rd_outstanding)) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: %s: ensure reading: another read is outstanding", pci_name(ndev->pcidev));
+            return -EBUSY;
+        }
+
+        nfp_log( NFP_DBG2,"nfp_ioctl: %s: ndev->rd_outstanding=1", pci_name(ndev->pcidev));
+
+        /* start read ready timeout */
+        start_rd_timer(ndev);
+
+        nfp_log( NFP_DBG2, "nfp_ioctl: %s: read request", pci_name(ndev->pcidev));
+        /* start read */
+
+        addr = (ndev->ifvers < NFDEV_IF_PCI_PUSH) ? 0 : ndev->read_dma;
+        nfp_log(NFP_DBG3,"nfp_ioctl: %s: ensure reading: read request with ifvers=%d addr=%p",
+                pci_name(ndev->pcidev), ndev->ifvers, addr);
+
+        ne = ndev->cmddev->ensure_reading(addr, len, ndev->common.cmdctx, 1);
+
+        if (ne != NFP_SUCCESS) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: %s: ensure reading: read request failed", pci_name(ndev->pcidev));
+            del_timer_sync(&ndev->rd_timer);
+            /* make sure that del_timer_sync is done before we clear rd_outstanding */
+            NF_smp_mb__before_atomic();
+            clear_bit(WAIT_BIT, &ndev->rd_outstanding);
+            return -EIO;
+        }
+    }
+    break;
+
+    case NFDEV_IOCTL_PCI_IFVERS: {
+        int vers, err = -EIO;
+
+        nfp_log(NFP_DBG4, "nfp_ioctl: %s: set ifvers", pci_name(ndev->pcidev));
+
+        if ((void *)arg == NULL) {
+            nfp_log(NFP_DBG1, "nfp_ioctl ifvers: %s: arg pointer is NULL.", pci_name(ndev->pcidev));   
+            return err;
+        }
+
+        COPY_FROM_USER(&vers, (void *)arg, sizeof(vers), err);
+        if (err) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: %s: set ifvers: copy from user space failed.", pci_name(ndev->pcidev));
+            return err;
+        }
+
+        if (test_bit(WAIT_BIT, &ndev->rd_outstanding)) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: %s: set ifvers: unable to set interface version while read outstanding", pci_name(ndev->pcidev));
+            return -EIO;
+        }
+
+        nfp_set_ifvers(ndev, vers);
+    }
+    break;
+
+    case NFDEV_IOCTL_CHUPDATE:
+        nfp_log(NFP_DBG1, "nfp_ioctl: %s: channel update ignored", pci_name(ndev->pcidev));
+        break;
+
+    case NFDEV_IOCTL_DEBUG: {
+        int num, err = -EIO;;
+
+        nfp_log(NFP_DBG4, "nfp_ioctl: debug");
+        if ((void *)arg == NULL) {
+            nfp_log(NFP_DBG1, "nfp_ioctl debug: arg pointer is NULL.");   
+            return err;
+        }
+
+        COPY_FROM_USER(&num, (void *)arg, sizeof(num), err);
+        if (err) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: debug: copy from user space failed.");
+            return err;
+        }
+
+        if (ndev->cmddev->debug) {
+            return nfp_oserr(ndev->cmddev->debug(num, ndev->common.cmdctx));
+        }
+
+        return -EINVAL;
+    }
+    break;
+
+    case NFDEV_IOCTL_STATS: {
+        int err = -EIO;
+
+        nfp_log(NFP_DBG4, "nfp_ioctl: stats");
+
+        if ((void *)arg == NULL) {
+            nfp_log(NFP_DBG1, "nfp_ioctl stats: arg pointer is NULL.");   
+            return err;
+        }
+
+        COPY_TO_USER((void *)arg, &ndev->common.stats, sizeof(nfdev_stats_str), err);
+        if (err) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: stats: copy to user space failed.");
+            return err;
+        }
+    }
+    break;
+
+    case NFDEV_IOCTL_CONTROL: {
+        int err = -EIO;
+        nfdev_control_str control;
+
+        nfp_log(NFP_DBG4, "nfp_ioctl: %s: control", pci_name(ndev->pcidev));
+
+        if ((void *)arg == NULL) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: control: %s: arg pointer is NULL.", pci_name(ndev->pcidev));   
+            return err;
+        }
+
+        COPY_FROM_USER(&control, (void *)arg, sizeof control, err);
+        if (err) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: control: %s: copy from user space failed.", pci_name(ndev->pcidev));
+            return err;
+        }
+
+        if (!ndev->cmddev->setcontrol) {
+            nfp_log(NFP_DBG2, "nfp_ioctl: control: %s: set control not supported for this device: ignored", pci_name(ndev->pcidev));
+            return -EINVAL;
+        }
+        nfp_log(NFP_DBG3, "nfp_ioctl: control: %s: updating HSM control register to 0x%x.", pci_name(ndev->pcidev), control);
+
+        return nfp_oserr(ndev->cmddev->setcontrol(&control, ndev->common.cmdctx));
+    }
+    break;
+
+    case NFDEV_IOCTL_STATUS: {
+        int err = -EIO;
+        nfdev_status_str status;
+
+        nfp_log(NFP_DBG4, "nfp_ioctl: %s: status", pci_name(ndev->pcidev));
+
+        if (!ndev->cmddev->getstatus) {
+            nfp_log(NFP_DBG2, "nfp_ioctl: %s: status not supported for this device: ignored", pci_name(ndev->pcidev));
+            return -EINVAL;
+        }
+        if ((err = ndev->cmddev->getstatus(&status, ndev->common.cmdctx))) {
+            return nfp_oserr(err);
+        }
+        if ((void *)arg != NULL) {
+            COPY_TO_USER((void *)arg, &status, sizeof(status), err);
+            if (err) {
+                nfp_log(NFP_DBG1, "nfp_ioctl: %s: status: copy from user space failed.", pci_name(ndev->pcidev));
+                return err;
+            }
+        }
+        else {
+            nfp_log(NFP_DBG1, "nfp_ioctl: %s: status: arg pointer is NULL.", pci_name(ndev->pcidev));   
+            return err;
+        }
+        if (status.status & NFPCI_SCRATCH_STATUS_ERROR) {
+            nfp_log(NFP_DBG1, "nfp_ioctl: %s: read status: 0x%x, error: 0x%02x%02x%02x%02x%02x%02x%02x%02x",
+                    pci_name(ndev->pcidev), status.status, status.error[0], status.error[1], status.error[2], status.error[3],
+                    status.error[4], status.error[5], status.error[6], status.error[7]);
+        }
+        else {
+            nfp_log(NFP_DBG3, "nfp_ioctl: %s: read status: 0x%x, error: 0x%02x%02x%02x%02x%02x%02x%02x%02x",
+                    pci_name(ndev->pcidev), status.status, status.error[0], status.error[1], status.error[2], status.error[3],
+                    status.error[4], status.error[5], status.error[6], status.error[7]);
+        }
+        
+    }
+    break;
+
+   case NFDEV_IOCTL_PCI_HOT_RESET_STATUS: {
+        /* check if card is in hot reset state */
+        int err = -EIO;
+        int hr_status = 0;
+
+        nfp_log(NFP_DBG4, "nfp_ioctl: %s: hot reset status", pci_name(ndev->pcidev));
+
+        if (!ndev->cmddev->hotreset) {
+            nfp_log(NFP_DBG2, "nfp_ioctl: %s: hotreset not supported for this device: ignored", pci_name(ndev->pcidev));
+            return -EINVAL;
+        }
+
+        err = nfp_hotreset_state(ndev->cmddev, ndev->pcidev, &hr_status);
+        nfp_log(NFP_DBG4, "nfp_ioctl: %s: hot reset status: %d", pci_name(ndev->pcidev), hr_status);
+        if (err) {
+          nfp_log(NFP_DBG1, "nfp_ioctl: %s: error getting hot reset status: %d", pci_name(ndev->pcidev), err);
+          return err;
+        }
+        nfp_log(NFP_DBG4, "nfp_ioctl: %s: hot reset status: hr_status %d", pci_name(ndev->pcidev), hr_status);
+        if ((void *)arg != NULL) {
+            COPY_TO_USER((void *)arg, &hr_status, sizeof(hr_status), err);
+            if (err) {
+                nfp_log(NFP_DBG1, "nfp_ioctl: %s: hot reset status: copy from user space failed.", pci_name(ndev->pcidev));
+                return err;
+            }
+        }
+        else {
+            nfp_log(NFP_DBG1, "nfp_ioctl: %s: hot reset status: arg pointer is NULL.", pci_name(ndev->pcidev));
+            return err;
+        }
+        return 0;
+    }
+    break;
+
+    case NFDEV_IOCTL_PCI_HOT_RESET: {
+        int hotreset, err = -EIO;
+        u16 ctrl;
+        struct pci_bus* bus = ndev->pcidev->bus;
+        struct pci_dev* bridge_dev = bus->self;
+        nfdev_status_str status;
+ 
+        nfp_log(NFP_DBG4, "nfp_ioctl: %s: pci hot reset", pci_name(ndev->pcidev));
+
+        if (!ndev->cmddev->hotreset) {
+            nfp_log(NFP_DBG2, "nfp_ioctl: %s: hotreset not supported for this device: ignored", pci_name(ndev->pcidev));
+            return -EINVAL;
+        }
+
+        if ((void *)arg != NULL) {
+            COPY_FROM_USER(&hotreset, (void *)arg, sizeof(hotreset), err);
+            if (err) {
+                nfp_log(NFP_DBG1, "nfp_ioctl: %s: pci hot reset: copy from user space failed.", pci_name(ndev->pcidev));
+                return err;
+            }
+        }
+        else {
+            nfp_log(NFP_DBG1, "nfp_ioctl pci hot reset: %s: arg pointer is NULL.", pci_name(ndev->pcidev));
+            return err;
+        }
+
+        if (hotreset) {
+            /* put pci virtual bridge into hot reset state */
+            /* store pci registers before enabling hot reset on pci virtual bridge so that we can restore afterwards */
+            nfp_log(NFP_DBG1, "nfp_ioctl pci hot reset: %s: storing pci registers", pci_name(ndev->pcidev));
+            err = pci_save_state(ndev->pcidev);
+            if (err) {
+                nfp_log(NFP_DBG1, "nfp_ioctl pci hot reset: %s: Failed to save pci state using pci_save_state", pci_name(ndev->pcidev));
+                return err;
+            }
+
+            nfp_log(NFP_DBG4, "nfp_ioctl pci hot reset: %s: storing of pci registers successful", pci_name(ndev->pcidev));
+            nfp_log(NFP_DBG4, "nfp_ioctl pci hot reset: %s: arm the hot reset capability on the pci device, hotreset %d", pci_name(ndev->pcidev) ,hotreset);
+            err = pci_write_config_word(ndev->pcidev, PCI_COMMAND, PCI_COMMAND_IO);
+            if (err) {
+                nfp_log(NFP_DBG1, "nfp_ioctl: %s: failed to arm hot reset %d err %d", pci_name(ndev->pcidev) ,hotreset,err);
+                return err;
+            }
+            /* need to sleep this long otherwise hot reset is not enabled! */
+            msleep(5000);
+
+            nfp_log(NFP_DBG1, "nfp_ioctl pci hot reset: %s: starting hot reset", pci_name(ndev->pcidev));
+            /* read pci virtual bridge first so that we can restore to disable hot reset later */
+            err = pci_read_config_word(bridge_dev, PCI_BRIDGE_CONTROL, &ndev->bridge_control_reg);
+            if (err) {
+                nfp_log(NFP_DBG1, "nfp_ioctl pci hot reset: %s: Failed to read pci bridge control %d", pci_name(ndev->pcidev) ,err);
+                return err;
+            }
+            else {
+                /* set the pci bridge control to hot reset state */
+                ctrl = ndev->bridge_control_reg|PCI_BRIDGE_CTL_BUS_RESET;
+                err = pci_write_config_word(bridge_dev, PCI_BRIDGE_CONTROL, ctrl);
+                if (err) {
+                  nfp_log(NFP_DBG1, "nfp_ioctl pci hot reset: %s: Failed to write pci bridge control to set hot reset %d", pci_name(ndev->pcidev) ,err);
+                  return err;
+                }
+                nfp_log(NFP_DBG4, "nfp_ioctl pci hot reset: %s: written for hot reset %04x ", pci_name(ndev->pcidev) ,ctrl);
+                msleep(300);
+            }
+        }
+        else {
+            nfp_log(NFP_DBG1, "nfp_ioctl pci hot reset: %s: ending hot reset", pci_name(ndev->pcidev));
+
+            err = pci_write_config_word(bridge_dev, PCI_BRIDGE_CONTROL, ndev->bridge_control_reg);
+            nfp_log(NFP_DBG4, "nfp_ioctl pci hot reset: %s: written for de hot reset %04x ", pci_name(ndev->pcidev) ,ndev->bridge_control_reg);
+            msleep(1000);
+
+            /* restore pci register */
+            pci_restore_state(ndev->pcidev);
+            msleep(1000);
+
+            /* check that device is up by getting status */
+            if (!ndev->cmddev->getstatus)
+              nfp_log(NFP_DBG2, "nfp_ioctl: %s: status not supported for this device: ignored", pci_name(ndev->pcidev));
+            else if ((err = ndev->cmddev->getstatus(&status, ndev->common.cmdctx)))
+                return nfp_oserr(err);
+        }
+        return 0;
+    }
+    break;
+
+    default: {
+        nfp_log(NFP_DBG1, "nfp_ioctl: %s: unknown ioctl.", pci_name(ndev->pcidev));
+        return -EINVAL;
+    }
+    break;
+
+    }
+
+    return 0;
+}
+
+#if LINUX_VERSION_CODE >= VERSION(2,6,36)
+
+/**
+ * Performs an NFP device unlocked IOCTL call.
+ *
+ * @param file  device file pointer.
+ * @param cmd   command id.
+ * @param arg   command argument.
+ * @returns 0 if successful.
+ */
+static long nfp_unlocked_ioctl(struct file *file, unsigned int cmd, long unsigned arg) {
+    long ret;
+    int minor;
+    nfp_dev *ndev;
+  
+    nfp_log( NFP_DBG2, "nfp_unlocked_ioctl: entered" );
+
+    if (file == NULL) {
+        nfp_log(NFP_DBG1, "nfp_unlocked_ioctl: pointer to file was NULL.");
+        return -ENODEV;
+    }
+  
+    minor = MINOR( INODE_FROM_FILE( file )->i_rdev );
+    if (minor>=NFP_MAXDEV) {
+      nfp_log( NFP_DBG1, "nfp_unlocked_ioctl: minor: %d out of range:  %d", minor, NFP_MAXDEV);
+      return -ENODEV;
+    }
+
+    ndev = nfp_dev_list[ minor ];
+    if (!ndev) {
+      nfp_log( NFP_DBG1, "nfp_unlocked_ioctl: cannot find dev %d.", minor );
+      return -ENODEV;
+    }
+    spin_lock (&ndev->spinlock);
+  
+    ret = nfp_ioctl(NULL, file, cmd, arg);
+  
+    spin_unlock (&ndev->spinlock);
+    nfp_log( NFP_DBG2, "nfp_unlocked_ioctl: left" );
+    return ret;
+}
+
+#endif
+
+static irqreturn_t nfp_isr(int irq, void *context) {
+    nfp_dev *ndev;
+    int handled;
+    nfp_err ne;
+
+    nfp_log(NFP_DBG4, "nfp_isr: entered");
+
+    ndev = (nfp_dev *)context;
+    if (!ndev) {
+        nfp_log(NFP_DBG1, "nfp_isr: no device associated with this interrupt");
+        return IRQ_NONE;
+    }
+
+    ne= ndev->cmddev->isr(ndev->common.cmdctx, &handled);
+
+    if (ne) nfp_log(NFP_DBG1, "nfp_isr: cmddev isr failed (%d)", nfp_oserr(ne));
+
+    return IRQ_RETVAL(handled);
+}
+
+/**
+ * Opens an NFP device.
+ *
+ * The kernel calls this function when a user tries to open an NFP device.
+ * It is an error to attempt to open an already opened device.
+ *
+ * @param inode device inode pointer.
+ * @param file device file pointer.
+ * @return 0 if successful.
+ */
+static int nfp_open(struct inode *inode, struct file *file) {
+    nfp_dev *ndev;
+    nfp_err ne;
+    int minor;
+
+    if (file == NULL) {
+        nfp_log(NFP_DBG1, "nfp_open: pointer to file was NULL.");
+        return -ENODEV;
+    }
+    minor = MINOR( INODE_FROM_FILE( file )->i_rdev );
+
+    if (minor>=NFP_MAXDEV) {
+      nfp_log( NFP_DBG1, "nfp_open: minor: %d out of range: %d.", minor, NFP_MAXDEV);
+      return -ENODEV;
+    }
+
+    nfp_log(NFP_DBG4, "nfp_open: entered");
+
+    nfp_log(NFP_DBG3, "nfp_open: opening file at %p.", file);
+
+    /* find ndev */
+    ndev = nfp_dev_list[ minor ];
+    if (!ndev) {
+      nfp_log( NFP_DBG1, "nfp_open: cannot find dev %d.", minor );
+      return -ENODEV;
+    }
+
+    /* Check if NFP device is already open */
+
+    spin_lock(&ndev->spinlock);
+    if (ndev->busy) {
+        nfp_log(NFP_DBG1, "nfp_open: device %s busy", pci_name(ndev->pcidev));
+        spin_unlock (&ndev->spinlock);
+        return -EBUSY;
+    }
+    ndev->busy = 1;
+    spin_unlock(&ndev->spinlock);
+
+    /* drop any old data */
+
+    clear_bit(0, &ndev->rd_ready);
+
+    /* set interface to module default */
+
+    if (ndev->cmddev->deviceid == PCI_DEVICE_ID_FREESCALE_T1022) {
+        nfp_set_ifvers(ndev, NFDEV_IF_PCI_PULL);
+    } else {
+        nfp_set_ifvers(ndev, NFDEV_IF_STANDARD);
+    }
+    nfp_log(NFP_DBG3, "nfp_open: for %s ifvers set to %d", pci_name(ndev->pcidev), ndev->ifvers);
+
+    /* open device */
+
+    ne = ndev->cmddev->open(ndev->common.cmdctx);
+    if (ne != NFP_SUCCESS) {
+        nfp_log(NFP_DBG1, "nfp_open: device: %s failed to open with error: %d", pci_name(ndev->pcidev), nfp_oserr(ne));
+    	spin_lock(&ndev->spinlock);
+        ndev->busy = 0;
+        spin_unlock(&ndev->spinlock);
+        return nfp_oserr(ne);
+    }
+
+    nfp_log(NFP_DBG2, "nfp_open: device %s open", pci_name(ndev->pcidev));
+
+    return 0;
+}
+
+/**
+ * Releases an NFP device.
+ *
+ * The kernel calls this function when a user tries to close an NFP device.
+ * It is an error to attempt to close an already closed device.
+ *
+ * @param node device inode pointer.
+ * @param file  device file pointer.
+ * @returns 0 if successful.
+ */
+static release_t nfp_release(struct inode *node, struct file *file) {
+    nfp_dev *ndev;
+    long timeout;
+    nfp_err ne;
+    int minor;
+
+    if (file == NULL) {
+        nfp_log(NFP_DBG1, "nfp_release: pointer to file was NULL.");
+        RELEASE_RETURN( -ENODEV );
+    }
+
+    minor = MINOR( INODE_FROM_FILE( file )->i_rdev );
+
+    nfp_log(NFP_DBG4, "nfp_release: entered");
+
+    nfp_log(NFP_DBG2, "nfp_release: closing file at %p.", file);
+
+    /* find ndev from minor */
+
+    if (minor>=NFP_MAXDEV) {
+      nfp_log( NFP_DBG1, "nfp_release: minor: %d out of range:  %d", minor, NFP_MAXDEV);
+      RELEASE_RETURN( -ENODEV );
+    }
+
+    ndev = nfp_dev_list[ minor ];
+    if (!ndev) {
+      nfp_log(NFP_DBG1, "nfp_release: cannot find dev %d.", minor);
+      RELEASE_RETURN( -ENODEV );
+    }
+  
+    {
+      nfp_wait_queue_t wait;
+      timeout= 1;
+      nfp_init_waitqueue_entry( &wait, current);
+      current->__state= TASK_UNINTERRUPTIBLE;
+      add_wait_queue(&ndev->rd_queue, &wait);
+      if (test_bit(WAIT_BIT, &ndev->rd_outstanding)) {
+        nfp_log( NFP_DBG2, "nfp_release: read outstanding");
+        nfp_schedule_timeout (NFP_TIMEOUT, timeout);
+        nfp_log( NFP_DBG3, "nfp_release: finished waiting");
+      }
+      current->__state= TASK_RUNNING;
+      remove_wait_queue(&ndev->rd_queue, &wait);
+      if (!timeout) {
+        nfp_log( NFP_DBG1, "nfp_release: outstanding read timed out");
+      }
+    }
+  
+    spin_lock (&ndev->spinlock);
+    if (test_bit(WAIT_BIT, &ndev->rd_outstanding)) {
+      del_timer_sync(&ndev->rd_timer);
+      /* make sure that del_timer_sync is done before we clear rd_outstanding */
+      NF_smp_mb__before_atomic();
+      clear_bit(WAIT_BIT, &ndev->rd_outstanding);
+    }
+    ndev->busy= 0;
+    spin_unlock (&ndev->spinlock);
+
+    /* close device */
+
+    ne = ndev->cmddev->close(ndev->common.cmdctx);
+    if (ne != NFP_SUCCESS) {
+        nfp_log(NFP_DBG1, "nfp_release: device close failed");
+        return nfp_oserr(ne);
+    }
+
+    RELEASE_RETURN(0);
+}
+
+/**
+ * NFP character device file operations table.
+ */
+static struct file_operations nfp_fops = {
+    owner: THIS_MODULE,
+    poll: nfp_poll,
+    write: nfp_write,
+    read: nfp_read,
+#if LINUX_VERSION_CODE >= VERSION(2,6,36)
+    unlocked_ioctl: nfp_unlocked_ioctl,
+#else
+    ioctl: nfp_ioctl,
+#endif
+    open: nfp_open,
+    release: nfp_release,
+};
+
+/**
+ * @addtogroup devmgr
+ * NFP device management.
+ * @{
+ */
+
+/* device setup -------------------------------------------------- */
+
+static void nfp_dev_destroy( nfp_dev *ndev, struct pci_dev *pci_dev ) {
+  int i;
+  nfp_log(NFP_DBG2,"nfp_dev_destroy: entered");
+  if (ndev) {
+    del_timer_sync(&ndev->rd_timer);
+    nfp_free_pci_push(ndev);
+    nfp_free_pci_pull(ndev);
+
+    if (ndev->irq) {
+      nfp_log(NFP_DBG3, "nfp_dev_destroy: freeing irq, %x", ndev->irq);
+      free_irq( ndev->irq, ndev );
+    }
+    for(i=0;i<6;i++)
+      if (ndev->common.bar[i]) {
+        nfp_log(NFP_DBG3, "nfp_dev_destroy: freeing MEM BAR, %d", i);
+        release_mem_region( pci_resource_start(pci_dev, i), pci_resource_len(pci_dev, i) );
+        IOUNMAP( ndev->common.bar[i] );
+      }
+    nfp_log(NFP_DBG3,"nfp_dev_destroy: freeing ndev");
+    kfree( ndev );
+  }
+}
+
+static int nfp_setup( const nfpcmd_dev *cmddev, unsigned char bus, unsigned char slot, unsigned int bar[6], unsigned int irq_line, struct pci_dev *pcidev) {
+  nfp_dev *ndev = 0;
+  nfp_err ne;
+  int i;
+
+  if (cmddev == NULL) {
+    nfp_log(NFP_DBG1, "nfp_setup: cmddev was NULL.");
+    return 0;
+  }
+
+  if (pcidev == NULL) {
+    nfp_log(NFP_DBG1, "nfp_setup: pcidev was NULL.");
+    return 0;
+  }
+
+  nfp_log( NFP_DBG2, "nfp_setup: Found '%s' at bus %x, slot %x, irq %d.", cmddev->name, bus, slot, irq_line);
+  
+  if (nfp_num_devices>=NFP_MAXDEV) {
+    nfp_log( NFP_DBG1, "nfp_setup: minor out of range." );
+    goto fail_continue;
+  }
+
+  ndev = (struct nfp_dev *)kmalloc( sizeof( *ndev ), GFP_KERNEL);
+  if (!ndev) {
+    nfp_log( NFP_DBG1, "nfp_setup: failed to allocate device structure." );
+    goto fail_continue;
+  }
+  nfp_log( NFP_DBG2, "nfp_setup: allocated device structure.");
+  memset( ndev, 0, sizeof( *ndev ) );
+
+  ndev->common.busno= bus;
+  ndev->pcidev= pcidev;
+  ndev->common.slotno= slot;
+  ndev->cmddev= cmddev;
+
+  for(i=0;i<6;i++) {
+    int map_bar_size = cmddev->bar_sizes[i] & NFP_MEMBAR_MASK;
+
+    if (map_bar_size) {
+      if (!request_mem_region( pci_resource_start(pcidev, i), pci_resource_len(pcidev, i), cmddev->name)) {
+        nfp_log( NFP_DBG1, "nfp_setup: request_mem_region failed, %x %x %d (%s)", pci_resource_start(pcidev, i), pci_resource_len(pcidev, i), i, cmddev->name );
+        goto fail_continue;
+      }
+
+      /* ioremap has been uncached since kernel 2.6.25 */
+      ndev->common.bar[i] = ioremap( bar[i], map_bar_size );
+
+      if (ndev->common.bar[i] == NULL) {
+        nfp_log( NFP_DBG1, "nfp_setup: unable to map memory BAR %d, (0x%x).", i, bar[i] );
+        goto fail_continue;
+      }
+    }
+  }
+
+  nfp_init_waitqueue_head( &ndev->wr_queue );
+  nfp_init_waitqueue_head( &ndev->rd_queue );
+
+  set_bit(0, &ndev->wr_ready);
+
+  spinlock_init( &ndev->spinlock );
+
+  ne = ndev->cmddev->create(&ndev->common);
+  if (ne != NFP_SUCCESS) {
+    nfp_log( NFP_DBG1, "nfp_setup: failed to create command device (%d)", nfp_oserr(ne));
+    goto fail_continue;
+  }
+  ndev->common.dev= ndev;
+
+  if (request_irq( irq_line,
+		   nfp_isr,
+		   IRQF_SHARED,
+		   cmddev->name,
+		   ndev)) {
+    nfp_log( NFP_DBG1, "nfp_setup: unable to claim interrupt." );
+    goto fail_continue;
+  }
+  ndev->irq= irq_line;
+
+  memset( &(ndev->common.stats), 0, sizeof( ndev->common.stats ) );
+
+  pci_set_drvdata( pcidev, ndev );
+
+  /* setup timeout timer */
+#if defined(from_timer)
+  /* Note that when from_timer is available, so is timer_setup.  timer_setup
+   * may not be a macro so we can't check that it's defined.
+   */
+  timer_setup(&ndev->rd_timer, nfp_read_timeout, 0);
+#else
+  init_timer(&ndev->rd_timer);
+  ndev->rd_timer.function = nfp_read_timeout;
+  ndev->rd_timer.data=(unsigned long)ndev;
+#endif
+
+  nfp_dev_list[ nfp_num_devices ] =  ndev;
+  device_create(nfp_class,
+                NULL, /* parent */
+                MKDEV(NFP_MAJOR, nfp_num_devices),
+                NULL, /* drvdata */
+                "nfp%d",
+                nfp_num_devices);
+  nfp_log( NFP_DBG2, "nfp_setup: nfp_num_devices= %d, ndev = %p.", nfp_num_devices, ndev );
+  nfp_num_devices ++;
+  return 1;
+
+fail_continue:
+  nfp_dev_destroy(ndev, pcidev);
+
+  return 0;
+}
+
+/* device probing ---------------------------------------------------------- */
+
+/**
+ * Adds a PCI device to the module. The PCI subsystem calls this function
+ * when a PCI device is found.
+ *
+ * @param pcidev PCI device.
+ * @param id PCI device ids.
+ * @returns 0 if successful.
+ */
+static int __devinit nfp_pci_probe(struct pci_dev *pcidev, struct pci_device_id const *id) {
+    int i;
+    unsigned int bar[6];
+    const nfpcmd_dev *cmddev = nfp_drvlist[id->driver_data];
+    long unsigned iosize;
+    unsigned int irq_line;
+    int pos = 0u;
+    int err = -EIO;
+    int hr_status = 0;
+    
+    if (pcidev == NULL) {
+        nfp_log(NFP_DBG1, "nfp_pci_probe: pcidev was NULL.");
+        return -ENODEV;
+    }
+
+    if (id == NULL) {
+        nfp_log(NFP_DBG1, "nfp_pci_probe: id was NULL.");
+        return -ENODEV;
+    }
+    
+    nfp_log(NFP_DBG3, "nfp_pci_probe: probing PCI device %s", pci_name(pcidev));
+
+    nfp_log( NFP_DBG1, "nfp_pci_probe: %s: entered", pci_name(pcidev));
+
+    /* We only check hot reset state for devices supporting hot reset. */
+    if (cmddev->hotreset) {
+        err = nfp_hotreset_state(cmddev, pcidev, &hr_status);
+        if (err)
+            nfp_log(NFP_DBG1, "nfp_pci_probe: %s: nfp_hotreset_state failed. %d", pci_name(pcidev) , err);
+        if (hr_status) {
+            nfp_log(NFP_DBG1, "nfp_pci_probe: PCI device %s is in HOT RESET, exit probing", pci_name(pcidev));
+            return -ENODEV;
+        }
+    }
+ 
+    /* enable the device */
+
+    err = pci_enable_device(pcidev);
+    nfp_log( NFP_DBG1, "nfp_pci_probe: %s: pci_enable_device", pci_name(pcidev));
+    if (err) {
+        nfp_log(NFP_DBG1,"nfp_pci_probe: %s: pci_enable_device failed", pci_name(pcidev));
+        err = -ENODEV;
+        goto probe_err;
+    }
+
+    pci_set_master(pcidev);
+    nfp_log( NFP_DBG1, "nfp_pci_probe: %s: pci_set_master", pci_name(pcidev));
+    /* save PCI device info */
+
+    irq_line = pcidev->irq;
+    for (i = 0; i < NFP_BARSIZES_COUNT; ++i) {
+        iosize = cmddev->bar_sizes[i] & NFP_BARSIZES_MASK;
+        if (pci_resource_len(pcidev, i) < iosize) {
+            nfp_log(NFP_DBG1, "nfp_pci_probe: %s region request overflow: bar %d, requested %x, maximum %x",
+                    pci_name(pcidev), i, iosize, pci_resource_len(pcidev, i));
+            err = -ENODEV;
+            goto probe_err;
+        }
+        bar[i] = pci_resource_start(pcidev, i);
+    }
+
+    if (cmddev->flags & NFP_CMD_FLG_NEED_MSI) {
+        pos = pci_find_capability(pcidev, PCI_CAP_ID_MSI);
+        if (!pos) {
+            nfp_log(NFP_DBG1, "nfp_pci_probe: %s MSI not supported", pci_name(pcidev));
+            err = -ENODEV;
+            goto probe_err;
+        }
+        nfp_log(NFP_DBG1, "nfp_pci_probe: %s MSI support at %d", pci_name(pcidev), pos);
+
+        err = pci_enable_msi(pcidev);
+        if (err) {
+            nfp_log(NFP_DBG1, "nfp_pci_probe: %s unable to enable MSI", pci_name(pcidev));
+            goto probe_err;
+        }
+
+        /* IRQ vector changes if MSI is enabled. */
+        irq_line = pcidev->irq;
+        nfp_log(NFP_DBG3, "nfp_pci_probe: %s MSI IRQ at %d", pci_name(pcidev), irq_line);
+    }
+
+    nfp_log( NFP_DBG2,
+             "nfp_probe: devname %s, slotname %s, busname %s",
+             "",
+             pci_name(pcidev),
+             pcidev->bus->name);
+
+    err = nfp_setup( cmddev,
+                     pcidev->bus->number,
+                     PCI_SLOT(pcidev->devfn),
+                     bar,
+                     irq_line,
+                     pcidev );
+    if (!err) {
+        err = -ENODEV;
+        goto probe_err;
+    }
+
+    return 0;
+
+    probe_err:
+        pci_disable_msi(pcidev);
+        pci_clear_master(pcidev);
+        pci_disable_device(pcidev);
+        return err;
+}
+
+/**
+ * Removes a PCI device from the module. The PCI subsystem calls this function
+ * when a PCI device is removed.
+ *
+ * @param pcidev PCI device.
+ * @returns 0 if successful.
+ */
+static void __devexit nfp_pci_remove(struct pci_dev *pcidev) {
+    int index;
+    nfp_dev *ndev;
+
+    if (pcidev == NULL) {
+        nfp_log(NFP_DBG1, "nfp_pci_remove: pcidev was NULL.");
+        return;
+    }
+
+    nfp_log(NFP_DBG1, "nfp_pci_remove: removing PCI device %s", pci_name(pcidev));
+
+    /* find existing device */
+
+    ndev = pci_get_drvdata(pcidev);
+    if (ndev == NULL) {
+        nfp_log(NFP_DBG1,"nfp_pci_remove: %s: no NFP device associated with this PCI device", pci_name(pcidev));
+        return;
+    }
+
+    /* destroy common device */
+
+    if (ndev->cmddev)
+        ndev->cmddev->destroy(ndev->common.cmdctx);
+
+    nfp_dev_destroy(ndev, pcidev);
+
+    pci_disable_msi(pcidev);
+    pci_clear_master(pcidev);
+    pci_disable_device(pcidev);
+
+    index = 0;
+    while( index < NFP_MAXDEV ) {
+      if (nfp_dev_list[ index ] == ndev) {
+        nfp_dev_list[ index ] = NULL;
+        device_destroy(nfp_class, MKDEV(NFP_MAJOR, index));
+      }
+      index++;
+    }
+}
+
+/**
+ * PCI device ID table.
+ */
+static struct pci_device_id nfp_pci_tbl[] __devinitdata = {
+    {   PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_21555, PCI_VENDOR_ID_NCIPHER, PCI_SUBSYSTEM_ID_NFAST_REV1,
+        0, 0, /* Ignore class */
+        0 /* Index into nfp_drvlist */
+    },
+    {   PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_FREESCALE_C293, PCI_VENDOR_ID_NCIPHER, PCI_SUBSYSTEM_ID_NFAST_REV1,
+        0, 0, /* Ignore class */
+        1 /* Index into nfp_drvlist */
+    },
+    {   PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_FREESCALE_P3041, PCI_VENDOR_ID_NCIPHER, PCI_SUBSYSTEM_ID_NFAST_REV1,
+        0, 0, /* Ignore class */
+        2 /* Index into nfp_drvlist */
+    },
+    {   PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_FREESCALE_T1022, PCI_VENDOR_ID_NCIPHER, PCI_SUBSYSTEM_ID_NFAST_REV1,
+        0, 0, /* Ignore class */
+        3 /* Index into nfp_drvlist */
+    },
+    {   0,} /* terminate list */
+};
+MODULE_DEVICE_TABLE(pci, nfp_pci_tbl);
+
+/**
+ * PCI driver operations.
+ */
+static struct pci_driver nfp_pci_driver = {
+    .name = "nfp",
+    .probe = nfp_pci_probe,
+    .remove = __devexit_p(nfp_pci_remove),
+    .id_table = nfp_pci_tbl
+};
+
+/*--------------------*/
+/*  init              */
+/*--------------------*/
+
+static int nfp_init( void ) {
+  int index;
+
+  nfp_log( NFP_DBG1, "nfp_init: entered" );
+
+  if (register_chrdev( NFP_MAJOR, NFP_DRVNAME, &nfp_fops)) {
+    nfp_log( NFP_DBG1, "unable to get major for nfp device." );
+    return -EIO;
+  }
+
+  for( index = 0; index < NFP_MAXDEV; index++ )
+    nfp_dev_list[index] = NULL;
+
+  nfp_class = class_create(THIS_MODULE, "nfp");
+  if (IS_ERR(nfp_class))
+  {
+    nfp_log( NFP_DBG1,
+             "nfp_init: failed to create a class for this device, err = %ld",
+             PTR_ERR(nfp_class));
+    return -EIO;
+  }
+
+  index= 0;
+  nfp_log( NFP_DBG1, "nfp_init: left" );
+  return pci_module_init(&nfp_pci_driver);
+}
+
+/** @} */
+
+/**
+ * Initializes this NFP kernel module.
+ */
+static int __init nfp_module_init(void) {
+    int err;
+
+    nfp_log(NFP_DBG1, "nfp_module_init: inserting nfp module");
+
+    err = nfp_init();
+
+    return err;
+}
+
+/**
+ * Exits this NFP kernel module.
+ */
+static void __exit nfp_module_exit(void) {
+
+    nfp_log(NFP_DBG3,"nfp_module_exit: removing nfp module");
+
+    /* unregister pci driver */
+
+    pci_unregister_driver(&nfp_pci_driver);
+    /* ... which triggers device removals */
+
+
+    class_destroy(nfp_class);
+  
+    unregister_chrdev( NFP_MAJOR, NFP_DRVNAME );
+    nfp_log(NFP_DBG1,"nfp_module_exit: removed nfp module");
+}
+
+module_init(nfp_module_init);
+module_exit(nfp_module_exit);
+
+/* end of file */
diff --git drivers/misc/nshield/i21555.c drivers/misc/nshield/i21555.c
new file mode 100644
index 000000000000..dcafe84b5d95
--- /dev/null
+++ drivers/misc/nshield/i21555.c
@@ -0,0 +1,495 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+i21555.c: nCipher PCI HSM intel 21555 command driver
+
+ * (c) nCipher Security Limited 2019
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#include "nfp_common.h"
+#include "nfp_error.h"
+#include "nfp_hostif.h"
+#include "nfp_osif.h"
+#include "i21555.h"
+#include "nfp_cmd.h"
+#include "nfpci.h"
+
+/* started ------------------------------------------------------
+ *
+ * Check that device is ready to talk, by checking that
+ * the i21555 has master enabled on its secondary interface
+ */
+
+static nfp_err i21555_started( nfp_cdev *pdev ) {
+  unsigned int tmp32;
+#ifdef CONFIGSPACE_DEBUG
+  unsigned int reg32[64];
+  int i;
+#endif
+  nfp_err ne;
+
+  nfp_log( NFP_DBG2, "i21555_started: entered");
+
+#ifdef CONFIGSPACE_DEBUG
+  /* Suck up all the registers */
+  for (i=0; i < 64; i++) {
+    ne = nfp_config_inl( pdev, i*4, &reg32[i] );
+  }
+
+  for (i=0; i < 16; i++) {
+    int j = i * 4;
+    nfp_log( NFP_DBG3, "i21555 config reg %2x: %08x %08x %08x %08x", j*4,
+        reg32[j], reg32[j+1], reg32[j+2], reg32[j+3]);
+  }
+#endif
+
+  ne = nfp_config_inl( pdev, I21555_CFG_SEC_CMD_STATUS, &tmp32 );
+  if (ne) {
+    /* succeed if PCI config reads are not implemented */
+    if (ne == NFP_EUNKNOWN)
+      return NFP_SUCCESS;
+    nfp_log( NFP_DBG1, "i21555_started: nfp_config_inl failed");
+    return ne;
+  }
+
+  tmp32= FROM_LE32_CONFIG(&tmp32) & 0xffff;
+
+  if ( tmp32 & CFG_CMD_MASTER ) {
+    nfp_log( NFP_DBG3, "i21555_started: Yes %x", tmp32);
+    return NFP_SUCCESS;
+  } else {
+    nfp_log( NFP_DBG1, "i21555_started: device not started yet %x", tmp32);
+    return NFP_ESTARTING;
+  }
+}
+
+/* create ------------------------------------------------------- */
+
+static nfp_err i21555_create( nfp_cdev *pdev ) {
+  unsigned int tmp32;
+
+  nfp_log( NFP_DBG2, "i21555_create: entered");
+  pdev->cmdctx= pdev;  /* set our context to just be a pointer to our nfp_cdev */
+
+  if(!pdev->bar[ CSR_BAR ]) {
+    nfp_log( NFP_DBG1, "i21555_create: null BAR[%d]", CSR_BAR );
+    return NFP_ENOMEM;
+  }
+  nfp_log( NFP_DBG2, "i21555_create: enable doorbell");
+  TO_LE32_MEM( &tmp32, I21555_DOORBELL_PRI_ENABLE );
+  nfp_outl( pdev, CSR_BAR, I21555_OFFSET_DOORBELL_PRI_SET_MASK, tmp32 );
+  nfp_outl( pdev, CSR_BAR, I21555_OFFSET_DOORBELL_PRI_CLEAR_MASK, tmp32 );
+  return NFP_SUCCESS;
+}
+
+/* stop ------------------------------------------------------- */
+
+static nfp_err i21555_destroy( void * ctx ) {
+  nfp_cdev *pdev;
+  unsigned int tmp32;
+
+  nfp_log( NFP_DBG2, "i21555_destroy: entered");
+
+  pdev= (nfp_cdev *)ctx;
+  if(!pdev) {
+    nfp_log( NFP_DBG1, "i21555_destroy: NULL pdev");
+    return NFP_ENODEV;
+  }
+  if(!pdev->bar[ CSR_BAR ]) {
+    nfp_log( NFP_DBG1, "i21555_destroy: null BAR[%d]", CSR_BAR );
+    return NFP_ENOMEM;
+  }
+  TO_LE32_MEM( &tmp32, I21555_DOORBELL_PRI_DISABLE );
+  nfp_outl( pdev, CSR_BAR, I21555_OFFSET_DOORBELL_PRI_SET_MASK, tmp32 );
+  nfp_outl( pdev, CSR_BAR, I21555_OFFSET_DOORBELL_PRI_CLEAR_MASK, tmp32 );
+
+  return NFP_SUCCESS;
+}
+
+/* open ------------------------------------------------------- */
+
+static nfp_err i21555_open( void * ctx ) {
+  (void)ctx;
+
+  nfp_log( NFP_DBG2, "i21555_open: entered");
+
+  return NFP_SUCCESS;
+}
+
+/* close ------------------------------------------------------- */
+
+static nfp_err i21555_close( void * ctx ) {
+  (void)ctx;
+  nfp_log( NFP_DBG2, "i21555_close: entered");
+
+  return NFP_SUCCESS;
+}
+
+/* isr ------------------------------------------------------- */
+
+static nfp_err i21555_isr( void *ctx, int *handled ) {
+  nfp_cdev *pdev;
+  unsigned short doorbell;
+  unsigned short tmp16;
+
+  nfp_log( NFP_DBG3, "i21555_isr: entered");
+
+  *handled= 0;
+  pdev= (nfp_cdev *)ctx;
+  if(!pdev) {
+    nfp_log( NFP_DBG1, "i21555_isr: NULL pdev");
+    return NFP_ENODEV;
+  }
+
+  pdev->stats.isr++;
+
+  if(!pdev->bar[ CSR_BAR ]) {
+    nfp_log( NFP_DBG1, "i21555_isr: null BAR[%d]", CSR_BAR );
+    return NFP_ENOMEM;
+  }
+
+  /* This interrupt may not be from our module, so check that it actually is
+   * us before handling it.
+   */
+  doorbell= nfp_inw( pdev, CSR_BAR, I21555_OFFSET_DOORBELL_PRI_SET);
+  doorbell= FROM_LE16_MEM(&doorbell);
+  while( doorbell && doorbell != 0xffff) {
+    *handled= 1;
+    /* service interrupts */
+    if( doorbell & (NFAST_INT_DEVICE_WRITE_OK | NFAST_INT_DEVICE_WRITE_FAILED)) {
+      pdev->stats.isr_write++;
+      TO_LE16_MEM(&tmp16,NFAST_INT_DEVICE_WRITE_OK | NFAST_INT_DEVICE_WRITE_FAILED);
+      nfp_outw( pdev, CSR_BAR, I21555_OFFSET_DOORBELL_PRI_CLEAR, tmp16 );
+
+      nfp_log( NFP_DBG2, "i21555_isr: write done interrupt, ok = %d.", doorbell & NFAST_INT_DEVICE_WRITE_OK ? 1 : 0 );
+
+      nfp_write_complete(pdev->dev, doorbell & NFAST_INT_DEVICE_WRITE_OK ? 1 : 0 );
+    }
+
+    if( doorbell & (NFAST_INT_DEVICE_READ_OK | NFAST_INT_DEVICE_READ_FAILED)) {
+      pdev->stats.isr_read++;
+      TO_LE16_MEM(&tmp16,NFAST_INT_DEVICE_READ_OK | NFAST_INT_DEVICE_READ_FAILED);
+      nfp_outw( pdev, CSR_BAR, I21555_OFFSET_DOORBELL_PRI_CLEAR, tmp16 );
+
+      nfp_log( NFP_DBG2, "i21555_isr: read ack interrupt, ok = %d.", doorbell & NFAST_INT_DEVICE_READ_OK ? 1 : 0 );
+      nfp_read_complete( pdev->dev, doorbell & NFAST_INT_DEVICE_READ_OK ? 1 : 0);
+    }
+
+    if( doorbell & ~(NFAST_INT_DEVICE_READ_OK  | NFAST_INT_DEVICE_READ_FAILED |
+                     NFAST_INT_DEVICE_WRITE_OK | NFAST_INT_DEVICE_WRITE_FAILED)) {
+      TO_LE16_MEM(&tmp16,doorbell);
+      nfp_outw( pdev, CSR_BAR, I21555_OFFSET_DOORBELL_PRI_CLEAR, tmp16 );
+      nfp_log( NFP_DBG1, "i21555_isr: unexpected interrupt %x", doorbell );
+    }
+    doorbell= nfp_inw( pdev, CSR_BAR, I21555_OFFSET_DOORBELL_PRI_SET);
+    doorbell= FROM_LE16_MEM(&doorbell);
+  }
+  nfp_log( NFP_DBG3, "i21555_isr: exiting");
+  return 0;
+}
+
+/* write ------------------------------------------------------- */
+
+static nfp_err i21555_write(unsigned int addr, const char *block, int len, void *ctx) {
+  nfp_cdev *cdev;
+  unsigned int hdr[2];
+  nfp_err ne;
+  unsigned short tmp16;
+  unsigned int tmp32;
+
+  /* Note: 'addr' not used in this implementation,
+   * and this is to silence the Windows build */
+  (void) addr;
+
+  nfp_log( NFP_DBG2, "i21555_write: entered");
+
+  cdev= (nfp_cdev *)ctx;
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21555_write: NULL cdev");
+    return NFP_ENODEV;
+  }
+
+  cdev->stats.write_fail++;
+
+  if(!cdev->bar[ CSR_BAR ]) {
+    nfp_log( NFP_DBG1, "i21555_write: null BAR[%d]", CSR_BAR );
+    return NFP_ENOMEM;
+  }
+
+  ne = i21555_started( cdev );
+  if (ne) {
+    if (ne != NFP_ESTARTING) {
+      nfp_log( NFP_DBG1, "i21555_write: i21555_started failed");
+    }
+    return ne;
+  }
+
+  nfp_log( NFP_DBG3, "i21555_write: cdev->bar[ MEMBAR2 ]= %p", cdev->bar[ MEMBAR2 ]);
+  nfp_log( NFP_DBG3, "i21555_write: cdev->bar[ CSR_BAR ]= %p", cdev->bar[ CSR_BAR ]);
+  nfp_log( NFP_DBG3, "i21555_write: block len %d", len ); 
+  ne= nfp_copy_from_user_to_dev( cdev, MEMBAR2, NFPCI_JOBS_WR_DATA, block, len);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_write: nfp_copy_from_user_to_dev failed");
+    return ne;
+  }
+  TO_LE32_MEM(&hdr[0], NFPCI_JOB_CONTROL);
+  TO_LE32_MEM(&hdr[1], len);
+  ne= nfp_copy_to_dev( cdev, MEMBAR2, NFPCI_JOBS_WR_CONTROL, (const char *)hdr, 8);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_write: nfp_copy_to_dev failed");
+    return ne;
+  }
+  ne= nfp_copy_from_dev( cdev, MEMBAR2, NFPCI_JOBS_WR_LENGTH, (char *)hdr, 4);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_write: nfp_copy_from_dev failed");
+    return ne;
+  }
+
+  TO_LE32_MEM(&tmp32, len);
+  if ( hdr[0] != tmp32 ) {
+    nfp_log( NFP_DBG1, "i21555_write: length not written");
+    return NFP_EIO;
+  }
+  TO_LE16_MEM(&tmp16, NFAST_INT_HOST_WRITE_REQUEST >> 16);
+  nfp_outw( cdev, CSR_BAR, I21555_OFFSET_DOORBELL_SEC_SET, tmp16);
+
+  cdev->stats.write_fail--;
+  cdev->stats.write_block++;
+  cdev->stats.write_byte += len;
+
+  nfp_log( NFP_DBG2, "i21555_write: done");
+  return NFP_SUCCESS;
+}
+
+/* read ------------------------------------------------------- */
+
+static nfp_err i21555_read( char *block, int len, void *ctx, int *rcount) {
+  nfp_cdev *cdev;
+  nfp_err ne;
+  int count;
+
+  nfp_log( NFP_DBG2, "i21555_read: entered");
+  *rcount= 0;
+
+  cdev= (nfp_cdev *)ctx;
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21555_read: NULL pdev");
+    return NFP_ENODEV;
+  }
+
+  cdev->stats.read_fail++;
+
+  if(!cdev->bar[ CSR_BAR ]) {
+    nfp_log( NFP_DBG1, "i21555_read: null BAR[%d]", CSR_BAR );
+    return NFP_ENOMEM;
+  }
+
+  ne = i21555_started( cdev );
+  if (ne) {
+    if (ne != NFP_ESTARTING) {
+      nfp_log( NFP_DBG1, "i21555_read: i21555_started failed");
+    }
+    return ne;
+  }
+
+  ne= nfp_copy_from_dev( cdev, MEMBAR2, NFPCI_JOBS_RD_LENGTH, (char *)&count, 4);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_read: nfp_copy_from_dev failed.");
+    return ne;
+  }
+  count= FROM_LE32_MEM(&count);
+  if(count<0 || count>len) {
+    nfp_log( NFP_DBG1, "i21555_read: bad byte count (%d) from device", count);
+    return NFP_EIO;
+  }
+  ne= nfp_copy_to_user_from_dev( cdev, MEMBAR2, NFPCI_JOBS_RD_DATA, block, count);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_read: nfp_copy_to_user failed.");
+    return ne;
+  }
+  nfp_log( NFP_DBG2, "i21555_read: done");
+  *rcount= count;
+  cdev->stats.read_fail--;
+  cdev->stats.read_block++;
+  cdev->stats.read_byte += len;
+  return NFP_SUCCESS;
+}
+
+/* chupdate  ------------------------------------------------------- */
+
+static nfp_err i21555_chupdate( char *data, int len, void *ctx ) {
+  (void)ctx;
+  (void)len;
+  (void)data;
+  nfp_log( NFP_DBG1, "i21555_chupdate: NYI");
+  return NFP_SUCCESS;
+}
+
+/* ensure reading -------------------------------------------------- */
+
+static nfp_err i21555_ensure_reading( unsigned int addr, int len, void *ctx, int lock_flag ) {
+  nfp_cdev *cdev;
+  unsigned int hdr[3];
+  unsigned short tmp16;
+  unsigned int tmp32;
+  nfp_err ne;
+  int hdr_len;
+
+  /* not used with i21555, mentioned to defeat build warnings
+   */
+  (void)lock_flag;
+
+
+  nfp_log( NFP_DBG2, "i21555_ensure_reading: entered");
+
+  cdev= (nfp_cdev *)ctx;
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21555_ensure_reading: NULL cdev");
+    return NFP_ENODEV;
+  }
+
+  cdev->stats.ensure_fail++;
+
+  if(!cdev->bar[ CSR_BAR ]) {
+    nfp_log( NFP_DBG1, "i21555_ensure_reading: null BAR[%d]", CSR_BAR );
+    return NFP_ENOMEM;
+  }
+
+  ne = i21555_started( cdev );
+  if (ne) {
+    if (ne != NFP_ESTARTING) {
+      nfp_log( NFP_DBG1, "i21555_ensure_reading: i21555_started failed");
+    }
+    return ne;
+  }
+
+  nfp_log( NFP_DBG3, "i21555_ensure_reading: pdev->bar[ MEMBAR2 ]= %p", cdev->bar[ MEMBAR2 ]);
+  nfp_log( NFP_DBG3, "i21555_ensure_reading: pdev->bar[ CSR_BAR ]= %p", cdev->bar[ CSR_BAR ]);
+  if(addr) {
+    nfp_log( NFP_DBG3, "i21555_ensure_reading: new format, addr %p", addr);
+    TO_LE32_MEM(&hdr[0], NFPCI_JOB_CONTROL_PCI_PUSH);
+    TO_LE32_MEM(&hdr[1], len);
+    TO_LE32_MEM(&hdr[2], addr);
+    hdr_len= 12;
+  } else {
+    TO_LE32_MEM(&hdr[0], NFPCI_JOB_CONTROL);
+    TO_LE32_MEM(&hdr[1], len);
+    hdr_len= 8;
+  }
+
+  ne= nfp_copy_to_dev( cdev, MEMBAR2, NFPCI_JOBS_RD_CONTROL, (const char *)hdr, hdr_len);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_ensure_reading: nfp_copy_to_dev failed");
+    return ne;
+  }
+
+  ne= nfp_copy_from_dev( cdev, MEMBAR2, NFPCI_JOBS_RD_LENGTH, (char *)hdr, 4);
+  if (ne) {
+    nfp_log( NFP_DBG1, "i21555_ensure_reading: nfp_copy_from_dev failed");
+    return ne;
+  }
+
+  TO_LE32_MEM(&tmp32, len);
+
+  if ( hdr[0] != tmp32 ) {
+    nfp_log( NFP_DBG1, "i21555_ensure_reading: len not written");
+    return NFP_EIO;
+  }
+  TO_LE16_MEM( &tmp16, NFAST_INT_HOST_READ_REQUEST >> 16);
+  nfp_outw( cdev, CSR_BAR, I21555_OFFSET_DOORBELL_SEC_SET, tmp16);
+
+  cdev->stats.ensure_fail--;
+  cdev->stats.ensure++;
+
+  return NFP_SUCCESS;
+}
+
+/* set control register ----------------------------------------- */
+
+static nfp_err i21555_set_control( const nfdev_control_str *control,
+                                   void *ctx ) {
+  nfp_cdev *cdev = (nfp_cdev *)ctx;
+  uint32_t control_flipped;
+
+  nfp_log( NFP_DBG3, "i21555_set_control: entered");
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21555_set_control: NULL pdev");
+    return NFP_ENODEV;
+  }
+  if(!cdev->bar[ CSR_BAR ]) {
+    nfp_log( NFP_DBG1, "i21555_write: null BAR[%d]", CSR_BAR );
+    return NFP_ENOMEM;
+  }
+  TO_LE32_MEM(&control_flipped, control->control);
+  nfp_outl( cdev, CSR_BAR, I21555_SCRATCHPAD_REGISTER_CONTROL, control_flipped);
+  return NFP_SUCCESS;
+
+}
+
+/* get status/error registers ----------------------------------- */
+
+static nfp_err i21555_get_status( nfdev_status_str *status, void *ctx ) {
+  nfp_cdev *cdev = (nfp_cdev *)ctx;
+  uint32_t status_flipped;
+  uint32_t *error = (uint32_t *)status->error;
+
+  nfp_log( NFP_DBG3, "i21555_get_status: entered");
+  if(!cdev) {
+    nfp_log( NFP_DBG1, "i21555_get_status: NULL cdev");
+    return NFP_ENODEV;
+  }
+  if(!cdev->bar[ CSR_BAR ]) {
+    nfp_log( NFP_DBG1, "i21555_write: null BAR[%d]", CSR_BAR );
+    return NFP_ENOMEM;
+  }
+  status_flipped = nfp_inl( cdev, CSR_BAR, I21555_SCRATCHPAD_REGISTER_STATUS);
+  status->status = FROM_LE32_MEM(&status_flipped);
+  error[0] = nfp_inl( cdev, CSR_BAR, I21555_SCRATCHPAD_REGISTER_ERROR_LO);
+  error[1] = nfp_inl( cdev, CSR_BAR, I21555_SCRATCHPAD_REGISTER_ERROR_HI);
+  return NFP_SUCCESS;
+}
+
+/* command device structure ------------------------------------- */
+
+const nfpcmd_dev i21555_cmddev = {
+  .name = "nCipher Gen 2 PCI",
+  .vendorid = PCI_VENDOR_ID_INTEL,
+  .deviceid = PCI_DEVICE_ID_INTEL_21555,
+  .sub_vendorid = PCI_VENDOR_ID_NCIPHER,
+  .sub_deviceid = PCI_SUBSYSTEM_ID_NFAST_REV1,
+  .bar_sizes = BAR_SIZES,
+  .flags = NFP_CMD_FLG_NEED_IOBUF,
+  .max_ifvers = NFDEV_IF_PCI_PUSH,
+  .create = i21555_create,
+  .destroy = i21555_destroy,
+  .open = i21555_open,
+  .close = i21555_close,
+  .isr = i21555_isr,
+  .write_block =  i21555_write,
+  .read_block = i21555_read,
+  .channel_update = i21555_chupdate,
+  .ensure_reading = i21555_ensure_reading,
+  .debug = i21555_debug,
+  .setcontrol = i21555_set_control,
+  .getstatus = i21555_get_status,
+};
diff --git drivers/misc/nshield/i21555.h drivers/misc/nshield/i21555.h
new file mode 100644
index 000000000000..f09d62576275
--- /dev/null
+++ drivers/misc/nshield/i21555.h
@@ -0,0 +1,75 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * (c) nCipher Security Limited 2019
+ *
+ *
+ */
+
+#ifndef I21555_H
+#define I21555_H
+
+#ifndef PCI_VENDOR_ID_INTEL
+#define PCI_VENDOR_ID_INTEL             0x8086
+#endif
+
+#ifndef PCI_DEVICE_ID_INTEL_21555
+#define PCI_DEVICE_ID_INTEL_21555       0xb555
+#endif
+
+#ifndef PCI_VENDOR_ID_NCIPHER
+#define PCI_VENDOR_ID_NCIPHER           0x0100
+#endif
+
+#ifndef PCI_SUBSYSTEM_ID_NFAST_REV1
+#define PCI_SUBSYSTEM_ID_NFAST_REV1     0x0100
+#endif
+
+#define I21555_OFFSET_DOORBELL_PRI_SET		0x9C
+#define I21555_OFFSET_DOORBELL_SEC_SET		0x9E
+#define I21555_OFFSET_DOORBELL_PRI_CLEAR	0x98
+
+#define I21555_OFFSET_DOORBELL_PRI_SET_MASK	0xA4
+#define I21555_OFFSET_DOORBELL_PRI_CLEAR_MASK	0xA0
+
+#define I21555_DOORBELL_PRI_ENABLE 0x0000
+#define I21555_DOORBELL_PRI_DISABLE 0xFFFF
+
+/* 8 32-bit scratchpad registers start here; bridge manual section 11.4 */
+#define I21555_SCRATCHPAD_REGISTER(n)           (0xA8 + 4 * (n))
+
+/* Scratchpad register assignments */
+#define I21555_SCRATCHPAD_REGISTER_CONTROL      I21555_SCRATCHPAD_REGISTER(0)
+#define I21555_SCRATCHPAD_REGISTER_STATUS       I21555_SCRATCHPAD_REGISTER(1)
+#define I21555_SCRATCHPAD_REGISTER_ERROR_LO     I21555_SCRATCHPAD_REGISTER(2)
+#define I21555_SCRATCHPAD_REGISTER_ERROR_HI     I21555_SCRATCHPAD_REGISTER(3)
+
+#define I21555_CFG_SEC_CMD_STATUS 0x44
+
+#define CFG_CMD_MASTER 0x0004
+
+#define MEMBAR1  0
+#define MEMBAR2  2
+
+#define MEMBAR1_SIZE 4096 /* lower 4k of BAR0 map the 21555 CSRs (doorbell IRQs etc) */
+
+#define CSR_BAR MEMBAR1 
+#define BAR_SIZES { MEMBAR1_SIZE, 0, NFPCI_RAM_MINSIZE_JOBS | PCI_BASE_ADDRESS_SPACE_PREFETCHABLE, 0, 0, 0 }
+
+extern nfp_err i21555_debug( int cmd, void *ctx );
+
+#endif
diff --git drivers/misc/nshield/i21555d.c drivers/misc/nshield/i21555d.c
new file mode 100644
index 000000000000..52feb1a76a80
--- /dev/null
+++ drivers/misc/nshield/i21555d.c
@@ -0,0 +1,41 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+i21555d.c: nCipher PCI HSM intel 21555 debug ioctl
+
+ * (c) nCipher Security Limited 2019
+
+history
+
+15/05/2002 jsh  Original, does nothing
+
+*/
+
+#include "nfp_common.h"
+#include "nfp_error.h"
+#include "nfp_osif.h"
+#include "i21555.h"
+
+nfp_err i21555_debug( int cmd, void *ctx) {
+  nfp_log( NFP_DBG1, "i21555_debug: entered");
+
+  (void) cmd;
+  (void) ctx;
+
+  return NFP_EUNKNOWN;
+}
diff --git drivers/misc/nshield/nfdev-common.h drivers/misc/nshield/nfdev-common.h
new file mode 100644
index 000000000000..898eb407b629
--- /dev/null
+++ drivers/misc/nshield/nfdev-common.h
@@ -0,0 +1,197 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/** \file nfdev-common.h
+ *
+ * \brief nFast device driver (not generic SCSI) ioctl struct definition file
+ *  include NFDEV-$(system) for ioctl number definitions
+ *
+ *  1998.07.13	jsh	Started
+ *
+ * 
+ */
+
+#ifndef NFDEV_COMMON_H
+#define NFDEV_COMMON_H
+
+#if defined(__KERNEL__) || defined(__OpenBSD_kernel__)
+/* uint32_t is known about - don't try to define it */
+#else
+/* We need to defined uint32_t somehow */
+#if defined(_WIN32)
+/* int is always 32-bits */
+typedef unsigned int uint32_t;
+#else
+#if defined(__OpenBSD__)
+#include <sys/types.h>
+#else
+/* inttypes.h eventually defines uint32_t */
+#include <inttypes.h>
+#endif
+#endif
+#endif
+
+/**
+ * tchar, plus a shim for non-Windows OSes.
+ */
+#if defined(_WIN32)
+#include <tchar.h>
+#else
+#define TCHAR char
+#define _T(x) (x)
+#endif
+
+/**
+ * Result of the ENQUIRY ioctl.
+ */
+typedef struct nfdev_enquiry_str {
+  uint32_t  busno; /**< Which bus is the PCI device on. */
+  unsigned char slotno; /**< Which slot is the PCI device in. */
+  unsigned char reserved[3]; /**< for consistant struct alignment */
+} nfdev_enquiry_str;
+
+/**
+ * Result of the STATS ioctl.
+ */
+typedef struct nfdev_stats_str {
+  uint32_t  isr; /**< Count interrupts. */
+  uint32_t  isr_read; /**< Count read interrupts. */
+  uint32_t  isr_write; /**< Count write interrupts. */
+  uint32_t  write_fail; /**< Count write failures. */
+  uint32_t  write_block; /**< Count blocks written. */
+  uint32_t  write_byte; /**< Count bytes written. */
+  uint32_t  read_fail; /**< Count read failures. */
+  uint32_t  read_block; /**< Count blocks read. */
+  uint32_t  read_byte; /**< Count bytes read. */
+  uint32_t  ensure_fail; /**< Count read request failures. */
+  uint32_t  ensure; /**< Count read requests. */
+} nfdev_stats_str;
+
+/**
+ * Input to the CONTROL ioctl.
+ */
+typedef struct nfdev_control_str {
+  uint32_t  control; /**< Control flags. */
+} nfdev_control_str;
+
+/** Control bit indicating host supports MOI control */
+#define NFDEV_CONTROL_HOST_MOI 0x0001
+
+/** Index of control bits indicating desired mode
+ *
+ * Desired mode follows the M_ModuleMode enumeration.
+ */
+#define NFDEV_CONTROL_MODE_SHIFT 1
+
+/** Detect a backwards-compatible control value
+ *
+ * Returns true if the request control value "makes no difference", i.e.
+ * and the failure of an attempt to set it is therefore uninteresting.
+ */
+#define NFDEV_CONTROL_HARMLESS(c) ((c) <= 1)
+
+/**
+ * Result of the STATUS ioctl.
+ */
+typedef struct nfdev_status_str {
+  uint32_t  status; /**< Status flags. */
+  char      error[8]; /**< Error string. */
+} nfdev_status_str;
+
+/** Monitor firmware supports MOI control and error reporting */
+#define NFDEV_STATUS_MONITOR_MOI 0x0001
+
+/** Application firmware supports MOI control and error reporting */
+#define NFDEV_STATUS_APPLICATION_MOI 0x0002
+
+/** Application firmware running and supports error reporting */
+#define NFDEV_STATUS_APPLICATION_RUNNING 0x0004
+
+/** HSM failed
+ *
+ * Consult error[] for additional information.
+ */
+#define NFDEV_STATUS_FAILED 0x0008
+
+/** Standard PCI interface. */
+#define NFDEV_IF_STANDARD	0x01
+
+/** PCI interface with read replies pushed from device
+ *  via DMA.
+ */
+#define NFDEV_IF_PCI_PUSH	0x02
+
+/** PCI interface with read replies pushed from device
+ *  and write requests pulled from host via DMA.
+ */
+#define NFDEV_IF_PCI_PULL 0x03
+
+/** Maximum PCI interface. */
+#define NFDEV_IF_MAX_VERS      NFDEV_IF_PCI_PUSH_PULL
+
+/* platform independant base ioctl numbers */
+
+/** Enquiry ioctl.
+ *  \return nfdev_enquiry_str describing the attached device. */
+#define NFDEV_IOCTL_NUM_ENQUIRY        0x01
+
+/** Channel Update ioctl.
+ *  \deprecated */
+#define NFDEV_IOCTL_NUM_CHUPDATE       0x02
+
+/** Ensure Reading ioctl.
+ *  Signal a read request to the device.
+ *  \param (unsigned int) Length of data to be read.
+ */
+#define NFDEV_IOCTL_NUM_ENSUREREADING  0x03
+
+/** Device Count ioctl.
+ *  Not implemented for on all platforms.
+ *  \return (int) the number of attached devices. */
+#define NFDEV_IOCTL_NUM_DEVCOUNT       0x04
+
+/** Internal Debug ioctl.
+ *  Not implemented in release drivers. */
+#define NFDEV_IOCTL_NUM_DEBUG          0x05
+
+/** PCI Interface Version ioctl.
+ *  \param (int) Maximum PCI interface version
+ *   supported by the user of the device. */
+#define NFDEV_IOCTL_NUM_PCI_IFVERS     0x06
+
+/** Statistics ioctl.
+ *  \return nfdev_enquiry_str describing the attached device. */
+#define NFDEV_IOCTL_NUM_STATS          0x07
+
+/** Module control ioctl
+ * \param (nfdev_control_str) Value to write to HSM control register
+ */
+#define NFDEV_IOCTL_NUM_CONTROL        0x08
+
+/** Module state ioctl
+ * \return (nfdev_status_str) Values read from HSM status/error registers
+ */
+#define NFDEV_IOCTL_NUM_STATUS         0x09
+
+/** Module PCI hot reset ioctl
+ *  \param (int) set to 1 to arm hot reset, 0 to stop hot reset */
+#define NFDEV_IOCTL_NUM_PCI_HOT_RESET  0x0A
+
+/** Module PCI hot reset status ioctl
+ * \return (int) hot reset status 1 for in hot reset, 0 not in hot reset */
+#define NFDEV_IOCTL_NUM_PCI_HOT_RESET_STATUS  0x0B
+
+#endif
diff --git drivers/misc/nshield/nfdev-linux.h drivers/misc/nshield/nfdev-linux.h
new file mode 100644
index 000000000000..e060353fe122
--- /dev/null
+++ drivers/misc/nshield/nfdev-linux.h
@@ -0,0 +1,79 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfdev-linux.h: nFast linux specific device ioctl interface.
+
+(C) nCipher Security Limited 2019
+
+history
+
+14/07/1998 jsh  Original
+
+*/
+
+#ifndef NFDEV_LINUX_H
+#define NFDEV_LINUX_H
+
+#include "nfdev-common.h"
+
+#define NFDEV_IOCTL_TYPE 0x10
+
+#define NFDEV_IOCTL_CHUPDATE		_IO( NFDEV_IOCTL_TYPE, \
+					     NFDEV_IOCTL_NUM_CHUPDATE )
+
+#define NFDEV_IOCTL_ENQUIRY		_IOR( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_ENQUIRY, \
+					       nfdev_enquiry_str )
+
+#define NFDEV_IOCTL_ENSUREREADING	_IOW( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_ENSUREREADING, \
+					      int )
+
+#define NFDEV_IOCTL_ENSUREREADING_BUG3349	_IO( NFDEV_IOCTL_TYPE, \
+					     NFDEV_IOCTL_NUM_ENSUREREADING )
+
+
+#define NFDEV_IOCTL_DEBUG		_IOW( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_DEBUG, \
+					      int )
+
+#define NFDEV_IOCTL_PCI_IFVERS		_IOW( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_PCI_IFVERS, \
+					      int )
+
+#define NFDEV_IOCTL_STATS		_IOR( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_STATS, \
+					       nfdev_stats_str )
+
+#define NFDEV_IOCTL_CONTROL		_IOW( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_CONTROL, \
+					      const nfdev_control_str )
+ 
+#define NFDEV_IOCTL_STATUS		_IOR( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_STATUS, \
+					      nfdev_status_str )
+
+#define NFDEV_IOCTL_PCI_HOT_RESET		_IOW( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_PCI_HOT_RESET, \
+					      int )
+
+#define NFDEV_IOCTL_PCI_HOT_RESET_STATUS		_IOR( NFDEV_IOCTL_TYPE, \
+					      NFDEV_IOCTL_NUM_PCI_HOT_RESET_STATUS, \
+					      int )
+
+#endif /* NFDEV_LINUX_H */
diff --git drivers/misc/nshield/nfp_cmd.h drivers/misc/nshield/nfp_cmd.h
new file mode 100644
index 000000000000..96f214fd5b8a
--- /dev/null
+++ drivers/misc/nshield/nfp_cmd.h
@@ -0,0 +1,124 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*************************************************************************
+ *
+ * nfp_cmd.h: nCipher PCI HSM command driver declarations
+ *
+ *-------------------------------------------------------------------------
+ *
+ *-------------------------------------------------------------------------
+ *
+ * Module Description:
+ *
+ *    This file defines the nCipher PCI HSM command driver interface.
+ *
+ *               Copyright (C) nCipher Security Limited 2019
+ *
+ *-------------------------------------------------------------------------
+ *
+ * Notes:
+ *
+ *    Solo cards will provide concrete implementations of this API to
+ *    provide card-specific functionality to complete the interface.
+ *    PCI drivers.
+ *
+ *    10/10/2001 jsh  Original
+ *
+ *************************************************************************/
+
+/** @file
+ *
+ * Defines the nCipher PCI HSM command driver interface.
+ * (c) nCipher Security Limited 2019
+ */
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#ifndef NFPCMD_H
+#define NFPCMD_H
+
+#include "nfp_hostif.h"
+#include "nfp_error.h"
+
+/* read and write called with userspace buffer */
+
+typedef struct nfpcmd_dev
+{
+    const char *name;
+    unsigned short vendorid, deviceid, sub_vendorid, sub_deviceid;
+    unsigned int bar_sizes[NFP_BARSIZES_COUNT];    /* includes IO bit */
+    unsigned int flags, max_ifvers;
+    nfp_err (*create)(struct nfp_cdev *cdev);
+    nfp_err (*destroy)(void * ctx);
+    nfp_err (*started)(struct nfp_cdev *cdev, int lock_flag);
+    nfp_err (*stopped)(struct nfp_cdev *cdev);
+    nfp_err (*open)(void * ctx);
+    nfp_err (*close)(void * ctx);
+    nfp_err (*isr)(void *ctx, int *handled);
+    nfp_err (*write_block)(unsigned int addr, const char *ublock, int len, void *ctx);
+    nfp_err (*read_block)(char *ublock, int len, void *ctx, int *rcount);
+    nfp_err (*channel_update)(char *data, int len, void *ctx);
+    nfp_err (*ensure_reading)(unsigned int addr, int len, void *ctx, int lock_flag);
+    nfp_err (*debug)(int cmd, void *ctx);
+    nfp_err (*setcontrol)(const nfdev_control_str *control, void *ctx); /* may be NULL */
+    nfp_err (*getstatus)(nfdev_status_str *status, void *ctx); /* may be NULL */
+    nfp_err (*hotreset)(void *ctx); /* may be NULL */
+} nfpcmd_dev;
+
+#define NFP_CMD_FLG_NEED_IOBUF  0x1
+#define NFP_CMD_FLG_NEED_MSI    0x2
+
+/* list of all supported drivers ---------------------------------------- */
+
+extern const nfpcmd_dev *nfp_drvlist[];
+
+extern const nfpcmd_dev i21555_cmddev;
+extern const nfpcmd_dev fsl_c293_cmddev;
+extern const nfpcmd_dev fsl_p3041_cmddev;
+extern const nfpcmd_dev fsl_t1022_cmddev;
+extern const nfpcmd_dev bcm5820_cmddev;
+
+#ifndef PCI_BASE_ADDRESS_SPACE_IO
+#define PCI_BASE_ADDRESS_SPACE_IO	0x1
+#endif
+
+#ifndef PCI_BASE_ADDRESS_SPACE_PREFETCHABLE
+#define PCI_BASE_ADDRESS_SPACE_PREFETCHABLE 0x8
+#endif
+
+#define NFP_MAXDEV	16
+
+#define NFP_MEMBAR_MASK    ~0xf
+#define NFP_IOBAR_MASK     ~0x3
+/*
+ This masks off the bottom bits of the PCI_CSR_BAR which signify that the
+ BAR is an IO BAR rather than a MEM BAR
+ */
+
+#define NFP_WITH_LOCK 1
+#define NFP_NO_LOCK   0
+
+#endif /* NFP_CMD_H */
+
+#ifdef __cplusplus
+}
+#endif
+
+/* end of file */
diff --git drivers/misc/nshield/nfp_common.h drivers/misc/nshield/nfp_common.h
new file mode 100644
index 000000000000..fdbe82783160
--- /dev/null
+++ drivers/misc/nshield/nfp_common.h
@@ -0,0 +1,55 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp.h: nCipher PCI HSM Linux OS interface declarations
+
+ * (c) nCipher Security Limited 2019
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#ifndef NFP_COMMON_H
+#define NFP_COMMON_H
+
+#include <linux/types.h>
+
+typedef u_int32_t UINT32;    
+typedef u_int8_t BYTE;      
+
+#define DEFINE_NFPCI_PACKED_STRUCTS
+#include "nfpci.h"
+#include "nfdev-linux.h"
+
+typedef int oserr_t;
+
+/* endian byte sex swapping ------------------------------------------- */
+
+/* little endian systems only for now */
+
+#define FROM_LE32_CONFIG(x) (*x)
+
+#define TO_LE16_MEM(x,y) (*x=y)
+#define FROM_LE16_MEM(x) (*x)
+
+#define TO_LE32_MEM(x,y) (*x=y)
+#define FROM_LE32_MEM(x) (*x)
+
+#endif
diff --git drivers/misc/nshield/nfp_dev.h drivers/misc/nshield/nfp_dev.h
new file mode 100644
index 000000000000..707790ed5696
--- /dev/null
+++ drivers/misc/nshield/nfp_dev.h
@@ -0,0 +1,82 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp_dev.h: nCipher PCI HSM linux device declarations
+
+ * (c) nCipher Security Limited 2019
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#ifndef NFP_DEV_H
+#define NFP_DEV_H
+
+#include "nfp_fixup.h"
+#include "nfp_hostif.h"
+#include "nfp_cmd.h"
+#include "nfp_osif.h"
+
+/* Interpretation of the bits of nfp_dev.rd_outstanding */
+#define WAIT_BIT 0     /* waiting for data */
+#define CMPLT_BIT 1    /* completing a read (got data or timing out) */
+
+typedef struct nfp_dev {
+    struct list_head list;
+
+    nfpcmd_dev const *cmddev;
+
+    nfp_cdev common;
+
+    int iosize[6];
+  
+    unsigned int irq;
+  
+    unsigned char *read_buf;
+    dma_addr_t     read_dma;
+  
+    unsigned char *write_buf;
+    dma_addr_t     write_dma;
+ 
+    struct pci_dev *pcidev;
+  
+    int busy;
+    int ifvers;
+    struct timer_list rd_timer;
+
+
+    nfp_wait_queue_head_t rd_queue;
+    long unsigned rd_ready;
+    long unsigned rd_outstanding;
+    int rd_ok;
+
+
+    nfp_wait_queue_head_t wr_queue;
+    long unsigned wr_ready;
+    long unsigned wr_outstanding;
+    int wr_ok;
+  
+    spinlock_t spinlock;
+
+    u16 bridge_control_reg;
+  
+} nfp_dev;
+
+#endif
diff --git drivers/misc/nshield/nfp_error.h drivers/misc/nshield/nfp_error.h
new file mode 100644
index 000000000000..0a725f334f9b
--- /dev/null
+++ drivers/misc/nshield/nfp_error.h
@@ -0,0 +1,62 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp_error.h: nCipher PCI HSM error handling
+
+ * (c) nCipher Security Limited 2019
+
+history
+
+05/12/2001 jsh  Original
+
+*/
+
+#ifndef NFP_ERROR_H
+#define NFP_ERROR_H
+
+#include "nfp_common.h"
+
+#define NFP_SUCCESS	0x0
+#define NFP_EFAULT      0x1
+#define NFP_ENOMEM	0x2
+#define NFP_EINVAL	0x3
+#define NFP_EIO		0x4
+#define NFP_ENXIO	0x5
+#define NFP_ENODEV	0x6
+#define NFP_EINTR	0x7
+#define NFP_ESTARTING	0x8
+#define NFP_EAGAIN	0x9
+#define NFP_EPOLLING     0xA
+#define NFP_EINTERRUPT   0xB
+#define NFP_EUNKNOWN	0x100
+
+typedef int nfp_err;
+
+extern oserr_t nfp_oserr( nfp_err nerr );
+extern nfp_err nfp_error( oserr_t oerr );
+
+#define nfr( x) \
+  return nfp_error((x))
+
+#define nfer(x, fn, msg) \
+  { oserr_t err=(x); if(err) { nfp_log( NFP_DBG1, #fn ": " msg); return nfp_error(err); } }
+
+#define er(x, fn, msg ) \
+{ nfp_err err=(x); if(err) { nfp_log( NFP_DBG1, #fn ": " msg); return err; } }
+
+#endif
diff --git drivers/misc/nshield/nfp_fixup.h drivers/misc/nshield/nfp_fixup.h
new file mode 100644
index 000000000000..c3dd35a55ea4
--- /dev/null
+++ drivers/misc/nshield/nfp_fixup.h
@@ -0,0 +1,117 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp_fixup.h: nCipher PCI HSM linux version fixup macros
+
+ * (c) nCipher Security Limited 2019
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#ifndef FIXUP_H
+#define FIXUP_H
+
+#define VERSION(ver,rel,seq) (((ver)<<16) | ((rel)<<8) | (seq))
+#include <linux/version.h>
+
+
+#include <linux/types.h>
+#include <linux/time.h>
+#include <asm/io.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+
+#define pci_module_init pci_register_driver
+
+#include <linux/init.h>
+#if LINUX_VERSION_CODE < VERSION(2,6,39)
+#define spinlock_init(plock)  *(plock) = SPIN_LOCK_UNLOCKED
+#else
+#define spinlock_init(plock) *(plock) = __SPIN_LOCK_UNLOCKED(*(plock))
+#endif
+
+#include <linux/moduleparam.h>
+#define NFP_MODULE_PARAMETERS \
+module_param(nfp_debug,int,0644); \
+module_param(nfp_ifvers,int,0444);
+#define NFP_MODULE_PREAMBLE \
+  MODULE_AUTHOR("nCipher"); \
+  MODULE_DESCRIPTION("nCipher PCI HSM driver"); \
+  NFP_MODULE_PARAMETERS \
+  MODULE_PARM_DESC(nfp_debug,"debug level (1-4)"); \
+  MODULE_PARM_DESC(nfp_ifvers,"maximum interface version (1-2), or any (0)");
+
+typedef wait_queue_head_t nfp_wait_queue_head_t;
+#if LINUX_VERSION_CODE < VERSION(4,12,13)
+typedef wait_queue_t nfp_wait_queue_t;
+#else
+typedef wait_queue_entry_t nfp_wait_queue_t;
+#endif
+
+#define nfp_init_waitqueue_head(x)    init_waitqueue_head(x)
+#define nfp_init_waitqueue_entry(x,y) init_waitqueue_entry(x,y)
+#define nfp_wake_up_all(x)          wake_up_all(x)
+
+#define NFP_MAJOR       176
+
+/* NB: most of the 2.1.x dependent code is untested */
+
+#define COPY_FROM_USER(DST,SRC,LEN,error) error = copy_from_user(DST,SRC,LEN) ? -EFAULT : 0
+#define COPY_TO_USER(DST,SRC,LEN,error)   error = copy_to_user(DST,SRC,LEN) ? -EFAULT : 0
+#if LINUX_VERSION_CODE >= VERSION(3,19,0)
+  #define INODE_FROM_FILE( file )       ((file)->f_path.dentry->d_inode)
+#else
+  #define INODE_FROM_FILE( file )       ((file)->f_dentry->d_inode)
+#endif
+
+#include <linux/poll.h>
+typedef ssize_t read_write_t;
+typedef int release_t;
+typedef size_t count_t;
+
+#define RELEASE_RETURN( x ) return x
+#define GET_FREE_PAGES( x, y, z ) __get_free_pages( x, y )
+
+#include <asm/uaccess.h>
+
+#define NFP_TIMEOUT ((NFP_TIMEOUT_SEC) * HZ)
+#define IOUNMAP(ADDR)                 iounmap(ADDR)
+#define nfp_schedule_timeout(time, timeout) \
+  timeout = schedule_timeout(time);
+
+#ifdef MODULE_LICENSE
+#define NFP_MODULE_LICENSE \
+  MODULE_LICENSE("GPL");
+#else
+#define NFP_MODULE_LICENSE
+#endif
+
+#endif
+
+
diff --git drivers/misc/nshield/nfp_hostif.h drivers/misc/nshield/nfp_hostif.h
new file mode 100644
index 000000000000..4ec75322feef
--- /dev/null
+++ drivers/misc/nshield/nfp_hostif.h
@@ -0,0 +1,79 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp_hostif.h: nCipher PCI HSM host interface declarations
+
+ * (c) nCipher Security Limited 2019
+
+history
+
+10/10/2001 jsh  Original
+
+*/
+
+#ifndef NFP_HOSTIF_H
+#define NFP_HOSTIF_H
+
+#include "nfdev-common.h"
+
+#define NFP_BARSIZES_COUNT 6
+#define NFP_BARSIZES_MASK ~0xF
+
+struct nfp_dev;
+
+/* common device structure */
+
+typedef struct nfp_cdev {
+  unsigned char *bar[NFP_BARSIZES_COUNT];
+  void *extra[NFP_BARSIZES_COUNT];
+
+  int busno;
+  int slotno;
+
+  void *cmdctx;
+
+  char *iobuf;
+
+  struct nfp_dev* dev;
+
+  struct nfdev_stats_str stats;
+  int active_bar;
+  int created;
+  int conn_status;
+  int detection_type;
+} nfp_cdev;
+
+/* callbacks from command drivers -------------------------------------- */
+
+void nfp_read_complete(  struct nfp_dev *pdev, int ok);
+void nfp_write_complete( struct nfp_dev *pdev, int ok);
+
+#define NFP_READ_MAX (8 * 1024)
+#define NFP_WRITE_MAX (8 * 1024)
+#define NFP_READBUF_SIZE (NFP_READ_MAX + 8)
+#define NFP_WRITEBUF_SIZE (NFP_WRITE_MAX + 8)
+#define NFP_TIMEOUT_SEC 20
+#define NFP_TIMEOUT_MSEC (1000 * NFP_TIMEOUT_SEC)
+#define NFP_DMA_NBYTES_OFFSET (4)
+#define NFP_DMA_ADDRESS_OFFSET (8)
+
+#define NFP_DRVNAME "nCipher nFast PCI driver"
+
+#define NFP_CLSNAME "nfp"
+
+#endif
diff --git drivers/misc/nshield/nfp_ifvers.c drivers/misc/nshield/nfp_ifvers.c
new file mode 100644
index 000000000000..17ea94a5765a
--- /dev/null
+++ drivers/misc/nshield/nfp_ifvers.c
@@ -0,0 +1,66 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * (c) nCipher Security Limited 2019
+ *
+ *
+ */
+/*
+ * nfp_ifervs.c  - common pci interface versioning
+ *
+ * uses:
+ *
+ * int pdev->ifvers
+ *     device interface version
+ *
+ * int nfp_ifvers
+ *     interface version limit
+ * 
+ * int nfp_alloc_pci_push( nfp_dev *pdev )
+ *     allocates resources needed for PCI Push,
+ *     if not already allocated, and return True if successful
+ *
+ * void nfp_free_pci_push( nfp_dev *pdev ) {
+ *     frees any resources allocated to PCI Push
+ */
+
+void nfp_set_ifvers( nfp_dev *pdev, int vers ) {
+#ifdef _WIN32
+#pragma warning(disable:6239)
+#pragma warning(disable:6326)
+#endif
+  if( (nfp_ifvers != 0) && (vers > nfp_ifvers) ) {
+    nfp_log( NFP_DBG2,
+             "nfp_set_ifvers: can't set ifvers %d"
+             " as nfp_ifvers wants max ifvers %d",
+             vers, nfp_ifvers);
+    return;
+  }
+  if( vers >= NFDEV_IF_PCI_PUSH ) {
+    if(!nfp_alloc_pci_push(pdev)) {
+      nfp_log( NFP_DBG1,
+               "nfp_set_ifvers: can't set ifvers %d"
+               " as resources not available",
+               vers);
+      return;
+    }
+  } else {
+    nfp_free_pci_push(pdev);
+  }
+  pdev->ifvers= vers;
+  nfp_log( NFP_DBG3, "nfp_set_ifvers: setting ifvers %d", vers);
+}
diff --git drivers/misc/nshield/nfp_osif.h drivers/misc/nshield/nfp_osif.h
new file mode 100644
index 000000000000..3e23f4f47a33
--- /dev/null
+++ drivers/misc/nshield/nfp_osif.h
@@ -0,0 +1,97 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+nfp_osif.h: nCipher PCI HSM OS interface declarations
+
+ * (c) nCipher Security Limited 2019
+
+history
+
+10/10/2001 jsh  Original
+
+*/
+
+#ifndef NFP_OSIF_H
+#define NFP_OSIF_H
+
+#include "nfp_hostif.h"
+#include "nfp_error.h"
+
+/* implementation choices ----------------------------------------- */
+
+/** ISR strict locking.
+ *
+ * Define this to choose strict locking for state variables changed
+ * within ISR calls. If not defined, we are relying on the implicit
+ * memory barriers in sleeping and waiting functions and the
+ * pseudo-barriers of the read and write related function calls
+ * themselves.
+ */
+#define NFP_USE_ISR_LOCKING
+
+/* general typedefs ----------------------------------------------- */
+
+typedef volatile unsigned int reg32;
+typedef volatile unsigned short reg16;
+typedef volatile unsigned char reg8;
+
+/* timeouts ------------------------------------------------------ */
+
+extern void nfp_sleep( int ms );
+
+/* config space access ------------------------------------------------ */
+
+/* return Little Endian 32 bit config register */
+extern nfp_err nfp_config_inl( nfp_cdev *pdev, int offset, unsigned int *res );
+
+/* io space access ------------------------------------------------ */
+
+extern unsigned int nfp_inl( nfp_cdev *pdev, int bar, int offset );
+extern unsigned short nfp_inw( nfp_cdev *pdev, int bar, int offset );
+extern void nfp_outl( nfp_cdev *pdev, int bar, int offset, unsigned int data );
+extern void nfp_outw( nfp_cdev *pdev, int bar, int offset, unsigned short data );
+
+/* user and device memory space access ---------------------------- */
+
+/* NB these 2 functions are not guarenteed to be re-entrant for a given device */
+extern nfp_err nfp_copy_from_user_to_dev( nfp_cdev *cdev, int bar, int offset, const char *ubuf, int len);
+extern nfp_err nfp_copy_to_user_from_dev( nfp_cdev *cdev, int bar, int offset, char *ubuf, int len);
+
+extern nfp_err nfp_copy_from_user( char *kbuf, const char *ubuf, int len );
+extern nfp_err nfp_copy_to_user( char *ubuf, const char *kbuf, int len );
+
+extern nfp_err nfp_copy_from_dev( nfp_cdev *cdev, int bar, int offset, char *kbuf, int len );
+extern nfp_err nfp_copy_to_dev( nfp_cdev *cdev, int bar, int offset, const char *kbuf, int len);
+
+/* debug ------------------------------------------------------------ */
+
+#define NFP_DBG1	1
+#define NFP_DBGE	NFP_DBG1
+#define NFP_DBG2	2
+#define NFP_DBG3	3
+#define NFP_DBG4	4
+
+#ifdef STRANGE_VARARGS
+extern void nfp_log();
+#else
+extern void nfp_log( int severity, const char *format, ...);
+#endif
+
+extern int nfp_debug;
+
+#endif
diff --git drivers/misc/nshield/nfp_tracepoint.h drivers/misc/nshield/nfp_tracepoint.h
new file mode 100644
index 000000000000..89f749bbbe2b
--- /dev/null
+++ drivers/misc/nshield/nfp_tracepoint.h
@@ -0,0 +1,55 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM nfp
+
+ /* This part must be outside protection */
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH ../../drivers/misc/nshield
+#define TRACE_INCLUDE_FILE nfp_tracepoint
+  
+#if !defined(_NFP_TP_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _NFP_TP_H
+
+#include <linux/tracepoint.h>
+
+/* name - the name of the tracepoint to be created. */
+TRACE_EVENT(nfp_write,
+  /* prototype - the prototype for the tracepoint callbacks */
+  TP_PROTO(size_t count), 
+
+  /* args - the arguments that match the prototype. */
+  TP_ARGS(count), 
+
+  /* struct - the structure that a tracer could use (but is not required to) to store the data passed into the tracepoint. */
+  TP_STRUCT__entry(
+    __field(  size_t, count             )
+  ), 
+  
+  /* assign - the C-like way to assign the data to the structure. */
+  TP_fast_assign(
+  __entry->count = count;
+  ),
+  
+  /* print - the way to output the structure in human readable ASCII format. */
+  TP_printk("count=%zd", __entry->count)
+);
+
+#endif /* _NFP_TP_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
\ No newline at end of file
diff --git drivers/misc/nshield/nfpci.h drivers/misc/nshield/nfpci.h
new file mode 100644
index 000000000000..ca000bad304a
--- /dev/null
+++ drivers/misc/nshield/nfpci.h
@@ -0,0 +1,226 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*************************************************************************
+ *
+ * Project:      NGSolo
+ *
+ *-------------------------------------------------------------------------
+ *
+ *-------------------------------------------------------------------------
+ *
+ * Module Description:
+ *
+ *    This file declares the nFast PCI register interface.
+ *
+ *-------------------------------------------------------------------------
+ *
+ * Notes:
+ *
+ *    This file is duplicated in the host and card repositories. It is
+ *    essential that both copies match!
+ *
+ *    1998.06.09   IH  Started
+ *
+ *
+ * (C) nCipher Security Limited 2019
+ *
+ *
+ *************************************************************************/
+
+/** @file
+ *
+ * Declares the nFast PCI register interface.
+ *
+ * The interface presented by nFast PCI devices consists of:
+ *
+ * - a region of shared RAM used for data transfer & control information
+ * - a doorbell interrupt register, so both sides can give each other interrupts
+ * - a number of DMA channels for transferring data
+ */
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#ifndef NFPCI_H
+#define NFPCI_H
+
+/* Sizes of some regions */
+
+/*
+ * This is the minimum size of shared RAM. In future it may be possible to
+ * negotiate larger sizes of shared RAM or auto-detect how big it is
+ */
+#define NFPCI_RAM_MINSIZE	                0x00100000
+#define NFPCI_RAM_MINSIZE_JOBS	            0x00020000 /* standard jobs only */
+#define NFPCI_RAM_MINSIZE_KERN	            0x00040000 /* standard and kernel jobs */
+
+/* Offsets within shared memory space.
+   The following main regions are:
+     jobs input area
+     jobs output area
+     kernel jobs input area
+     kernel output area
+ */
+
+#define NFPCI_OFFSET_JOBS                   0x00000000
+#define NFPCI_OFFSET_JOBS_WR                0x00000000
+#define NFPCI_OFFSET_JOBS_RD                0x00010000
+#define NFPCI_OFFSET_KERN                   0x00020000
+#define NFPCI_OFFSET_KERN_WR                0x00020000
+#define NFPCI_OFFSET_KERN_RD                0x00030000
+
+/* Interrupts, defined by bit position in doorbell register */
+
+/* Interrupts from device to host */
+#define NFAST_INT_DEVICE_WRITE_OK           0x00000001
+#define NFAST_INT_DEVICE_WRITE_FAILED       0x00000002
+#define NFAST_INT_DEVICE_READ_OK            0x00000004
+#define NFAST_INT_DEVICE_READ_FAILED        0x00000008
+#define NFAST_INT_DEVICE_KERN_WRITE_OK		0x00000010
+#define NFAST_INT_DEVICE_KERN_WRITE_FAILED	0x00000020
+#define NFAST_INT_DEVICE_KERN_READ_OK		0x00000040
+#define NFAST_INT_DEVICE_KERN_READ_FAILED	0x00000080
+
+/* Interrupts from host to device */
+#define NFAST_INT_HOST_WRITE_REQUEST        0x00010000
+#define NFAST_INT_HOST_READ_REQUEST         0x00020000
+#define NFAST_INT_HOST_DEBUG                0x00040000
+#define NFAST_INT_HOST_KERN_WRITE_REQUEST	0x00080000
+#define NFAST_INT_HOST_KERN_READ_REQUEST	0x00100000
+
+/* Ordinary job submission ------------------------ */
+
+/*
+ * The NFPCI_OFFSET_JOBS_WR and NFPCI_OFFSET_JOBS_RD regions
+ * are defined by the following (byte) address offsets.
+ */
+
+#define NFPCI_OFFSET_CONTROL                0x0
+#define NFPCI_OFFSET_LENGTH                 0x4
+#define NFPCI_OFFSET_DATA                   0x8
+#define NFPCI_OFFSET_PUSH_ADDR              0x8
+#define NFPCI_OFFSET_PULL_ADDR              0x8
+
+#define NFPCI_JOBS_WR_CONTROL               (NFPCI_OFFSET_JOBS_WR + NFPCI_OFFSET_CONTROL)
+#define NFPCI_JOBS_WR_LENGTH                (NFPCI_OFFSET_JOBS_WR + NFPCI_OFFSET_LENGTH)
+#define NFPCI_JOBS_WR_DATA                  (NFPCI_OFFSET_JOBS_WR + NFPCI_OFFSET_DATA)
+/* address in PCI space of host buffer for NFPCI_JOB_CONTROL_PCI_PUSH */
+#define NFPCI_JOBS_WR_PULL_ADDR             (NFPCI_OFFSET_JOBS_WR + NFPCI_OFFSET_PULL_ADDR)
+#define NFPCI_MAX_JOBS_WR_LEN               (0x0000FFF8)
+
+#define NFPCI_JOBS_RD_CONTROL               (NFPCI_OFFSET_JOBS_RD + NFPCI_OFFSET_CONTROL)
+#define NFPCI_JOBS_RD_LENGTH                (NFPCI_OFFSET_JOBS_RD + NFPCI_OFFSET_LENGTH)
+#define NFPCI_JOBS_RD_DATA                  (NFPCI_OFFSET_JOBS_RD + NFPCI_OFFSET_DATA)
+/* address in PCI space of host buffer for NFPCI_JOB_CONTROL_PCI_PUSH */
+#define NFPCI_JOBS_RD_PUSH_ADDR             (NFPCI_OFFSET_JOBS_RD + NFPCI_OFFSET_PUSH_ADDR)
+#define NFPCI_MAX_JOBS_RD_LEN               (0x000FFF8)
+
+/* Kernel interface job submission ---------------- */
+
+#define NFPCI_KERN_WR_CONTROL               (NFPCI_OFFSET_KERN_WR + NFPCI_OFFSET_CONTROL)
+#define NFPCI_KERN_WR_LENGTH                (NFPCI_OFFSET_KERN_WR + NFPCI_OFFSET_LENGTH)
+#define NFPCI_KERN_WR_DATA                  (NFPCI_OFFSET_KERN_WR + NFPCI_OFFSET_DATA)
+/* address in PCI space of host buffer for NFPCI_JOB_CONTROL_PCI_PUSH */
+#define NFPCI_KERN_WR_PULL_ADDR             (NFPCI_OFFSET_KERN_WR + NFPCI_OFFSET_PULL_ADDR)
+#define NFPCI_MAX_KERN_WR_LEN               (0x0000FFF8)
+
+#define NFPCI_KERN_RD_CONTROL               (NFPCI_OFFSET_KERN_RD + NFPCI_OFFSET_CONTROL)
+#define NFPCI_KERN_RD_LENGTH                (NFPCI_OFFSET_KERN_RD + NFPCI_OFFSET_LENGTH)
+#define NFPCI_KERN_RD_DATA                  (NFPCI_OFFSET_KERN_RD + NFPCI_OFFSET_DATA)
+/* address in PCI space of host buffer for NFPCI_JOB_CONTROL_PCI_PUSH */
+#define NFPCI_KERN_RD_PUSH_ADDR             (NFPCI_OFFSET_KERN_RD + NFPCI_OFFSET_PUSH_ADDR)
+#define NFPCI_MAX_KERN_RD_LEN               (0x000FFF8)
+
+#ifdef DEFINE_NFPCI_PACKED_STRUCTS
+typedef struct
+{
+    UINT32 controlword;
+    UINT32 length; /* length of data to follow */
+    union
+    {
+        BYTE data[1];
+        UINT32 addr;
+    }uu;
+} NFPCI_JOBS_BLOCK;
+#endif
+
+#define NFPCI_JOB_CONTROL		            0x00000001
+#define NFPCI_JOB_CONTROL_PCI_PUSH          0x00000002
+#define NFPCI_JOB_CONTROL_PCI_PULL          0x00000003
+
+/*
+ The 'Control' word is analogous to the SCSI read/write address;
+ 1 = standard push/pull I/O
+ 2 = push/push I/O
+ 3 = pull/push I/O
+
+ To submit a block of job data, the host:
+ - sets the (32-bit, little-endian) word at NFPCI_JOBS_WR_CONTROL to NFPCI_JOB_CONTROL
+ - sets the word at NFPCI_JOBS_WR_LENGTH to the length of the data
+ - copies the data to NFPCI_JOBS_WR_DATA
+ - sets interrupt NFAST_INT_HOST_WRITE_REQUEST in the doorbell register
+ - awaits the NFAST_INT_DEVICE_WRITE_OK (or _FAILED) interrupts back
+
+ To read a block of jobs back, the host:
+ - sets the word at NFPCI_JOBS_RD_CONTROL to NFPCI_JOB_CONTROL
+ - sets the word at NFPCI_JOBS_RD_LENGTH to the max length for returned data
+ - sets interrupt NFAST_INT_HOST_READ_REQUEST
+ - awaits the NFAST_INT_DEVICE_READ_OK (or _FAILED) interrupt
+ - reads the data from NFPCI_JOBS_RD_DATA; the module will set the word at NFPCI_JOBS_RD_LENGTH to its actual length.
+
+ Optionally the host can request the PCI read data to be pushed to host PCI mapped ram:
+ - allocates a contiguous PCI addressable buffer for a NFPCI_JOBS_BLOCK of max size NFPCI_MAX_JOBS_RD_LEN (or NFPCI_MAX_KERN_RD_LEN) + 8
+ - sets the word at NFPCI_JOBS_RD_CONTROL to NFPCI_JOB_CONTROL_PCI_PUSH
+ - sets the word at NFPCI_JOBS_RD_LENGTH to the max length for returned data
+ - sets the word at NFPCI_JOBS_RD_PUSH_ADDR to be the host PCI address of the buffer
+ - sets interrupt NFAST_INT_HOST_READ_REQUEST
+ - awaits the NFAST_INT_DEVICE_READ_OK (or _FAILED) interrupt
+ - reads the data from the buffer at NFPCI_OFFSET_DATA in the buffer. The module will set NFPCI_OFFSET_LENGTH to the actual length.
+
+ Optionally the host can request the PCI write data to be pulled from host PCI mapped ram:
+ - allocates a contiguous PCI addressable buffer for a NFPCI_JOBS_BLOCK of max size NFPCI_MAX_JOBS_WR_LEN (or NFPCI_MAX_KERN_WR_LEN) + 8
+ - copies the data to the PCI addressable buffer
+ - sets the word at NFPCI_JOBS_WR_CONTROL to NFPCI_JOB_CONTROL_PCI_PULL
+ - sets the word at NFPCI_JOBS_WR_LENGTH to the length of the data
+ - sets the word at NFPCI_JOBS_RD_PULL_ADDR to be the host PCI address of the buffer
+ - sets interrupt NFAST_INT_HOST_WRITE_REQUEST in the doorbell register
+ - awaits the NFAST_INT_DEVICE_WRITE_OK (or _FAILED) interrupts back
+ */
+
+#define NFPCI_SCRATCH_CONTROL       0
+
+#define NFPCI_SCRATCH_CONTROL_HOST_MOI   (1<<0)
+#define NFPCI_SCRATCH_CONTROL_MODE_SHIFT 1
+#define NFPCI_SCRATCH_CONTROL_MODE_MASK  (3<<NFPCI_SCRATCH_CONTROL_MODE_SHIFT)
+
+#define NFPCI_SCRATCH_STATUS        1
+
+#define NFPCI_SCRATCH_STATUS_MONITOR_MOI         (1<<0)
+#define NFPCI_SCRATCH_STATUS_APPLICATION_MOI     (1<<1)
+#define NFPCI_SCRATCH_STATUS_APPLICATION_RUNNING (1<<2)
+#define NFPCI_SCRATCH_STATUS_ERROR               (1<<3)
+
+#define NFPCI_SCRATCH_ERROR_LO      2
+#define NFPCI_SCRATCH_ERROR_HI      3
+
+#endif /* NFPCI_H */
+
+#ifdef __cplusplus
+}
+#endif
diff --git drivers/misc/nshield/osif.c drivers/misc/nshield/osif.c
new file mode 100644
index 000000000000..957f1c36cc66
--- /dev/null
+++ drivers/misc/nshield/osif.c
@@ -0,0 +1,194 @@
+/*
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this source file; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+
+osif.c: nCipher PCI HSM OS interface
+
+ * (c) nCipher Security Limited 2019
+
+history
+
+09/10/2001 jsh  Original
+
+*/
+
+#include "nfp_common.h"
+#include "nfp_error.h"
+#include "nfp_fixup.h"
+#include "nfp_hostif.h"
+#include "nfp_osif.h"
+#include "nfp_error.h"
+#include "autoversion.h"
+#include "nfp_dev.h"
+
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+
+void nfp_sleep( int ms ) {
+  DEFINE_WAIT(wait);
+  nfp_wait_queue_head_t q;
+
+  nfp_init_waitqueue_head( &q );
+
+  prepare_to_wait(&q, &wait, TASK_UNINTERRUPTIBLE);
+  schedule_timeout((ms * HZ) / 1000);
+  finish_wait(&q, &wait);
+}
+
+nfp_err nfp_config_inl( nfp_cdev *pdev, int offset, unsigned int *res ) {
+  if(!pdev->dev || !pdev->dev->pcidev)
+    return NFP_ENODEV;
+  pci_read_config_dword( pdev->dev->pcidev, offset, res);
+  return 0;
+}
+
+/* user space memory access ---------------------------------- */
+
+nfp_err nfp_copy_from_user( char *kbuf, const char *ubuf, int len) {
+  int oserr;
+  long task_state;
+  task_state = current->__state;
+  COPY_FROM_USER(kbuf, ubuf, len, oserr);
+  current->__state = task_state;
+  nfr( oserr );
+}
+
+nfp_err nfp_copy_to_user( char *ubuf, const char *kbuf, int len) {
+  int oserr;
+  long task_state;
+  task_state = current->__state;
+  COPY_TO_USER(ubuf, kbuf, len, oserr);
+  current->__state = task_state;
+  nfr( oserr );
+}
+
+nfp_err nfp_copy_from_user_to_dev( nfp_cdev *cdev, int bar, int offset, const char *ubuf, int len) {
+  int oserr;
+  long task_state;
+  task_state = current->__state;
+  COPY_FROM_USER(cdev->bar[bar] + offset, ubuf, len, oserr);
+  current->__state = task_state;
+  nfr( oserr );
+}
+
+nfp_err nfp_copy_to_user_from_dev( nfp_cdev *cdev, int bar, int offset, char *ubuf, int len) {
+  int oserr;
+  long task_state;
+  task_state = current->__state;
+  COPY_TO_USER(ubuf, cdev->bar[bar] + offset, len, oserr);
+  current->__state = task_state;
+  nfr( oserr );
+}
+
+nfp_err nfp_copy_from_dev( nfp_cdev *cdev, int bar, int offset, char *kbuf, int len) {
+  memcpy( kbuf, cdev->bar[bar] + offset, len);
+  return NFP_SUCCESS;
+}
+
+nfp_err nfp_copy_to_dev( nfp_cdev *cdev, int bar, int offset, const char *kbuf, int len) {
+  memcpy( cdev->bar[bar] + offset, kbuf, len);
+  return NFP_SUCCESS;
+}
+
+/* pci fixed length accessors. The below functions are used predominantly
+ * to access CSR registers in pci memory space. */
+unsigned int nfp_inl( nfp_cdev *pdev, int bar, int offset ) {
+  nfp_log( NFP_DBG3, "nfp_inl: addr %p", pdev->bar[bar] + offset);
+  return ioread32( pdev->bar[bar] + offset );
+}
+
+unsigned short nfp_inw( nfp_cdev *pdev, int bar, int offset ) {
+  nfp_log( NFP_DBG3, "nfp_inl: addr %p", pdev->bar[bar] + offset);
+  return ioread16( pdev->bar[bar] + offset );
+}
+
+void nfp_outl( nfp_cdev *pdev, int bar, int offset, unsigned int data ) {
+  nfp_log( NFP_DBG3, "nfp_outl: addr %p, data %x", pdev->bar[bar] + offset, data);
+  iowrite32( data, pdev->bar[bar] + offset );
+}
+
+void nfp_outw( nfp_cdev *pdev, int bar, int offset, unsigned short data ) {
+  nfp_log( NFP_DBG3, "nfp_outl: addr %p, data %x", pdev->bar[bar] + offset, data);
+  iowrite16( data, pdev->bar[bar] + offset );
+}
+
+/* logging ---------------------------------------------------- */
+
+void nfp_log( int level, const char *fmt, ...)
+{
+  va_list ap;
+
+  switch (level) {
+  case NFP_DBG4: if (nfp_debug < 4) break;
+    fallthrough;
+  case NFP_DBG3: if (nfp_debug < 3) break;
+    fallthrough;
+  case NFP_DBG2: if (nfp_debug < 2) break;
+    fallthrough;
+  case NFP_DBG1: if (nfp_debug < 1) break;
+    fallthrough;
+  default:
+    printk (VERSION_COMPNAME " " VERSION_STRING ": ");
+    va_start(ap, fmt);
+    (void) vprintk(fmt, ap);
+    va_end(ap);
+    printk ("\n");
+    break;
+  }
+}
+
+struct errstr {
+  int oserr;
+  nfp_err nferr;
+};
+
+static struct errstr errtab[] = {
+  { -EFAULT, NFP_EFAULT },
+  { -ENOMEM, NFP_ENOMEM },
+  { -EINVAL, NFP_EINVAL },
+  { -EIO, NFP_EIO },
+  { -ENXIO, NFP_ENXIO },
+  { -ENODEV, NFP_ENODEV },
+  { 0, 0 }
+};
+
+nfp_err nfp_error( int oserr ) {
+  struct errstr *perr;
+  if(!oserr)
+    return 0;
+  perr= errtab;
+  while(perr->nferr) {
+   if(perr->oserr == oserr)
+     return perr->nferr;
+   perr++;
+  }
+  return NFP_EUNKNOWN;
+}
+
+int nfp_oserr( nfp_err nferr )
+{
+  struct errstr *perr;
+  if( nferr == NFP_SUCCESS)
+    return 0;
+  perr= errtab;
+  while(perr->nferr) {
+   if(perr->nferr == nferr)
+     return perr->oserr;
+   perr++;
+  }
+  return -EIO;
+}
